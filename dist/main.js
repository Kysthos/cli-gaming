!function(g){var I={};function n(c){if(I[c])return I[c].exports;var t=I[c]={i:c,l:!1,exports:{}};return g[c].call(t.exports,t,t.exports,n),t.l=!0,t.exports}n.m=g,n.c=I,n.d=function(g,I,c){n.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:c})},n.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},n.t=function(g,I){if(1&I&&(g=n(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var c=Object.create(null);if(n.r(c),Object.defineProperty(c,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var t in g)n.d(c,t,function(I){return g[I]}.bind(null,t));return c},n.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return n.d(I,"a",I),I},n.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},n.p="",n(n.s=25)}([function(module,exports){eval('module.exports = require("path");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJwYXRoXCI/NzRiYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicGF0aFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.objectKeys = exports.assertSingleKey = exports.assertNotStrictEqual = void 0;\nconst assert_1 = __webpack_require__(18);\n/**\n * Typing wrapper around assert.notStrictEqual()\n */\nfunction assertNotStrictEqual(actual, expected, message) {\n    assert_1.notStrictEqual(actual, expected, message);\n}\nexports.assertNotStrictEqual = assertNotStrictEqual;\n/**\n * Asserts actual is a single key, not a key array or a key map.\n */\nfunction assertSingleKey(actual) {\n    assert_1.strictEqual(typeof actual, 'string');\n}\nexports.assertSingleKey = assertSingleKey;\n/**\n * Typing wrapper around Object.keys()\n */\nfunction objectKeys(object) {\n    return Object.keys(object);\n}\nexports.objectKeys = objectKeys;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliL2NvbW1vbi10eXBlcy5qcz81NGQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyxFQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9iamVjdEtleXMgPSBleHBvcnRzLmFzc2VydFNpbmdsZUtleSA9IGV4cG9ydHMuYXNzZXJ0Tm90U3RyaWN0RXF1YWwgPSB2b2lkIDA7XG5jb25zdCBhc3NlcnRfMSA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG4vKipcbiAqIFR5cGluZyB3cmFwcGVyIGFyb3VuZCBhc3NlcnQubm90U3RyaWN0RXF1YWwoKVxuICovXG5mdW5jdGlvbiBhc3NlcnROb3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gICAgYXNzZXJ0XzEubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSk7XG59XG5leHBvcnRzLmFzc2VydE5vdFN0cmljdEVxdWFsID0gYXNzZXJ0Tm90U3RyaWN0RXF1YWw7XG4vKipcbiAqIEFzc2VydHMgYWN0dWFsIGlzIGEgc2luZ2xlIGtleSwgbm90IGEga2V5IGFycmF5IG9yIGEga2V5IG1hcC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0U2luZ2xlS2V5KGFjdHVhbCkge1xuICAgIGFzc2VydF8xLnN0cmljdEVxdWFsKHR5cGVvZiBhY3R1YWwsICdzdHJpbmcnKTtcbn1cbmV4cG9ydHMuYXNzZXJ0U2luZ2xlS2V5ID0gYXNzZXJ0U2luZ2xlS2V5O1xuLyoqXG4gKiBUeXBpbmcgd3JhcHBlciBhcm91bmQgT2JqZWN0LmtleXMoKVxuICovXG5mdW5jdGlvbiBvYmplY3RLZXlzKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpO1xufVxuZXhwb3J0cy5vYmplY3RLZXlzID0gb2JqZWN0S2V5cztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n")},function(module,exports){eval('module.exports = require("fs");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJmc1wiP2E0MGQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImZzXCIpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n')},function(module,exports){eval('module.exports = require("util");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ1dGlsXCI/YmUwYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXRpbFwiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n')},function(module,exports,__webpack_require__){"use strict";eval("\nconst ansiRegex = __webpack_require__(43);\n\nmodule.exports = string => typeof string === 'string' ? string.replace(ansiRegex(), '') : string;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcz83NjcxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2Isa0JBQWtCLG1CQUFPLENBQUMsRUFBWTs7QUFFdEMiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGFuc2lSZWdleCA9IHJlcXVpcmUoJ2Fuc2ktcmVnZXgnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmcgPT4gdHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycgPyBzdHJpbmcucmVwbGFjZShhbnNpUmVnZXgoKSwgJycpIDogc3RyaW5nO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isPromise = void 0;\nfunction isPromise(maybePromise) {\n    return !!maybePromise &&\n        !!maybePromise.then &&\n        (typeof maybePromise.then === 'function');\n}\nexports.isPromise = isPromise;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliL2lzLXByb21pc2UuanM/ZDE1ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNQcm9taXNlID0gdm9pZCAwO1xuZnVuY3Rpb24gaXNQcm9taXNlKG1heWJlUHJvbWlzZSkge1xuICAgIHJldHVybiAhIW1heWJlUHJvbWlzZSAmJlxuICAgICAgICAhIW1heWJlUHJvbWlzZS50aGVuICYmXG4gICAgICAgICh0eXBlb2YgbWF5YmVQcm9taXNlLnRoZW4gPT09ICdmdW5jdGlvbicpO1xufVxuZXhwb3J0cy5pc1Byb21pc2UgPSBpc1Byb21pc2U7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.YError = void 0;\nclass YError extends Error {\n    constructor(msg) {\n        super(msg || 'yargs error');\n        this.name = 'YError';\n        Error.captureStackTrace(this, YError);\n    }\n}\nexports.YError = YError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliL3llcnJvci5qcz82OTFkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuWUVycm9yID0gdm9pZCAwO1xuY2xhc3MgWUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1zZykge1xuICAgICAgICBzdXBlcihtc2cgfHwgJ3lhcmdzIGVycm9yJyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdZRXJyb3InO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBZRXJyb3IpO1xuICAgIH1cbn1cbmV4cG9ydHMuWUVycm9yID0gWUVycm9yO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///6\n")},function(module,exports){eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 7;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliIHN5bmM/ZGIyYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiB3ZWJwYWNrRW1wdHlDb250ZXh0KHJlcSkge1xuXHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0dGhyb3cgZTtcbn1cbndlYnBhY2tFbXB0eUNvbnRleHQua2V5cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH07XG53ZWJwYWNrRW1wdHlDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xud2VicGFja0VtcHR5Q29udGV4dC5pZCA9IDc7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n")},function(module,exports){eval('module.exports = require("events");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJldmVudHNcIj83YTdlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJldmVudHNcIik7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.getBackgroundColor = exports.getForegroundColor = exports.availableColors = void 0;\nvar COLORS = {\n    black: { fg: "black", bg: "bgBlack" },\n    red: { fg: "red", bg: "bgRed" },\n    green: { fg: "green", bg: "bgGreen" },\n    yellow: { fg: "yellow", bg: "bgYellow" },\n    blue: { fg: "blue", bg: "bgBlue" },\n    magenta: { fg: "magenta", bg: "bgMagenta" },\n    cyan: { fg: "cyan", bg: "bgCyan" },\n    white: { fg: "white", bg: "bgWhite" },\n    gray: { fg: "gray", bg: "bgGray" },\n    grey: { fg: "grey", bg: "bgGrey" },\n    blackBright: { fg: "blackBright", bg: "bgBlackBright" },\n    redBright: { fg: "redBright", bg: "bgRedBright" },\n    greenBright: { fg: "greenBright", bg: "bgGreenBright" },\n    yellowBright: { fg: "yellowBright", bg: "bgYellowBright" },\n    blueBright: { fg: "blueBright", bg: "bgBlueBright" },\n    magentaBright: { fg: "magentaBright", bg: "bgMagentaBright" },\n    cyanBright: { fg: "cyanBright", bg: "bgCyanBright" },\n    whiteBright: { fg: "whiteBright", bg: "bgWhiteBright" },\n};\nexports.availableColors = [\n    "magentaBright",\n    "black",\n    "red",\n    "green",\n    "yellow",\n    "blue",\n    "magenta",\n    "cyan",\n    "white",\n    "gray",\n    "grey",\n    "blackBright",\n    "redBright",\n    "greenBright",\n    "yellowBright",\n    "blueBright",\n    "cyanBright",\n    "whiteBright",\n];\n/**\n * Get a chalk acceptable foreground color\n * @param color\n */\nexports.getForegroundColor = function (color) {\n    return COLORS[color].fg;\n};\n/**\n * Get a chalk acceptable background color\n * @param color\n */\nexports.getBackgroundColor = function (color) {\n    return COLORS[color].bg;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29sb3JzLnRzPzA0NjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBNEJBLElBQU0sTUFBTSxHQUFXO0lBQ3JCLEtBQUssRUFBRSxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFLFNBQVMsRUFBRTtJQUNyQyxHQUFHLEVBQUUsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxPQUFPLEVBQUU7SUFDL0IsS0FBSyxFQUFFLEVBQUUsRUFBRSxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUUsU0FBUyxFQUFFO0lBQ3JDLE1BQU0sRUFBRSxFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFLFVBQVUsRUFBRTtJQUN4QyxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUU7SUFDbEMsT0FBTyxFQUFFLEVBQUUsRUFBRSxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQUUsV0FBVyxFQUFFO0lBQzNDLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRTtJQUNsQyxLQUFLLEVBQUUsRUFBRSxFQUFFLEVBQUUsT0FBTyxFQUFFLEVBQUUsRUFBRSxTQUFTLEVBQUU7SUFDckMsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUUsUUFBUSxFQUFFO0lBQ2xDLElBQUksRUFBRSxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRTtJQUNsQyxXQUFXLEVBQUUsRUFBRSxFQUFFLEVBQUUsYUFBYSxFQUFFLEVBQUUsRUFBRSxlQUFlLEVBQUU7SUFDdkQsU0FBUyxFQUFFLEVBQUUsRUFBRSxFQUFFLFdBQVcsRUFBRSxFQUFFLEVBQUUsYUFBYSxFQUFFO0lBQ2pELFdBQVcsRUFBRSxFQUFFLEVBQUUsRUFBRSxhQUFhLEVBQUUsRUFBRSxFQUFFLGVBQWUsRUFBRTtJQUN2RCxZQUFZLEVBQUUsRUFBRSxFQUFFLEVBQUUsY0FBYyxFQUFFLEVBQUUsRUFBRSxnQkFBZ0IsRUFBRTtJQUMxRCxVQUFVLEVBQUUsRUFBRSxFQUFFLEVBQUUsWUFBWSxFQUFFLEVBQUUsRUFBRSxjQUFjLEVBQUU7SUFDcEQsYUFBYSxFQUFFLEVBQUUsRUFBRSxFQUFFLGVBQWUsRUFBRSxFQUFFLEVBQUUsaUJBQWlCLEVBQUU7SUFDN0QsVUFBVSxFQUFFLEVBQUUsRUFBRSxFQUFFLFlBQVksRUFBRSxFQUFFLEVBQUUsY0FBYyxFQUFFO0lBQ3BELFdBQVcsRUFBRSxFQUFFLEVBQUUsRUFBRSxhQUFhLEVBQUUsRUFBRSxFQUFFLGVBQWUsRUFBRTtDQUN4RCxDQUFDO0FBSVcsdUJBQWUsR0FBRztJQUM3QixlQUFlO0lBQ2YsT0FBTztJQUNQLEtBQUs7SUFDTCxPQUFPO0lBQ1AsUUFBUTtJQUNSLE1BQU07SUFDTixTQUFTO0lBQ1QsTUFBTTtJQUNOLE9BQU87SUFDUCxNQUFNO0lBQ04sTUFBTTtJQUNOLGFBQWE7SUFDYixXQUFXO0lBQ1gsYUFBYTtJQUNiLGNBQWM7SUFDZCxZQUFZO0lBQ1osWUFBWTtJQUNaLGFBQWE7Q0FDZCxDQUFDO0FBRUY7OztHQUdHO0FBQ1UsMEJBQWtCLEdBQUcsVUFBQyxLQUFZO0lBQzdDLGFBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO0FBQWhCLENBQWdCLENBQUM7QUFFbkI7OztHQUdHO0FBQ1UsMEJBQWtCLEdBQUcsVUFBQyxLQUFZO0lBQzdDLGFBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO0FBQWhCLENBQWdCLENBQUMiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEZvcmVncm91bmRDb2xvciwgQmFja2dyb3VuZENvbG9yIH0gZnJvbSBcImNoYWxrXCI7XG5cbmludGVyZmFjZSBDb2xvck9iaiB7XG4gIGZnOiB0eXBlb2YgRm9yZWdyb3VuZENvbG9yO1xuICBiZzogdHlwZW9mIEJhY2tncm91bmRDb2xvcjtcbn1cblxuaW50ZXJmYWNlIENvbG9ycyB7XG4gIGJsYWNrOiBDb2xvck9iajtcbiAgcmVkOiBDb2xvck9iajtcbiAgZ3JlZW46IENvbG9yT2JqO1xuICB5ZWxsb3c6IENvbG9yT2JqO1xuICBibHVlOiBDb2xvck9iajtcbiAgbWFnZW50YTogQ29sb3JPYmo7XG4gIGN5YW46IENvbG9yT2JqO1xuICB3aGl0ZTogQ29sb3JPYmo7XG4gIGdyYXk6IENvbG9yT2JqO1xuICBncmV5OiBDb2xvck9iajtcbiAgYmxhY2tCcmlnaHQ6IENvbG9yT2JqO1xuICByZWRCcmlnaHQ6IENvbG9yT2JqO1xuICBncmVlbkJyaWdodDogQ29sb3JPYmo7XG4gIHllbGxvd0JyaWdodDogQ29sb3JPYmo7XG4gIGJsdWVCcmlnaHQ6IENvbG9yT2JqO1xuICBtYWdlbnRhQnJpZ2h0OiBDb2xvck9iajtcbiAgY3lhbkJyaWdodDogQ29sb3JPYmo7XG4gIHdoaXRlQnJpZ2h0OiBDb2xvck9iajtcbn1cblxuY29uc3QgQ09MT1JTOiBDb2xvcnMgPSB7XG4gIGJsYWNrOiB7IGZnOiBcImJsYWNrXCIsIGJnOiBcImJnQmxhY2tcIiB9LFxuICByZWQ6IHsgZmc6IFwicmVkXCIsIGJnOiBcImJnUmVkXCIgfSxcbiAgZ3JlZW46IHsgZmc6IFwiZ3JlZW5cIiwgYmc6IFwiYmdHcmVlblwiIH0sXG4gIHllbGxvdzogeyBmZzogXCJ5ZWxsb3dcIiwgYmc6IFwiYmdZZWxsb3dcIiB9LFxuICBibHVlOiB7IGZnOiBcImJsdWVcIiwgYmc6IFwiYmdCbHVlXCIgfSxcbiAgbWFnZW50YTogeyBmZzogXCJtYWdlbnRhXCIsIGJnOiBcImJnTWFnZW50YVwiIH0sXG4gIGN5YW46IHsgZmc6IFwiY3lhblwiLCBiZzogXCJiZ0N5YW5cIiB9LFxuICB3aGl0ZTogeyBmZzogXCJ3aGl0ZVwiLCBiZzogXCJiZ1doaXRlXCIgfSxcbiAgZ3JheTogeyBmZzogXCJncmF5XCIsIGJnOiBcImJnR3JheVwiIH0sXG4gIGdyZXk6IHsgZmc6IFwiZ3JleVwiLCBiZzogXCJiZ0dyZXlcIiB9LFxuICBibGFja0JyaWdodDogeyBmZzogXCJibGFja0JyaWdodFwiLCBiZzogXCJiZ0JsYWNrQnJpZ2h0XCIgfSxcbiAgcmVkQnJpZ2h0OiB7IGZnOiBcInJlZEJyaWdodFwiLCBiZzogXCJiZ1JlZEJyaWdodFwiIH0sXG4gIGdyZWVuQnJpZ2h0OiB7IGZnOiBcImdyZWVuQnJpZ2h0XCIsIGJnOiBcImJnR3JlZW5CcmlnaHRcIiB9LFxuICB5ZWxsb3dCcmlnaHQ6IHsgZmc6IFwieWVsbG93QnJpZ2h0XCIsIGJnOiBcImJnWWVsbG93QnJpZ2h0XCIgfSxcbiAgYmx1ZUJyaWdodDogeyBmZzogXCJibHVlQnJpZ2h0XCIsIGJnOiBcImJnQmx1ZUJyaWdodFwiIH0sXG4gIG1hZ2VudGFCcmlnaHQ6IHsgZmc6IFwibWFnZW50YUJyaWdodFwiLCBiZzogXCJiZ01hZ2VudGFCcmlnaHRcIiB9LFxuICBjeWFuQnJpZ2h0OiB7IGZnOiBcImN5YW5CcmlnaHRcIiwgYmc6IFwiYmdDeWFuQnJpZ2h0XCIgfSxcbiAgd2hpdGVCcmlnaHQ6IHsgZmc6IFwid2hpdGVCcmlnaHRcIiwgYmc6IFwiYmdXaGl0ZUJyaWdodFwiIH0sXG59O1xuXG5leHBvcnQgdHlwZSBDb2xvciA9IGtleW9mIENvbG9ycztcblxuZXhwb3J0IGNvbnN0IGF2YWlsYWJsZUNvbG9ycyA9IFtcbiAgXCJtYWdlbnRhQnJpZ2h0XCIsXG4gIFwiYmxhY2tcIixcbiAgXCJyZWRcIixcbiAgXCJncmVlblwiLFxuICBcInllbGxvd1wiLFxuICBcImJsdWVcIixcbiAgXCJtYWdlbnRhXCIsXG4gIFwiY3lhblwiLFxuICBcIndoaXRlXCIsXG4gIFwiZ3JheVwiLFxuICBcImdyZXlcIixcbiAgXCJibGFja0JyaWdodFwiLFxuICBcInJlZEJyaWdodFwiLFxuICBcImdyZWVuQnJpZ2h0XCIsXG4gIFwieWVsbG93QnJpZ2h0XCIsXG4gIFwiYmx1ZUJyaWdodFwiLFxuICBcImN5YW5CcmlnaHRcIixcbiAgXCJ3aGl0ZUJyaWdodFwiLFxuXTtcblxuLyoqXG4gKiBHZXQgYSBjaGFsayBhY2NlcHRhYmxlIGZvcmVncm91bmQgY29sb3JcbiAqIEBwYXJhbSBjb2xvclxuICovXG5leHBvcnQgY29uc3QgZ2V0Rm9yZWdyb3VuZENvbG9yID0gKGNvbG9yOiBDb2xvcik6IHR5cGVvZiBGb3JlZ3JvdW5kQ29sb3IgPT5cbiAgQ09MT1JTW2NvbG9yXS5mZztcblxuLyoqXG4gKiBHZXQgYSBjaGFsayBhY2NlcHRhYmxlIGJhY2tncm91bmQgY29sb3JcbiAqIEBwYXJhbSBjb2xvclxuICovXG5leHBvcnQgY29uc3QgZ2V0QmFja2dyb3VuZENvbG9yID0gKGNvbG9yOiBDb2xvcik6IHR5cGVvZiBCYWNrZ3JvdW5kQ29sb3IgPT5cbiAgQ09MT1JTW2NvbG9yXS5iZztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.argsert = void 0;\nconst yerror_1 = __webpack_require__(6);\nconst parse_command_1 = __webpack_require__(11);\nconst positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];\nfunction argsert(arg1, arg2, arg3) {\n    function parseArgs() {\n        return typeof arg1 === 'object'\n            ? [{ demanded: [], optional: [] }, arg1, arg2]\n            : [parse_command_1.parseCommand(`cmd ${arg1}`), arg2, arg3];\n    }\n    // TODO: should this eventually raise an exception.\n    try {\n        // preface the argument description with \"cmd\", so\n        // that we can run it through yargs' command parser.\n        let position = 0;\n        let [parsed, callerArguments, length] = parseArgs();\n        const args = [].slice.call(callerArguments);\n        while (args.length && args[args.length - 1] === undefined)\n            args.pop();\n        length = length || args.length;\n        if (length < parsed.demanded.length) {\n            throw new yerror_1.YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);\n        }\n        const totalCommands = parsed.demanded.length + parsed.optional.length;\n        if (length > totalCommands) {\n            throw new yerror_1.YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);\n        }\n        parsed.demanded.forEach((demanded) => {\n            const arg = args.shift();\n            const observedType = guessType(arg);\n            const matchingTypes = demanded.cmd.filter(type => type === observedType || type === '*');\n            if (matchingTypes.length === 0)\n                argumentTypeError(observedType, demanded.cmd, position);\n            position += 1;\n        });\n        parsed.optional.forEach((optional) => {\n            if (args.length === 0)\n                return;\n            const arg = args.shift();\n            const observedType = guessType(arg);\n            const matchingTypes = optional.cmd.filter(type => type === observedType || type === '*');\n            if (matchingTypes.length === 0)\n                argumentTypeError(observedType, optional.cmd, position);\n            position += 1;\n        });\n    }\n    catch (err) {\n        console.warn(err.stack);\n    }\n}\nexports.argsert = argsert;\nfunction guessType(arg) {\n    if (Array.isArray(arg)) {\n        return 'array';\n    }\n    else if (arg === null) {\n        return 'null';\n    }\n    return typeof arg;\n}\nfunction argumentTypeError(observedType, allowedTypes, position) {\n    throw new yerror_1.YError(`Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliL2FyZ3NlcnQuanM/MzJjNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsQ0FBVTtBQUNuQyx3QkFBd0IsbUJBQU8sQ0FBQyxFQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0MsbURBQW1ELEtBQUs7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLHVCQUF1QixnQkFBZ0IsWUFBWTtBQUNwSTtBQUNBO0FBQ0E7QUFDQSxtRkFBbUYsY0FBYyxnQkFBZ0IsT0FBTztBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQ0FBb0Msc0JBQXNCLDBCQUEwQixnQkFBZ0IsYUFBYTtBQUMxSiIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hcmdzZXJ0ID0gdm9pZCAwO1xuY29uc3QgeWVycm9yXzEgPSByZXF1aXJlKFwiLi95ZXJyb3JcIik7XG5jb25zdCBwYXJzZV9jb21tYW5kXzEgPSByZXF1aXJlKFwiLi9wYXJzZS1jb21tYW5kXCIpO1xuY29uc3QgcG9zaXRpb25OYW1lID0gWydmaXJzdCcsICdzZWNvbmQnLCAndGhpcmQnLCAnZm91cnRoJywgJ2ZpZnRoJywgJ3NpeHRoJ107XG5mdW5jdGlvbiBhcmdzZXJ0KGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBmdW5jdGlvbiBwYXJzZUFyZ3MoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgYXJnMSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgID8gW3sgZGVtYW5kZWQ6IFtdLCBvcHRpb25hbDogW10gfSwgYXJnMSwgYXJnMl1cbiAgICAgICAgICAgIDogW3BhcnNlX2NvbW1hbmRfMS5wYXJzZUNvbW1hbmQoYGNtZCAke2FyZzF9YCksIGFyZzIsIGFyZzNdO1xuICAgIH1cbiAgICAvLyBUT0RPOiBzaG91bGQgdGhpcyBldmVudHVhbGx5IHJhaXNlIGFuIGV4Y2VwdGlvbi5cbiAgICB0cnkge1xuICAgICAgICAvLyBwcmVmYWNlIHRoZSBhcmd1bWVudCBkZXNjcmlwdGlvbiB3aXRoIFwiY21kXCIsIHNvXG4gICAgICAgIC8vIHRoYXQgd2UgY2FuIHJ1biBpdCB0aHJvdWdoIHlhcmdzJyBjb21tYW5kIHBhcnNlci5cbiAgICAgICAgbGV0IHBvc2l0aW9uID0gMDtcbiAgICAgICAgbGV0IFtwYXJzZWQsIGNhbGxlckFyZ3VtZW50cywgbGVuZ3RoXSA9IHBhcnNlQXJncygpO1xuICAgICAgICBjb25zdCBhcmdzID0gW10uc2xpY2UuY2FsbChjYWxsZXJBcmd1bWVudHMpO1xuICAgICAgICB3aGlsZSAoYXJncy5sZW5ndGggJiYgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgICBsZW5ndGggPSBsZW5ndGggfHwgYXJncy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPCBwYXJzZWQuZGVtYW5kZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgeWVycm9yXzEuWUVycm9yKGBOb3QgZW5vdWdoIGFyZ3VtZW50cyBwcm92aWRlZC4gRXhwZWN0ZWQgJHtwYXJzZWQuZGVtYW5kZWQubGVuZ3RofSBidXQgcmVjZWl2ZWQgJHthcmdzLmxlbmd0aH0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG90YWxDb21tYW5kcyA9IHBhcnNlZC5kZW1hbmRlZC5sZW5ndGggKyBwYXJzZWQub3B0aW9uYWwubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoID4gdG90YWxDb21tYW5kcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHllcnJvcl8xLllFcnJvcihgVG9vIG1hbnkgYXJndW1lbnRzIHByb3ZpZGVkLiBFeHBlY3RlZCBtYXggJHt0b3RhbENvbW1hbmRzfSBidXQgcmVjZWl2ZWQgJHtsZW5ndGh9LmApO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlZC5kZW1hbmRlZC5mb3JFYWNoKChkZW1hbmRlZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXJnID0gYXJncy5zaGlmdCgpO1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZWRUeXBlID0gZ3Vlc3NUeXBlKGFyZyk7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZ1R5cGVzID0gZGVtYW5kZWQuY21kLmZpbHRlcih0eXBlID0+IHR5cGUgPT09IG9ic2VydmVkVHlwZSB8fCB0eXBlID09PSAnKicpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nVHlwZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIGFyZ3VtZW50VHlwZUVycm9yKG9ic2VydmVkVHlwZSwgZGVtYW5kZWQuY21kLCBwb3NpdGlvbik7XG4gICAgICAgICAgICBwb3NpdGlvbiArPSAxO1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyc2VkLm9wdGlvbmFsLmZvckVhY2goKG9wdGlvbmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgYXJnID0gYXJncy5zaGlmdCgpO1xuICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZWRUeXBlID0gZ3Vlc3NUeXBlKGFyZyk7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZ1R5cGVzID0gb3B0aW9uYWwuY21kLmZpbHRlcih0eXBlID0+IHR5cGUgPT09IG9ic2VydmVkVHlwZSB8fCB0eXBlID09PSAnKicpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nVHlwZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIGFyZ3VtZW50VHlwZUVycm9yKG9ic2VydmVkVHlwZSwgb3B0aW9uYWwuY21kLCBwb3NpdGlvbik7XG4gICAgICAgICAgICBwb3NpdGlvbiArPSAxO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLndhcm4oZXJyLnN0YWNrKTtcbiAgICB9XG59XG5leHBvcnRzLmFyZ3NlcnQgPSBhcmdzZXJ0O1xuZnVuY3Rpb24gZ3Vlc3NUeXBlKGFyZykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIGFyZztcbn1cbmZ1bmN0aW9uIGFyZ3VtZW50VHlwZUVycm9yKG9ic2VydmVkVHlwZSwgYWxsb3dlZFR5cGVzLCBwb3NpdGlvbikge1xuICAgIHRocm93IG5ldyB5ZXJyb3JfMS5ZRXJyb3IoYEludmFsaWQgJHtwb3NpdGlvbk5hbWVbcG9zaXRpb25dIHx8ICdtYW55aXRoJ30gYXJndW1lbnQuIEV4cGVjdGVkICR7YWxsb3dlZFR5cGVzLmpvaW4oJyBvciAnKX0gYnV0IHJlY2VpdmVkICR7b2JzZXJ2ZWRUeXBlfS5gKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseCommand = void 0;\nfunction parseCommand(cmd) {\n    const extraSpacesStrippedCommand = cmd.replace(/\\s{2,}/g, ' ');\n    const splitCommand = extraSpacesStrippedCommand.split(/\\s+(?![^[]*]|[^<]*>)/);\n    const bregex = /\\.*[\\][<>]/g;\n    const firstCommand = splitCommand.shift();\n    if (!firstCommand)\n        throw new Error(`No command found in: ${cmd}`);\n    const parsedCommand = {\n        cmd: firstCommand.replace(bregex, ''),\n        demanded: [],\n        optional: []\n    };\n    splitCommand.forEach((cmd, i) => {\n        let variadic = false;\n        cmd = cmd.replace(/\\s/g, '');\n        if (/\\.+[\\]>]/.test(cmd) && i === splitCommand.length - 1)\n            variadic = true;\n        if (/^\\[/.test(cmd)) {\n            parsedCommand.optional.push({\n                cmd: cmd.replace(bregex, '').split('|'),\n                variadic\n            });\n        }\n        else {\n            parsedCommand.demanded.push({\n                cmd: cmd.replace(bregex, '').split('|'),\n                variadic\n            });\n        }\n    });\n    return parsedCommand;\n}\nexports.parseCommand = parseCommand;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliL3BhcnNlLWNvbW1hbmQuanM/ZmZiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQSx1REFBdUQsR0FBRztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxJQUFJO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VDb21tYW5kID0gdm9pZCAwO1xuZnVuY3Rpb24gcGFyc2VDb21tYW5kKGNtZCkge1xuICAgIGNvbnN0IGV4dHJhU3BhY2VzU3RyaXBwZWRDb21tYW5kID0gY21kLnJlcGxhY2UoL1xcc3syLH0vZywgJyAnKTtcbiAgICBjb25zdCBzcGxpdENvbW1hbmQgPSBleHRyYVNwYWNlc1N0cmlwcGVkQ29tbWFuZC5zcGxpdCgvXFxzKyg/IVteW10qXXxbXjxdKj4pLyk7XG4gICAgY29uc3QgYnJlZ2V4ID0gL1xcLipbXFxdWzw+XS9nO1xuICAgIGNvbnN0IGZpcnN0Q29tbWFuZCA9IHNwbGl0Q29tbWFuZC5zaGlmdCgpO1xuICAgIGlmICghZmlyc3RDb21tYW5kKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGNvbW1hbmQgZm91bmQgaW46ICR7Y21kfWApO1xuICAgIGNvbnN0IHBhcnNlZENvbW1hbmQgPSB7XG4gICAgICAgIGNtZDogZmlyc3RDb21tYW5kLnJlcGxhY2UoYnJlZ2V4LCAnJyksXG4gICAgICAgIGRlbWFuZGVkOiBbXSxcbiAgICAgICAgb3B0aW9uYWw6IFtdXG4gICAgfTtcbiAgICBzcGxpdENvbW1hbmQuZm9yRWFjaCgoY21kLCBpKSA9PiB7XG4gICAgICAgIGxldCB2YXJpYWRpYyA9IGZhbHNlO1xuICAgICAgICBjbWQgPSBjbWQucmVwbGFjZSgvXFxzL2csICcnKTtcbiAgICAgICAgaWYgKC9cXC4rW1xcXT5dLy50ZXN0KGNtZCkgJiYgaSA9PT0gc3BsaXRDb21tYW5kLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICB2YXJpYWRpYyA9IHRydWU7XG4gICAgICAgIGlmICgvXlxcWy8udGVzdChjbWQpKSB7XG4gICAgICAgICAgICBwYXJzZWRDb21tYW5kLm9wdGlvbmFsLnB1c2goe1xuICAgICAgICAgICAgICAgIGNtZDogY21kLnJlcGxhY2UoYnJlZ2V4LCAnJykuc3BsaXQoJ3wnKSxcbiAgICAgICAgICAgICAgICB2YXJpYWRpY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJzZWRDb21tYW5kLmRlbWFuZGVkLnB1c2goe1xuICAgICAgICAgICAgICAgIGNtZDogY21kLnJlcGxhY2UoYnJlZ2V4LCAnJykuc3BsaXQoJ3wnKSxcbiAgICAgICAgICAgICAgICB2YXJpYWRpY1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcGFyc2VkQ29tbWFuZDtcbn1cbmV4cG9ydHMucGFyc2VDb21tYW5kID0gcGFyc2VDb21tYW5kO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///11\n")},function(module,exports,__webpack_require__){eval("const camelCase = __webpack_require__(53)\nconst decamelize = __webpack_require__(22)\nconst path = __webpack_require__(0)\nconst tokenizeArgString = __webpack_require__(54)\nconst util = __webpack_require__(3)\n\nfunction parse (args, opts) {\n  opts = Object.assign(Object.create(null), opts)\n  // allow a string argument to be passed in rather\n  // than an argv array.\n  args = tokenizeArgString(args)\n\n  // aliases might have transitive relationships, normalize this.\n  const aliases = combineAliases(Object.assign(Object.create(null), opts.alias))\n  const configuration = Object.assign({\n    'boolean-negation': true,\n    'camel-case-expansion': true,\n    'combine-arrays': false,\n    'dot-notation': true,\n    'duplicate-arguments-array': true,\n    'flatten-duplicate-arrays': true,\n    'greedy-arrays': true,\n    'halt-at-non-option': false,\n    'nargs-eats-options': false,\n    'negation-prefix': 'no-',\n    'parse-numbers': true,\n    'populate--': false,\n    'set-placeholder-key': false,\n    'short-option-groups': true,\n    'strip-aliased': false,\n    'strip-dashed': false,\n    'unknown-options-as-args': false\n  }, opts.configuration)\n  const defaults = Object.assign(Object.create(null), opts.default)\n  const configObjects = opts.configObjects || []\n  const envPrefix = opts.envPrefix\n  const notFlagsOption = configuration['populate--']\n  const notFlagsArgv = notFlagsOption ? '--' : '_'\n  const newAliases = Object.create(null)\n  const defaulted = Object.create(null)\n  // allow a i18n handler to be passed in, default to a fake one (util.format).\n  const __ = opts.__ || util.format\n  const flags = {\n    aliases: Object.create(null),\n    arrays: Object.create(null),\n    bools: Object.create(null),\n    strings: Object.create(null),\n    numbers: Object.create(null),\n    counts: Object.create(null),\n    normalize: Object.create(null),\n    configs: Object.create(null),\n    nargs: Object.create(null),\n    coercions: Object.create(null),\n    keys: []\n  }\n  const negative = /^-([0-9]+(\\.[0-9]+)?|\\.[0-9]+)$/\n  const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)')\n\n  ;[].concat(opts.array).filter(Boolean).forEach(function (opt) {\n    const key = opt.key || opt\n\n    // assign to flags[bools|strings|numbers]\n    const assignment = Object.keys(opt).map(function (key) {\n      return ({\n        boolean: 'bools',\n        string: 'strings',\n        number: 'numbers'\n      })[key]\n    }).filter(Boolean).pop()\n\n    // assign key to be coerced\n    if (assignment) {\n      flags[assignment][key] = true\n    }\n\n    flags.arrays[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.boolean).filter(Boolean).forEach(function (key) {\n    flags.bools[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.string).filter(Boolean).forEach(function (key) {\n    flags.strings[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.number).filter(Boolean).forEach(function (key) {\n    flags.numbers[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.count).filter(Boolean).forEach(function (key) {\n    flags.counts[key] = true\n    flags.keys.push(key)\n  })\n\n  ;[].concat(opts.normalize).filter(Boolean).forEach(function (key) {\n    flags.normalize[key] = true\n    flags.keys.push(key)\n  })\n\n  Object.keys(opts.narg || {}).forEach(function (k) {\n    flags.nargs[k] = opts.narg[k]\n    flags.keys.push(k)\n  })\n\n  Object.keys(opts.coerce || {}).forEach(function (k) {\n    flags.coercions[k] = opts.coerce[k]\n    flags.keys.push(k)\n  })\n\n  if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n    ;[].concat(opts.config).filter(Boolean).forEach(function (key) {\n      flags.configs[key] = true\n    })\n  } else {\n    Object.keys(opts.config || {}).forEach(function (k) {\n      flags.configs[k] = opts.config[k]\n    })\n  }\n\n  // create a lookup table that takes into account all\n  // combinations of aliases: {f: ['foo'], foo: ['f']}\n  extendAliases(opts.key, aliases, opts.default, flags.arrays)\n\n  // apply default values to all aliases.\n  Object.keys(defaults).forEach(function (key) {\n    (flags.aliases[key] || []).forEach(function (alias) {\n      defaults[alias] = defaults[key]\n    })\n  })\n\n  let error = null\n  checkConfiguration()\n\n  let notFlags = []\n\n  const argv = Object.assign(Object.create(null), { _: [] })\n  // TODO(bcoe): for the first pass at removing object prototype  we didn't\n  // remove all prototypes from objects returned by this API, we might want\n  // to gradually move towards doing so.\n  const argvReturn = {}\n\n  for (let i = 0; i < args.length; i++) {\n    const arg = args[i]\n    let broken\n    let key\n    let letters\n    let m\n    let next\n    let value\n\n    // any unknown option (except for end-of-options, \"--\")\n    if (arg !== '--' && isUnknownOptionAsArg(arg)) {\n      argv._.push(arg)\n    // -- separated by =\n    } else if (arg.match(/^--.+=/) || (\n      !configuration['short-option-groups'] && arg.match(/^-.+=/)\n    )) {\n      // Using [\\s\\S] instead of . because js doesn't support the\n      // 'dotall' regex modifier. See:\n      // http://stackoverflow.com/a/1068308/13216\n      m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/)\n\n      // arrays format = '--f=a b c'\n      if (checkAllAliases(m[1], flags.arrays)) {\n        i = eatArray(i, m[1], args, m[2])\n      } else if (checkAllAliases(m[1], flags.nargs) !== false) {\n        // nargs format = '--f=monkey washing cat'\n        i = eatNargs(i, m[1], args, m[2])\n      } else {\n        setArg(m[1], m[2])\n      }\n    } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n      key = arg.match(negatedBoolean)[1]\n      setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false)\n\n    // -- separated by space.\n    } else if (arg.match(/^--.+/) || (\n      !configuration['short-option-groups'] && arg.match(/^-[^-]+/)\n    )) {\n      key = arg.match(/^--?(.+)/)[1]\n\n      if (checkAllAliases(key, flags.arrays)) {\n        // array format = '--foo a b c'\n        i = eatArray(i, key, args)\n      } else if (checkAllAliases(key, flags.nargs) !== false) {\n        // nargs format = '--foo a b c'\n        // should be truthy even if: flags.nargs[key] === 0\n        i = eatNargs(i, key, args)\n      } else {\n        next = args[i + 1]\n\n        if (next !== undefined && (!next.match(/^-/) ||\n          next.match(negative)) &&\n          !checkAllAliases(key, flags.bools) &&\n          !checkAllAliases(key, flags.counts)) {\n          setArg(key, next)\n          i++\n        } else if (/^(true|false)$/.test(next)) {\n          setArg(key, next)\n          i++\n        } else {\n          setArg(key, defaultValue(key))\n        }\n      }\n\n    // dot-notation flag separated by '='.\n    } else if (arg.match(/^-.\\..+=/)) {\n      m = arg.match(/^-([^=]+)=([\\s\\S]*)$/)\n      setArg(m[1], m[2])\n\n    // dot-notation flag separated by space.\n    } else if (arg.match(/^-.\\..+/) && !arg.match(negative)) {\n      next = args[i + 1]\n      key = arg.match(/^-(.\\..+)/)[1]\n\n      if (next !== undefined && !next.match(/^-/) &&\n        !checkAllAliases(key, flags.bools) &&\n        !checkAllAliases(key, flags.counts)) {\n        setArg(key, next)\n        i++\n      } else {\n        setArg(key, defaultValue(key))\n      }\n    } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n      letters = arg.slice(1, -1).split('')\n      broken = false\n\n      for (let j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2)\n\n        if (letters[j + 1] && letters[j + 1] === '=') {\n          value = arg.slice(j + 3)\n          key = letters[j]\n\n          if (checkAllAliases(key, flags.arrays)) {\n            // array format = '-f=a b c'\n            i = eatArray(i, key, args, value)\n          } else if (checkAllAliases(key, flags.nargs) !== false) {\n            // nargs format = '-f=monkey washing cat'\n            i = eatNargs(i, key, args, value)\n          } else {\n            setArg(key, value)\n          }\n\n          broken = true\n          break\n        }\n\n        if (next === '-') {\n          setArg(letters[j], next)\n          continue\n        }\n\n        // current letter is an alphabetic character and next value is a number\n        if (/[A-Za-z]/.test(letters[j]) &&\n          /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        }\n\n        if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          setArg(letters[j], next)\n          broken = true\n          break\n        } else {\n          setArg(letters[j], defaultValue(letters[j]))\n        }\n      }\n\n      key = arg.slice(-1)[0]\n\n      if (!broken && key !== '-') {\n        if (checkAllAliases(key, flags.arrays)) {\n          // array format = '-f a b c'\n          i = eatArray(i, key, args)\n        } else if (checkAllAliases(key, flags.nargs) !== false) {\n          // nargs format = '-f a b c'\n          // should be truthy even if: flags.nargs[key] === 0\n          i = eatNargs(i, key, args)\n        } else {\n          next = args[i + 1]\n\n          if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||\n            next.match(negative)) &&\n            !checkAllAliases(key, flags.bools) &&\n            !checkAllAliases(key, flags.counts)) {\n            setArg(key, next)\n            i++\n          } else if (/^(true|false)$/.test(next)) {\n            setArg(key, next)\n            i++\n          } else {\n            setArg(key, defaultValue(key))\n          }\n        }\n      }\n    } else if (arg.match(/^-[0-9]$/) &&\n      arg.match(negative) &&\n      checkAllAliases(arg.slice(1), flags.bools)) {\n      // single-digit boolean alias, e.g: xargs -0\n      key = arg.slice(1)\n      setArg(key, defaultValue(key))\n    } else if (arg === '--') {\n      notFlags = args.slice(i + 1)\n      break\n    } else if (configuration['halt-at-non-option']) {\n      notFlags = args.slice(i)\n      break\n    } else {\n      argv._.push(maybeCoerceNumber('_', arg))\n    }\n  }\n\n  // order of precedence:\n  // 1. command line arg\n  // 2. value from env var\n  // 3. value from config file\n  // 4. value from config objects\n  // 5. configured default value\n  applyEnvVars(argv, true) // special case: check env vars that point to config file\n  applyEnvVars(argv, false)\n  setConfig(argv)\n  setConfigObjects()\n  applyDefaultsAndAliases(argv, flags.aliases, defaults, true)\n  applyCoercions(argv)\n  if (configuration['set-placeholder-key']) setPlaceholderKeys(argv)\n\n  // for any counts either not in args or without an explicit default, set to 0\n  Object.keys(flags.counts).forEach(function (key) {\n    if (!hasKey(argv, key.split('.'))) setArg(key, 0)\n  })\n\n  // '--' defaults to undefined.\n  if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = []\n  notFlags.forEach(function (key) {\n    argv[notFlagsArgv].push(key)\n  })\n\n  if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n    Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\n      delete argv[key]\n    })\n  }\n\n  if (configuration['strip-aliased']) {\n    ;[].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\n      if (configuration['camel-case-expansion']) {\n        delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')]\n      }\n\n      delete argv[alias]\n    })\n  }\n\n  // how many arguments should we consume, based\n  // on the nargs option?\n  function eatNargs (i, key, args, argAfterEqualSign) {\n    let ii\n    let toEat = checkAllAliases(key, flags.nargs)\n    // NaN has a special meaning for the array type, indicating that one or\n    // more values are expected.\n    toEat = isNaN(toEat) ? 1 : toEat\n\n    if (toEat === 0) {\n      if (!isUndefined(argAfterEqualSign)) {\n        error = Error(__('Argument unexpected for: %s', key))\n      }\n      setArg(key, defaultValue(key))\n      return i\n    }\n\n    let available = isUndefined(argAfterEqualSign) ? 0 : 1\n    if (configuration['nargs-eats-options']) {\n      // classic behavior, yargs eats positional and dash arguments.\n      if (args.length - (i + 1) + available < toEat) {\n        error = Error(__('Not enough arguments following: %s', key))\n      }\n      available = toEat\n    } else {\n      // nargs will not consume flag arguments, e.g., -abc, --foo,\n      // and terminates when one is observed.\n      for (ii = i + 1; ii < args.length; ii++) {\n        if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++\n        else break\n      }\n      if (available < toEat) error = Error(__('Not enough arguments following: %s', key))\n    }\n\n    let consumed = Math.min(available, toEat)\n    if (!isUndefined(argAfterEqualSign) && consumed > 0) {\n      setArg(key, argAfterEqualSign)\n      consumed--\n    }\n    for (ii = i + 1; ii < (consumed + i + 1); ii++) {\n      setArg(key, args[ii])\n    }\n\n    return (i + consumed)\n  }\n\n  // if an option is an array, eat all non-hyphenated arguments\n  // following it... YUM!\n  // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n  function eatArray (i, key, args, argAfterEqualSign) {\n    let argsToSet = []\n    let next = argAfterEqualSign || args[i + 1]\n    // If both array and nargs are configured, enforce the nargs count:\n    const nargsCount = checkAllAliases(key, flags.nargs)\n\n    if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {\n      argsToSet.push(true)\n    } else if (isUndefined(next) ||\n        (isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {\n      // for keys without value ==> argsToSet remains an empty []\n      // set user default value, if available\n      if (defaults[key] !== undefined) {\n        const defVal = defaults[key]\n        argsToSet = Array.isArray(defVal) ? defVal : [defVal]\n      }\n    } else {\n      // value in --option=value is eaten as is\n      if (!isUndefined(argAfterEqualSign)) {\n        argsToSet.push(processValue(key, argAfterEqualSign))\n      }\n      for (let ii = i + 1; ii < args.length; ii++) {\n        if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||\n          (nargsCount && argsToSet.length >= nargsCount)) break\n        next = args[ii]\n        if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break\n        i = ii\n        argsToSet.push(processValue(key, next))\n      }\n    }\n\n    // If both array and nargs are configured, create an error if less than\n    // nargs positionals were found. NaN has special meaning, indicating\n    // that at least one value is required (more are okay).\n    if ((nargsCount && argsToSet.length < nargsCount) ||\n        (isNaN(nargsCount) && argsToSet.length === 0)) {\n      error = Error(__('Not enough arguments following: %s', key))\n    }\n\n    setArg(key, argsToSet)\n    return i\n  }\n\n  function setArg (key, val) {\n    if (/-/.test(key) && configuration['camel-case-expansion']) {\n      const alias = key.split('.').map(function (prop) {\n        return camelCase(prop)\n      }).join('.')\n      addNewAlias(key, alias)\n    }\n\n    const value = processValue(key, val)\n    const splitKey = key.split('.')\n    setKey(argv, splitKey, value)\n\n    // handle populating aliases of the full key\n    if (flags.aliases[key]) {\n      flags.aliases[key].forEach(function (x) {\n        x = x.split('.')\n        setKey(argv, x, value)\n      })\n    }\n\n    // handle populating aliases of the first element of the dot-notation key\n    if (splitKey.length > 1 && configuration['dot-notation']) {\n      ;(flags.aliases[splitKey[0]] || []).forEach(function (x) {\n        x = x.split('.')\n\n        // expand alias with nested objects in key\n        const a = [].concat(splitKey)\n        a.shift() // nuke the old key.\n        x = x.concat(a)\n\n        // populate alias only if is not already an alias of the full key\n        // (already populated above)\n        if (!(flags.aliases[key] || []).includes(x.join('.'))) {\n          setKey(argv, x, value)\n        }\n      })\n    }\n\n    // Set normalize getter and setter when key is in 'normalize' but isn't an array\n    if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n      const keys = [key].concat(flags.aliases[key] || [])\n      keys.forEach(function (key) {\n        Object.defineProperty(argvReturn, key, {\n          enumerable: true,\n          get () {\n            return val\n          },\n          set (value) {\n            val = typeof value === 'string' ? path.normalize(value) : value\n          }\n        })\n      })\n    }\n  }\n\n  function addNewAlias (key, alias) {\n    if (!(flags.aliases[key] && flags.aliases[key].length)) {\n      flags.aliases[key] = [alias]\n      newAliases[alias] = true\n    }\n    if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n      addNewAlias(alias, key)\n    }\n  }\n\n  function processValue (key, val) {\n    // strings may be quoted, clean this up as we assign values.\n    if (typeof val === 'string' &&\n      (val[0] === \"'\" || val[0] === '\"') &&\n      val[val.length - 1] === val[0]\n    ) {\n      val = val.substring(1, val.length - 1)\n    }\n\n    // handle parsing boolean arguments --foo=true --bar false.\n    if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n      if (typeof val === 'string') val = val === 'true'\n    }\n\n    let value = Array.isArray(val)\n      ? val.map(function (v) { return maybeCoerceNumber(key, v) })\n      : maybeCoerceNumber(key, val)\n\n    // increment a count given as arg (either no value or value parsed as boolean)\n    if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n      value = increment\n    }\n\n    // Set normalized value when key is in 'normalize' and in 'arrays'\n    if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n      if (Array.isArray(val)) value = val.map(path.normalize)\n      else value = path.normalize(val)\n    }\n    return value\n  }\n\n  function maybeCoerceNumber (key, value) {\n    if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n      const shouldCoerceNumber = isNumber(value) && configuration['parse-numbers'] && (\n        Number.isSafeInteger(Math.floor(value))\n      )\n      if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) value = Number(value)\n    }\n    return value\n  }\n\n  // set args from config.json file, this should be\n  // applied last so that defaults can be applied.\n  function setConfig (argv) {\n    const configLookup = Object.create(null)\n\n    // expand defaults/aliases, in-case any happen to reference\n    // the config.json file.\n    applyDefaultsAndAliases(configLookup, flags.aliases, defaults)\n\n    Object.keys(flags.configs).forEach(function (configKey) {\n      const configPath = argv[configKey] || configLookup[configKey]\n      if (configPath) {\n        try {\n          let config = null\n          const resolvedConfigPath = path.resolve(process.cwd(), configPath)\n\n          if (typeof flags.configs[configKey] === 'function') {\n            try {\n              config = flags.configs[configKey](resolvedConfigPath)\n            } catch (e) {\n              config = e\n            }\n            if (config instanceof Error) {\n              error = config\n              return\n            }\n          } else {\n            config = __webpack_require__(55)(resolvedConfigPath)\n          }\n\n          setConfigObject(config)\n        } catch (ex) {\n          if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath))\n        }\n      }\n    })\n  }\n\n  // set args from config object.\n  // it recursively checks nested objects.\n  function setConfigObject (config, prev) {\n    Object.keys(config).forEach(function (key) {\n      const value = config[key]\n      const fullKey = prev ? prev + '.' + key : key\n\n      // if the value is an inner object and we have dot-notation\n      // enabled, treat inner objects in config the same as\n      // heavily nested dot notations (foo.bar.apple).\n      if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n        // if the value is an object but not an array, check nested object\n        setConfigObject(value, fullKey)\n      } else {\n        // setting arguments via CLI takes precedence over\n        // values within the config file.\n        if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {\n          setArg(fullKey, value)\n        }\n      }\n    })\n  }\n\n  // set all config objects passed in opts\n  function setConfigObjects () {\n    if (typeof configObjects === 'undefined') return\n    configObjects.forEach(function (configObject) {\n      setConfigObject(configObject)\n    })\n  }\n\n  function applyEnvVars (argv, configOnly) {\n    if (typeof envPrefix === 'undefined') return\n\n    const prefix = typeof envPrefix === 'string' ? envPrefix : ''\n    Object.keys(process.env).forEach(function (envVar) {\n      if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n        // get array of nested keys and convert them to camel case\n        const keys = envVar.split('__').map(function (key, i) {\n          if (i === 0) {\n            key = key.substring(prefix.length)\n          }\n          return camelCase(key)\n        })\n\n        if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {\n          setArg(keys.join('.'), process.env[envVar])\n        }\n      }\n    })\n  }\n\n  function applyCoercions (argv) {\n    let coerce\n    const applied = new Set()\n    Object.keys(argv).forEach(function (key) {\n      if (!applied.has(key)) { // If we haven't already coerced this option via one of its aliases\n        coerce = checkAllAliases(key, flags.coercions)\n        if (typeof coerce === 'function') {\n          try {\n            const value = maybeCoerceNumber(key, coerce(argv[key]))\n            ;([].concat(flags.aliases[key] || [], key)).forEach(ali => {\n              applied.add(ali)\n              argv[ali] = value\n            })\n          } catch (err) {\n            error = err\n          }\n        }\n      }\n    })\n  }\n\n  function setPlaceholderKeys (argv) {\n    flags.keys.forEach((key) => {\n      // don't set placeholder keys for dot notation options 'foo.bar'.\n      if (~key.indexOf('.')) return\n      if (typeof argv[key] === 'undefined') argv[key] = undefined\n    })\n    return argv\n  }\n\n  function applyDefaultsAndAliases (obj, aliases, defaults, canLog = false) {\n    Object.keys(defaults).forEach(function (key) {\n      if (!hasKey(obj, key.split('.'))) {\n        setKey(obj, key.split('.'), defaults[key])\n        if (canLog) defaulted[key] = true\n\n        ;(aliases[key] || []).forEach(function (x) {\n          if (hasKey(obj, x.split('.'))) return\n          setKey(obj, x.split('.'), defaults[key])\n        })\n      }\n    })\n  }\n\n  function hasKey (obj, keys) {\n    let o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key) {\n      o = (o[key] || {})\n    })\n\n    const key = keys[keys.length - 1]\n\n    if (typeof o !== 'object') return false\n    else return key in o\n  }\n\n  function setKey (obj, keys, value) {\n    let o = obj\n\n    if (!configuration['dot-notation']) keys = [keys.join('.')]\n\n    keys.slice(0, -1).forEach(function (key, index) {\n      // TODO(bcoe): in the next major version of yargs, switch to\n      // Object.create(null) for dot notation:\n      key = sanitizeKey(key)\n\n      if (typeof o === 'object' && o[key] === undefined) {\n        o[key] = {}\n      }\n\n      if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n        // ensure that o[key] is an array, and that the last item is an empty object.\n        if (Array.isArray(o[key])) {\n          o[key].push({})\n        } else {\n          o[key] = [o[key], {}]\n        }\n\n        // we want to update the empty object at the end of the o[key] array, so set o to that object\n        o = o[key][o[key].length - 1]\n      } else {\n        o = o[key]\n      }\n    })\n\n    // TODO(bcoe): in the next major version of yargs, switch to\n    // Object.create(null) for dot notation:\n    const key = sanitizeKey(keys[keys.length - 1])\n\n    const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays)\n    const isValueArray = Array.isArray(value)\n    let duplicate = configuration['duplicate-arguments-array']\n\n    // nargs has higher priority than duplicate\n    if (!duplicate && checkAllAliases(key, flags.nargs)) {\n      duplicate = true\n      if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {\n        o[key] = undefined\n      }\n    }\n\n    if (value === increment) {\n      o[key] = increment(o[key])\n    } else if (Array.isArray(o[key])) {\n      if (duplicate && isTypeArray && isValueArray) {\n        o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value])\n      } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n        o[key] = value\n      } else {\n        o[key] = o[key].concat([value])\n      }\n    } else if (o[key] === undefined && isTypeArray) {\n      o[key] = isValueArray ? value : [value]\n    } else if (duplicate && !(\n      o[key] === undefined ||\n        checkAllAliases(key, flags.counts) ||\n        checkAllAliases(key, flags.bools)\n    )) {\n      o[key] = [o[key], value]\n    } else {\n      o[key] = value\n    }\n  }\n\n  // extend the aliases list with inferred aliases.\n  function extendAliases (...args) {\n    args.forEach(function (obj) {\n      Object.keys(obj || {}).forEach(function (key) {\n        // short-circuit if we've already added a key\n        // to the aliases array, for example it might\n        // exist in both 'opts.default' and 'opts.key'.\n        if (flags.aliases[key]) return\n\n        flags.aliases[key] = [].concat(aliases[key] || [])\n        // For \"--option-name\", also set argv.optionName\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (/-/.test(x) && configuration['camel-case-expansion']) {\n            const c = camelCase(x)\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c)\n              newAliases[c] = true\n            }\n          }\n        })\n        // For \"--optionName\", also set argv['option-name']\n        flags.aliases[key].concat(key).forEach(function (x) {\n          if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n            const c = decamelize(x, '-')\n            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n              flags.aliases[key].push(c)\n              newAliases[c] = true\n            }\n          }\n        })\n        flags.aliases[key].forEach(function (x) {\n          flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n            return x !== y\n          }))\n        })\n      })\n    })\n  }\n\n  // return the 1st set flag for any of a key's aliases (or false if no flag set)\n  function checkAllAliases (key, flag) {\n    const toCheck = [].concat(flags.aliases[key] || [], key)\n    const keys = Object.keys(flag)\n    const setAlias = toCheck.find(key => keys.includes(key))\n    return setAlias ? flag[setAlias] : false\n  }\n\n  function hasAnyFlag (key) {\n    const toCheck = [].concat(Object.keys(flags).map(k => flags[k]))\n    return toCheck.some(function (flag) {\n      return Array.isArray(flag) ? flag.includes(key) : flag[key]\n    })\n  }\n\n  function hasFlagsMatching (arg, ...patterns) {\n    const toCheck = [].concat(...patterns)\n    return toCheck.some(function (pattern) {\n      const match = arg.match(pattern)\n      return match && hasAnyFlag(match[1])\n    })\n  }\n\n  // based on a simplified version of the short flag group parsing logic\n  function hasAllShortFlags (arg) {\n    // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group\n    if (arg.match(negative) || !arg.match(/^-[^-]+/)) { return false }\n    let hasAllFlags = true\n    let next\n    const letters = arg.slice(1).split('')\n    for (let j = 0; j < letters.length; j++) {\n      next = arg.slice(j + 2)\n\n      if (!hasAnyFlag(letters[j])) {\n        hasAllFlags = false\n        break\n      }\n\n      if ((letters[j + 1] && letters[j + 1] === '=') ||\n        next === '-' ||\n        (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) ||\n        (letters[j + 1] && letters[j + 1].match(/\\W/))) {\n        break\n      }\n    }\n    return hasAllFlags\n  }\n\n  function isUnknownOptionAsArg (arg) {\n    return configuration['unknown-options-as-args'] && isUnknownOption(arg)\n  }\n\n  function isUnknownOption (arg) {\n    // ignore negative numbers\n    if (arg.match(negative)) { return false }\n    // if this is a short option group and all of them are configured, it isn't unknown\n    if (hasAllShortFlags(arg)) { return false }\n    // e.g. '--count=2'\n    const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/\n    // e.g. '-a' or '--arg'\n    const normalFlag = /^-+([^=]+?)$/\n    // e.g. '-a-'\n    const flagEndingInHyphen = /^-+([^=]+?)-$/\n    // e.g. '-abc123'\n    const flagEndingInDigits = /^-+([^=]+?\\d+)$/\n    // e.g. '-a/usr/local'\n    const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/\n    // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method\n    return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters)\n  }\n\n  // make a best effor to pick a default value\n  // for an option based on name and type.\n  function defaultValue (key) {\n    if (!checkAllAliases(key, flags.bools) &&\n        !checkAllAliases(key, flags.counts) &&\n        `${key}` in defaults) {\n      return defaults[key]\n    } else {\n      return defaultForType(guessType(key))\n    }\n  }\n\n  // return a default value, given the type of a flag.,\n  // e.g., key of type 'string' will default to '', rather than 'true'.\n  function defaultForType (type) {\n    const def = {\n      boolean: true,\n      string: '',\n      number: undefined,\n      array: []\n    }\n\n    return def[type]\n  }\n\n  // given a flag, enforce a default type.\n  function guessType (key) {\n    let type = 'boolean'\n    if (checkAllAliases(key, flags.strings)) type = 'string'\n    else if (checkAllAliases(key, flags.numbers)) type = 'number'\n    else if (checkAllAliases(key, flags.bools)) type = 'boolean'\n    else if (checkAllAliases(key, flags.arrays)) type = 'array'\n    return type\n  }\n\n  function isNumber (x) {\n    if (x === null || x === undefined) return false\n    // if loaded from config, may already be a number.\n    if (typeof x === 'number') return true\n    // hexadecimal.\n    if (/^0x[0-9a-f]+$/i.test(x)) return true\n    // don't treat 0123 as a number; as it drops the leading '0'.\n    if (x.length > 1 && x[0] === '0') return false\n    return /^[-]?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/.test(x)\n  }\n\n  function isUndefined (num) {\n    return num === undefined\n  }\n\n  // check user configuration settings for inconsistencies\n  function checkConfiguration () {\n    // count keys should not be set as array/narg\n    Object.keys(flags.counts).find(key => {\n      if (checkAllAliases(key, flags.arrays)) {\n        error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key))\n        return true\n      } else if (checkAllAliases(key, flags.nargs)) {\n        error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key))\n        return true\n      }\n    })\n  }\n\n  return {\n    argv: Object.assign(argvReturn, argv),\n    error: error,\n    aliases: Object.assign({}, flags.aliases),\n    newAliases: Object.assign({}, newAliases),\n    defaulted: Object.assign({}, defaulted),\n    configuration: configuration\n  }\n}\n\n// if any aliases reference each other, we should\n// merge them together.\nfunction combineAliases (aliases) {\n  const aliasArrays = []\n  const combined = Object.create(null)\n  let change = true\n\n  // turn alias lookup hash {key: ['alias1', 'alias2']} into\n  // a simple array ['key', 'alias1', 'alias2']\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push(\n      [].concat(aliases[key], key)\n    )\n  })\n\n  // combine arrays until zero changes are\n  // made in an iteration.\n  while (change) {\n    change = false\n    for (let i = 0; i < aliasArrays.length; i++) {\n      for (let ii = i + 1; ii < aliasArrays.length; ii++) {\n        const intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1\n        })\n\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii])\n          aliasArrays.splice(ii, 1)\n          change = true\n          break\n        }\n      }\n    }\n  }\n\n  // map arrays back to the hash-lookup (de-dupe while\n  // we're at it).\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i\n    })\n    combined[aliasArray.pop()] = aliasArray\n  })\n\n  return combined\n}\n\n// this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\nfunction increment (orig) {\n  return orig !== undefined ? orig + 1 : 1\n}\n\nfunction Parser (args, opts) {\n  const result = parse(args.slice(), opts)\n  return result.argv\n}\n\n// parse arguments and return detailed\n// meta information, aliases, etc.\nParser.detailed = function (args, opts) {\n  return parse(args.slice(), opts)\n}\n\n// TODO(bcoe): in the next major version of yargs, switch to\n// Object.create(null) for dot notation:\nfunction sanitizeKey (key) {\n  if (key === '__proto__') return '___proto___'\n  return key\n}\n\nmodule.exports = Parser\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MtcGFyc2VyL2luZGV4LmpzP2FmYWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsa0JBQWtCLG1CQUFPLENBQUMsRUFBVztBQUNyQyxtQkFBbUIsbUJBQU8sQ0FBQyxFQUFZO0FBQ3ZDLGFBQWEsbUJBQU8sQ0FBQyxDQUFNO0FBQzNCLDBCQUEwQixtQkFBTyxDQUFDLEVBQTJCO0FBQzdELGFBQWEsbUJBQU8sQ0FBQyxDQUFNOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUgsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVILEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUgsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVILDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsR0FBRzs7QUFFSCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILGlDQUFpQztBQUNqQztBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLCtCQUErQjtBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7O0FBRUEsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEscUJBQXFCLG9CQUFvQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsbUNBQW1DO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gscUJBQXFCLHdCQUFRLGtCQUFrQixDQUFDO0FBQ2hEOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixTQUFTO0FBQ1QsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxJQUFJO0FBQ2Y7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGdDQUFnQztBQUNoQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsMEJBQTBCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQywwQkFBMEIseUJBQXlCO0FBQ25EO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNhbWVsQ2FzZSA9IHJlcXVpcmUoJ2NhbWVsY2FzZScpXG5jb25zdCBkZWNhbWVsaXplID0gcmVxdWlyZSgnZGVjYW1lbGl6ZScpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCB0b2tlbml6ZUFyZ1N0cmluZyA9IHJlcXVpcmUoJy4vbGliL3Rva2VuaXplLWFyZy1zdHJpbmcnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG5mdW5jdGlvbiBwYXJzZSAoYXJncywgb3B0cykge1xuICBvcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBvcHRzKVxuICAvLyBhbGxvdyBhIHN0cmluZyBhcmd1bWVudCB0byBiZSBwYXNzZWQgaW4gcmF0aGVyXG4gIC8vIHRoYW4gYW4gYXJndiBhcnJheS5cbiAgYXJncyA9IHRva2VuaXplQXJnU3RyaW5nKGFyZ3MpXG5cbiAgLy8gYWxpYXNlcyBtaWdodCBoYXZlIHRyYW5zaXRpdmUgcmVsYXRpb25zaGlwcywgbm9ybWFsaXplIHRoaXMuXG4gIGNvbnN0IGFsaWFzZXMgPSBjb21iaW5lQWxpYXNlcyhPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIG9wdHMuYWxpYXMpKVxuICBjb25zdCBjb25maWd1cmF0aW9uID0gT2JqZWN0LmFzc2lnbih7XG4gICAgJ2Jvb2xlYW4tbmVnYXRpb24nOiB0cnVlLFxuICAgICdjYW1lbC1jYXNlLWV4cGFuc2lvbic6IHRydWUsXG4gICAgJ2NvbWJpbmUtYXJyYXlzJzogZmFsc2UsXG4gICAgJ2RvdC1ub3RhdGlvbic6IHRydWUsXG4gICAgJ2R1cGxpY2F0ZS1hcmd1bWVudHMtYXJyYXknOiB0cnVlLFxuICAgICdmbGF0dGVuLWR1cGxpY2F0ZS1hcnJheXMnOiB0cnVlLFxuICAgICdncmVlZHktYXJyYXlzJzogdHJ1ZSxcbiAgICAnaGFsdC1hdC1ub24tb3B0aW9uJzogZmFsc2UsXG4gICAgJ25hcmdzLWVhdHMtb3B0aW9ucyc6IGZhbHNlLFxuICAgICduZWdhdGlvbi1wcmVmaXgnOiAnbm8tJyxcbiAgICAncGFyc2UtbnVtYmVycyc6IHRydWUsXG4gICAgJ3BvcHVsYXRlLS0nOiBmYWxzZSxcbiAgICAnc2V0LXBsYWNlaG9sZGVyLWtleSc6IGZhbHNlLFxuICAgICdzaG9ydC1vcHRpb24tZ3JvdXBzJzogdHJ1ZSxcbiAgICAnc3RyaXAtYWxpYXNlZCc6IGZhbHNlLFxuICAgICdzdHJpcC1kYXNoZWQnOiBmYWxzZSxcbiAgICAndW5rbm93bi1vcHRpb25zLWFzLWFyZ3MnOiBmYWxzZVxuICB9LCBvcHRzLmNvbmZpZ3VyYXRpb24pXG4gIGNvbnN0IGRlZmF1bHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCBvcHRzLmRlZmF1bHQpXG4gIGNvbnN0IGNvbmZpZ09iamVjdHMgPSBvcHRzLmNvbmZpZ09iamVjdHMgfHwgW11cbiAgY29uc3QgZW52UHJlZml4ID0gb3B0cy5lbnZQcmVmaXhcbiAgY29uc3Qgbm90RmxhZ3NPcHRpb24gPSBjb25maWd1cmF0aW9uWydwb3B1bGF0ZS0tJ11cbiAgY29uc3Qgbm90RmxhZ3NBcmd2ID0gbm90RmxhZ3NPcHRpb24gPyAnLS0nIDogJ18nXG4gIGNvbnN0IG5ld0FsaWFzZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG4gIGNvbnN0IGRlZmF1bHRlZCA9IE9iamVjdC5jcmVhdGUobnVsbClcbiAgLy8gYWxsb3cgYSBpMThuIGhhbmRsZXIgdG8gYmUgcGFzc2VkIGluLCBkZWZhdWx0IHRvIGEgZmFrZSBvbmUgKHV0aWwuZm9ybWF0KS5cbiAgY29uc3QgX18gPSBvcHRzLl9fIHx8IHV0aWwuZm9ybWF0XG4gIGNvbnN0IGZsYWdzID0ge1xuICAgIGFsaWFzZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgYXJyYXlzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIGJvb2xzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIHN0cmluZ3M6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgbnVtYmVyczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICBjb3VudHM6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgbm9ybWFsaXplOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIGNvbmZpZ3M6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgbmFyZ3M6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgY29lcmNpb25zOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIGtleXM6IFtdXG4gIH1cbiAgY29uc3QgbmVnYXRpdmUgPSAvXi0oWzAtOV0rKFxcLlswLTldKyk/fFxcLlswLTldKykkL1xuICBjb25zdCBuZWdhdGVkQm9vbGVhbiA9IG5ldyBSZWdFeHAoJ14tLScgKyBjb25maWd1cmF0aW9uWyduZWdhdGlvbi1wcmVmaXgnXSArICcoLispJylcblxuICA7W10uY29uY2F0KG9wdHMuYXJyYXkpLmZpbHRlcihCb29sZWFuKS5mb3JFYWNoKGZ1bmN0aW9uIChvcHQpIHtcbiAgICBjb25zdCBrZXkgPSBvcHQua2V5IHx8IG9wdFxuXG4gICAgLy8gYXNzaWduIHRvIGZsYWdzW2Jvb2xzfHN0cmluZ3N8bnVtYmVyc11cbiAgICBjb25zdCBhc3NpZ25tZW50ID0gT2JqZWN0LmtleXMob3B0KS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuICh7XG4gICAgICAgIGJvb2xlYW46ICdib29scycsXG4gICAgICAgIHN0cmluZzogJ3N0cmluZ3MnLFxuICAgICAgICBudW1iZXI6ICdudW1iZXJzJ1xuICAgICAgfSlba2V5XVxuICAgIH0pLmZpbHRlcihCb29sZWFuKS5wb3AoKVxuXG4gICAgLy8gYXNzaWduIGtleSB0byBiZSBjb2VyY2VkXG4gICAgaWYgKGFzc2lnbm1lbnQpIHtcbiAgICAgIGZsYWdzW2Fzc2lnbm1lbnRdW2tleV0gPSB0cnVlXG4gICAgfVxuXG4gICAgZmxhZ3MuYXJyYXlzW2tleV0gPSB0cnVlXG4gICAgZmxhZ3Mua2V5cy5wdXNoKGtleSlcbiAgfSlcblxuICA7W10uY29uY2F0KG9wdHMuYm9vbGVhbikuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGZsYWdzLmJvb2xzW2tleV0gPSB0cnVlXG4gICAgZmxhZ3Mua2V5cy5wdXNoKGtleSlcbiAgfSlcblxuICA7W10uY29uY2F0KG9wdHMuc3RyaW5nKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgZmxhZ3Muc3RyaW5nc1trZXldID0gdHJ1ZVxuICAgIGZsYWdzLmtleXMucHVzaChrZXkpXG4gIH0pXG5cbiAgO1tdLmNvbmNhdChvcHRzLm51bWJlcikuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGZsYWdzLm51bWJlcnNba2V5XSA9IHRydWVcbiAgICBmbGFncy5rZXlzLnB1c2goa2V5KVxuICB9KVxuXG4gIDtbXS5jb25jYXQob3B0cy5jb3VudCkuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGZsYWdzLmNvdW50c1trZXldID0gdHJ1ZVxuICAgIGZsYWdzLmtleXMucHVzaChrZXkpXG4gIH0pXG5cbiAgO1tdLmNvbmNhdChvcHRzLm5vcm1hbGl6ZSkuZmlsdGVyKEJvb2xlYW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGZsYWdzLm5vcm1hbGl6ZVtrZXldID0gdHJ1ZVxuICAgIGZsYWdzLmtleXMucHVzaChrZXkpXG4gIH0pXG5cbiAgT2JqZWN0LmtleXMob3B0cy5uYXJnIHx8IHt9KS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgZmxhZ3MubmFyZ3Nba10gPSBvcHRzLm5hcmdba11cbiAgICBmbGFncy5rZXlzLnB1c2goaylcbiAgfSlcblxuICBPYmplY3Qua2V5cyhvcHRzLmNvZXJjZSB8fCB7fSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIGZsYWdzLmNvZXJjaW9uc1trXSA9IG9wdHMuY29lcmNlW2tdXG4gICAgZmxhZ3Mua2V5cy5wdXNoKGspXG4gIH0pXG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0cy5jb25maWcpIHx8IHR5cGVvZiBvcHRzLmNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICA7W10uY29uY2F0KG9wdHMuY29uZmlnKS5maWx0ZXIoQm9vbGVhbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBmbGFncy5jb25maWdzW2tleV0gPSB0cnVlXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBPYmplY3Qua2V5cyhvcHRzLmNvbmZpZyB8fCB7fSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgZmxhZ3MuY29uZmlnc1trXSA9IG9wdHMuY29uZmlnW2tdXG4gICAgfSlcbiAgfVxuXG4gIC8vIGNyZWF0ZSBhIGxvb2t1cCB0YWJsZSB0aGF0IHRha2VzIGludG8gYWNjb3VudCBhbGxcbiAgLy8gY29tYmluYXRpb25zIG9mIGFsaWFzZXM6IHtmOiBbJ2ZvbyddLCBmb286IFsnZiddfVxuICBleHRlbmRBbGlhc2VzKG9wdHMua2V5LCBhbGlhc2VzLCBvcHRzLmRlZmF1bHQsIGZsYWdzLmFycmF5cylcblxuICAvLyBhcHBseSBkZWZhdWx0IHZhbHVlcyB0byBhbGwgYWxpYXNlcy5cbiAgT2JqZWN0LmtleXMoZGVmYXVsdHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIChmbGFncy5hbGlhc2VzW2tleV0gfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKGFsaWFzKSB7XG4gICAgICBkZWZhdWx0c1thbGlhc10gPSBkZWZhdWx0c1trZXldXG4gICAgfSlcbiAgfSlcblxuICBsZXQgZXJyb3IgPSBudWxsXG4gIGNoZWNrQ29uZmlndXJhdGlvbigpXG5cbiAgbGV0IG5vdEZsYWdzID0gW11cblxuICBjb25zdCBhcmd2ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7IF86IFtdIH0pXG4gIC8vIFRPRE8oYmNvZSk6IGZvciB0aGUgZmlyc3QgcGFzcyBhdCByZW1vdmluZyBvYmplY3QgcHJvdG90eXBlICB3ZSBkaWRuJ3RcbiAgLy8gcmVtb3ZlIGFsbCBwcm90b3R5cGVzIGZyb20gb2JqZWN0cyByZXR1cm5lZCBieSB0aGlzIEFQSSwgd2UgbWlnaHQgd2FudFxuICAvLyB0byBncmFkdWFsbHkgbW92ZSB0b3dhcmRzIGRvaW5nIHNvLlxuICBjb25zdCBhcmd2UmV0dXJuID0ge31cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhcmcgPSBhcmdzW2ldXG4gICAgbGV0IGJyb2tlblxuICAgIGxldCBrZXlcbiAgICBsZXQgbGV0dGVyc1xuICAgIGxldCBtXG4gICAgbGV0IG5leHRcbiAgICBsZXQgdmFsdWVcblxuICAgIC8vIGFueSB1bmtub3duIG9wdGlvbiAoZXhjZXB0IGZvciBlbmQtb2Ytb3B0aW9ucywgXCItLVwiKVxuICAgIGlmIChhcmcgIT09ICctLScgJiYgaXNVbmtub3duT3B0aW9uQXNBcmcoYXJnKSkge1xuICAgICAgYXJndi5fLnB1c2goYXJnKVxuICAgIC8vIC0tIHNlcGFyYXRlZCBieSA9XG4gICAgfSBlbHNlIGlmIChhcmcubWF0Y2goL14tLS4rPS8pIHx8IChcbiAgICAgICFjb25maWd1cmF0aW9uWydzaG9ydC1vcHRpb24tZ3JvdXBzJ10gJiYgYXJnLm1hdGNoKC9eLS4rPS8pXG4gICAgKSkge1xuICAgICAgLy8gVXNpbmcgW1xcc1xcU10gaW5zdGVhZCBvZiAuIGJlY2F1c2UganMgZG9lc24ndCBzdXBwb3J0IHRoZVxuICAgICAgLy8gJ2RvdGFsbCcgcmVnZXggbW9kaWZpZXIuIFNlZTpcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzEwNjgzMDgvMTMyMTZcbiAgICAgIG0gPSBhcmcubWF0Y2goL14tLT8oW149XSspPShbXFxzXFxTXSopJC8pXG5cbiAgICAgIC8vIGFycmF5cyBmb3JtYXQgPSAnLS1mPWEgYiBjJ1xuICAgICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhtWzFdLCBmbGFncy5hcnJheXMpKSB7XG4gICAgICAgIGkgPSBlYXRBcnJheShpLCBtWzFdLCBhcmdzLCBtWzJdKVxuICAgICAgfSBlbHNlIGlmIChjaGVja0FsbEFsaWFzZXMobVsxXSwgZmxhZ3MubmFyZ3MpICE9PSBmYWxzZSkge1xuICAgICAgICAvLyBuYXJncyBmb3JtYXQgPSAnLS1mPW1vbmtleSB3YXNoaW5nIGNhdCdcbiAgICAgICAgaSA9IGVhdE5hcmdzKGksIG1bMV0sIGFyZ3MsIG1bMl0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRBcmcobVsxXSwgbVsyXSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZy5tYXRjaChuZWdhdGVkQm9vbGVhbikgJiYgY29uZmlndXJhdGlvblsnYm9vbGVhbi1uZWdhdGlvbiddKSB7XG4gICAgICBrZXkgPSBhcmcubWF0Y2gobmVnYXRlZEJvb2xlYW4pWzFdXG4gICAgICBzZXRBcmcoa2V5LCBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5hcnJheXMpID8gW2ZhbHNlXSA6IGZhbHNlKVxuXG4gICAgLy8gLS0gc2VwYXJhdGVkIGJ5IHNwYWNlLlxuICAgIH0gZWxzZSBpZiAoYXJnLm1hdGNoKC9eLS0uKy8pIHx8IChcbiAgICAgICFjb25maWd1cmF0aW9uWydzaG9ydC1vcHRpb24tZ3JvdXBzJ10gJiYgYXJnLm1hdGNoKC9eLVteLV0rLylcbiAgICApKSB7XG4gICAgICBrZXkgPSBhcmcubWF0Y2goL14tLT8oLispLylbMV1cblxuICAgICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmFycmF5cykpIHtcbiAgICAgICAgLy8gYXJyYXkgZm9ybWF0ID0gJy0tZm9vIGEgYiBjJ1xuICAgICAgICBpID0gZWF0QXJyYXkoaSwga2V5LCBhcmdzKVxuICAgICAgfSBlbHNlIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5uYXJncykgIT09IGZhbHNlKSB7XG4gICAgICAgIC8vIG5hcmdzIGZvcm1hdCA9ICctLWZvbyBhIGIgYydcbiAgICAgICAgLy8gc2hvdWxkIGJlIHRydXRoeSBldmVuIGlmOiBmbGFncy5uYXJnc1trZXldID09PSAwXG4gICAgICAgIGkgPSBlYXROYXJncyhpLCBrZXksIGFyZ3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0ID0gYXJnc1tpICsgMV1cblxuICAgICAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkICYmICghbmV4dC5tYXRjaCgvXi0vKSB8fFxuICAgICAgICAgIG5leHQubWF0Y2gobmVnYXRpdmUpKSAmJlxuICAgICAgICAgICFjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5ib29scykgJiZcbiAgICAgICAgICAhY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuY291bnRzKSkge1xuICAgICAgICAgIHNldEFyZyhrZXksIG5leHQpXG4gICAgICAgICAgaSsrXG4gICAgICAgIH0gZWxzZSBpZiAoL14odHJ1ZXxmYWxzZSkkLy50ZXN0KG5leHQpKSB7XG4gICAgICAgICAgc2V0QXJnKGtleSwgbmV4dClcbiAgICAgICAgICBpKytcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRBcmcoa2V5LCBkZWZhdWx0VmFsdWUoa2V5KSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgLy8gZG90LW5vdGF0aW9uIGZsYWcgc2VwYXJhdGVkIGJ5ICc9Jy5cbiAgICB9IGVsc2UgaWYgKGFyZy5tYXRjaCgvXi0uXFwuLis9LykpIHtcbiAgICAgIG0gPSBhcmcubWF0Y2goL14tKFtePV0rKT0oW1xcc1xcU10qKSQvKVxuICAgICAgc2V0QXJnKG1bMV0sIG1bMl0pXG5cbiAgICAvLyBkb3Qtbm90YXRpb24gZmxhZyBzZXBhcmF0ZWQgYnkgc3BhY2UuXG4gICAgfSBlbHNlIGlmIChhcmcubWF0Y2goL14tLlxcLi4rLykgJiYgIWFyZy5tYXRjaChuZWdhdGl2ZSkpIHtcbiAgICAgIG5leHQgPSBhcmdzW2kgKyAxXVxuICAgICAga2V5ID0gYXJnLm1hdGNoKC9eLSguXFwuLispLylbMV1cblxuICAgICAgaWYgKG5leHQgIT09IHVuZGVmaW5lZCAmJiAhbmV4dC5tYXRjaCgvXi0vKSAmJlxuICAgICAgICAhY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYm9vbHMpICYmXG4gICAgICAgICFjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5jb3VudHMpKSB7XG4gICAgICAgIHNldEFyZyhrZXksIG5leHQpXG4gICAgICAgIGkrK1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0QXJnKGtleSwgZGVmYXVsdFZhbHVlKGtleSkpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmcubWF0Y2goL14tW14tXSsvKSAmJiAhYXJnLm1hdGNoKG5lZ2F0aXZlKSkge1xuICAgICAgbGV0dGVycyA9IGFyZy5zbGljZSgxLCAtMSkuc3BsaXQoJycpXG4gICAgICBicm9rZW4gPSBmYWxzZVxuXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxldHRlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbmV4dCA9IGFyZy5zbGljZShqICsgMilcblxuICAgICAgICBpZiAobGV0dGVyc1tqICsgMV0gJiYgbGV0dGVyc1tqICsgMV0gPT09ICc9Jykge1xuICAgICAgICAgIHZhbHVlID0gYXJnLnNsaWNlKGogKyAzKVxuICAgICAgICAgIGtleSA9IGxldHRlcnNbal1cblxuICAgICAgICAgIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5hcnJheXMpKSB7XG4gICAgICAgICAgICAvLyBhcnJheSBmb3JtYXQgPSAnLWY9YSBiIGMnXG4gICAgICAgICAgICBpID0gZWF0QXJyYXkoaSwga2V5LCBhcmdzLCB2YWx1ZSlcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLm5hcmdzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIG5hcmdzIGZvcm1hdCA9ICctZj1tb25rZXkgd2FzaGluZyBjYXQnXG4gICAgICAgICAgICBpID0gZWF0TmFyZ3MoaSwga2V5LCBhcmdzLCB2YWx1ZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0QXJnKGtleSwgdmFsdWUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJva2VuID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dCA9PT0gJy0nKSB7XG4gICAgICAgICAgc2V0QXJnKGxldHRlcnNbal0sIG5leHQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGN1cnJlbnQgbGV0dGVyIGlzIGFuIGFscGhhYmV0aWMgY2hhcmFjdGVyIGFuZCBuZXh0IHZhbHVlIGlzIGEgbnVtYmVyXG4gICAgICAgIGlmICgvW0EtWmEtel0vLnRlc3QobGV0dGVyc1tqXSkgJiZcbiAgICAgICAgICAvXi0/XFxkKyhcXC5cXGQqKT8oZS0/XFxkKyk/JC8udGVzdChuZXh0KSkge1xuICAgICAgICAgIHNldEFyZyhsZXR0ZXJzW2pdLCBuZXh0KVxuICAgICAgICAgIGJyb2tlbiA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxldHRlcnNbaiArIDFdICYmIGxldHRlcnNbaiArIDFdLm1hdGNoKC9cXFcvKSkge1xuICAgICAgICAgIHNldEFyZyhsZXR0ZXJzW2pdLCBuZXh0KVxuICAgICAgICAgIGJyb2tlbiA9IHRydWVcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldEFyZyhsZXR0ZXJzW2pdLCBkZWZhdWx0VmFsdWUobGV0dGVyc1tqXSkpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAga2V5ID0gYXJnLnNsaWNlKC0xKVswXVxuXG4gICAgICBpZiAoIWJyb2tlbiAmJiBrZXkgIT09ICctJykge1xuICAgICAgICBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYXJyYXlzKSkge1xuICAgICAgICAgIC8vIGFycmF5IGZvcm1hdCA9ICctZiBhIGIgYydcbiAgICAgICAgICBpID0gZWF0QXJyYXkoaSwga2V5LCBhcmdzKVxuICAgICAgICB9IGVsc2UgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLm5hcmdzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAvLyBuYXJncyBmb3JtYXQgPSAnLWYgYSBiIGMnXG4gICAgICAgICAgLy8gc2hvdWxkIGJlIHRydXRoeSBldmVuIGlmOiBmbGFncy5uYXJnc1trZXldID09PSAwXG4gICAgICAgICAgaSA9IGVhdE5hcmdzKGksIGtleSwgYXJncylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0ID0gYXJnc1tpICsgMV1cblxuICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgKCEvXigtfC0tKVteLV0vLnRlc3QobmV4dCkgfHxcbiAgICAgICAgICAgIG5leHQubWF0Y2gobmVnYXRpdmUpKSAmJlxuICAgICAgICAgICAgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmJvb2xzKSAmJlxuICAgICAgICAgICAgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmNvdW50cykpIHtcbiAgICAgICAgICAgIHNldEFyZyhrZXksIG5leHQpXG4gICAgICAgICAgICBpKytcbiAgICAgICAgICB9IGVsc2UgaWYgKC9eKHRydWV8ZmFsc2UpJC8udGVzdChuZXh0KSkge1xuICAgICAgICAgICAgc2V0QXJnKGtleSwgbmV4dClcbiAgICAgICAgICAgIGkrK1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRBcmcoa2V5LCBkZWZhdWx0VmFsdWUoa2V5KSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZy5tYXRjaCgvXi1bMC05XSQvKSAmJlxuICAgICAgYXJnLm1hdGNoKG5lZ2F0aXZlKSAmJlxuICAgICAgY2hlY2tBbGxBbGlhc2VzKGFyZy5zbGljZSgxKSwgZmxhZ3MuYm9vbHMpKSB7XG4gICAgICAvLyBzaW5nbGUtZGlnaXQgYm9vbGVhbiBhbGlhcywgZS5nOiB4YXJncyAtMFxuICAgICAga2V5ID0gYXJnLnNsaWNlKDEpXG4gICAgICBzZXRBcmcoa2V5LCBkZWZhdWx0VmFsdWUoa2V5KSlcbiAgICB9IGVsc2UgaWYgKGFyZyA9PT0gJy0tJykge1xuICAgICAgbm90RmxhZ3MgPSBhcmdzLnNsaWNlKGkgKyAxKVxuICAgICAgYnJlYWtcbiAgICB9IGVsc2UgaWYgKGNvbmZpZ3VyYXRpb25bJ2hhbHQtYXQtbm9uLW9wdGlvbiddKSB7XG4gICAgICBub3RGbGFncyA9IGFyZ3Muc2xpY2UoaSlcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIHtcbiAgICAgIGFyZ3YuXy5wdXNoKG1heWJlQ29lcmNlTnVtYmVyKCdfJywgYXJnKSlcbiAgICB9XG4gIH1cblxuICAvLyBvcmRlciBvZiBwcmVjZWRlbmNlOlxuICAvLyAxLiBjb21tYW5kIGxpbmUgYXJnXG4gIC8vIDIuIHZhbHVlIGZyb20gZW52IHZhclxuICAvLyAzLiB2YWx1ZSBmcm9tIGNvbmZpZyBmaWxlXG4gIC8vIDQuIHZhbHVlIGZyb20gY29uZmlnIG9iamVjdHNcbiAgLy8gNS4gY29uZmlndXJlZCBkZWZhdWx0IHZhbHVlXG4gIGFwcGx5RW52VmFycyhhcmd2LCB0cnVlKSAvLyBzcGVjaWFsIGNhc2U6IGNoZWNrIGVudiB2YXJzIHRoYXQgcG9pbnQgdG8gY29uZmlnIGZpbGVcbiAgYXBwbHlFbnZWYXJzKGFyZ3YsIGZhbHNlKVxuICBzZXRDb25maWcoYXJndilcbiAgc2V0Q29uZmlnT2JqZWN0cygpXG4gIGFwcGx5RGVmYXVsdHNBbmRBbGlhc2VzKGFyZ3YsIGZsYWdzLmFsaWFzZXMsIGRlZmF1bHRzLCB0cnVlKVxuICBhcHBseUNvZXJjaW9ucyhhcmd2KVxuICBpZiAoY29uZmlndXJhdGlvblsnc2V0LXBsYWNlaG9sZGVyLWtleSddKSBzZXRQbGFjZWhvbGRlcktleXMoYXJndilcblxuICAvLyBmb3IgYW55IGNvdW50cyBlaXRoZXIgbm90IGluIGFyZ3Mgb3Igd2l0aG91dCBhbiBleHBsaWNpdCBkZWZhdWx0LCBzZXQgdG8gMFxuICBPYmplY3Qua2V5cyhmbGFncy5jb3VudHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaGFzS2V5KGFyZ3YsIGtleS5zcGxpdCgnLicpKSkgc2V0QXJnKGtleSwgMClcbiAgfSlcblxuICAvLyAnLS0nIGRlZmF1bHRzIHRvIHVuZGVmaW5lZC5cbiAgaWYgKG5vdEZsYWdzT3B0aW9uICYmIG5vdEZsYWdzLmxlbmd0aCkgYXJndltub3RGbGFnc0FyZ3ZdID0gW11cbiAgbm90RmxhZ3MuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgYXJndltub3RGbGFnc0FyZ3ZdLnB1c2goa2V5KVxuICB9KVxuXG4gIGlmIChjb25maWd1cmF0aW9uWydjYW1lbC1jYXNlLWV4cGFuc2lvbiddICYmIGNvbmZpZ3VyYXRpb25bJ3N0cmlwLWRhc2hlZCddKSB7XG4gICAgT2JqZWN0LmtleXMoYXJndikuZmlsdGVyKGtleSA9PiBrZXkgIT09ICctLScgJiYga2V5LmluY2x1ZGVzKCctJykpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGRlbGV0ZSBhcmd2W2tleV1cbiAgICB9KVxuICB9XG5cbiAgaWYgKGNvbmZpZ3VyYXRpb25bJ3N0cmlwLWFsaWFzZWQnXSkge1xuICAgIDtbXS5jb25jYXQoLi4uT2JqZWN0LmtleXMoYWxpYXNlcykubWFwKGsgPT4gYWxpYXNlc1trXSkpLmZvckVhY2goYWxpYXMgPT4ge1xuICAgICAgaWYgKGNvbmZpZ3VyYXRpb25bJ2NhbWVsLWNhc2UtZXhwYW5zaW9uJ10pIHtcbiAgICAgICAgZGVsZXRlIGFyZ3ZbYWxpYXMuc3BsaXQoJy4nKS5tYXAocHJvcCA9PiBjYW1lbENhc2UocHJvcCkpLmpvaW4oJy4nKV1cbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGFyZ3ZbYWxpYXNdXG4gICAgfSlcbiAgfVxuXG4gIC8vIGhvdyBtYW55IGFyZ3VtZW50cyBzaG91bGQgd2UgY29uc3VtZSwgYmFzZWRcbiAgLy8gb24gdGhlIG5hcmdzIG9wdGlvbj9cbiAgZnVuY3Rpb24gZWF0TmFyZ3MgKGksIGtleSwgYXJncywgYXJnQWZ0ZXJFcXVhbFNpZ24pIHtcbiAgICBsZXQgaWlcbiAgICBsZXQgdG9FYXQgPSBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5uYXJncylcbiAgICAvLyBOYU4gaGFzIGEgc3BlY2lhbCBtZWFuaW5nIGZvciB0aGUgYXJyYXkgdHlwZSwgaW5kaWNhdGluZyB0aGF0IG9uZSBvclxuICAgIC8vIG1vcmUgdmFsdWVzIGFyZSBleHBlY3RlZC5cbiAgICB0b0VhdCA9IGlzTmFOKHRvRWF0KSA/IDEgOiB0b0VhdFxuXG4gICAgaWYgKHRvRWF0ID09PSAwKSB7XG4gICAgICBpZiAoIWlzVW5kZWZpbmVkKGFyZ0FmdGVyRXF1YWxTaWduKSkge1xuICAgICAgICBlcnJvciA9IEVycm9yKF9fKCdBcmd1bWVudCB1bmV4cGVjdGVkIGZvcjogJXMnLCBrZXkpKVxuICAgICAgfVxuICAgICAgc2V0QXJnKGtleSwgZGVmYXVsdFZhbHVlKGtleSkpXG4gICAgICByZXR1cm4gaVxuICAgIH1cblxuICAgIGxldCBhdmFpbGFibGUgPSBpc1VuZGVmaW5lZChhcmdBZnRlckVxdWFsU2lnbikgPyAwIDogMVxuICAgIGlmIChjb25maWd1cmF0aW9uWyduYXJncy1lYXRzLW9wdGlvbnMnXSkge1xuICAgICAgLy8gY2xhc3NpYyBiZWhhdmlvciwgeWFyZ3MgZWF0cyBwb3NpdGlvbmFsIGFuZCBkYXNoIGFyZ3VtZW50cy5cbiAgICAgIGlmIChhcmdzLmxlbmd0aCAtIChpICsgMSkgKyBhdmFpbGFibGUgPCB0b0VhdCkge1xuICAgICAgICBlcnJvciA9IEVycm9yKF9fKCdOb3QgZW5vdWdoIGFyZ3VtZW50cyBmb2xsb3dpbmc6ICVzJywga2V5KSlcbiAgICAgIH1cbiAgICAgIGF2YWlsYWJsZSA9IHRvRWF0XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5hcmdzIHdpbGwgbm90IGNvbnN1bWUgZmxhZyBhcmd1bWVudHMsIGUuZy4sIC1hYmMsIC0tZm9vLFxuICAgICAgLy8gYW5kIHRlcm1pbmF0ZXMgd2hlbiBvbmUgaXMgb2JzZXJ2ZWQuXG4gICAgICBmb3IgKGlpID0gaSArIDE7IGlpIDwgYXJncy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgaWYgKCFhcmdzW2lpXS5tYXRjaCgvXi1bXjAtOV0vKSB8fCBhcmdzW2lpXS5tYXRjaChuZWdhdGl2ZSkgfHwgaXNVbmtub3duT3B0aW9uQXNBcmcoYXJnc1tpaV0pKSBhdmFpbGFibGUrK1xuICAgICAgICBlbHNlIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAoYXZhaWxhYmxlIDwgdG9FYXQpIGVycm9yID0gRXJyb3IoX18oJ05vdCBlbm91Z2ggYXJndW1lbnRzIGZvbGxvd2luZzogJXMnLCBrZXkpKVxuICAgIH1cblxuICAgIGxldCBjb25zdW1lZCA9IE1hdGgubWluKGF2YWlsYWJsZSwgdG9FYXQpXG4gICAgaWYgKCFpc1VuZGVmaW5lZChhcmdBZnRlckVxdWFsU2lnbikgJiYgY29uc3VtZWQgPiAwKSB7XG4gICAgICBzZXRBcmcoa2V5LCBhcmdBZnRlckVxdWFsU2lnbilcbiAgICAgIGNvbnN1bWVkLS1cbiAgICB9XG4gICAgZm9yIChpaSA9IGkgKyAxOyBpaSA8IChjb25zdW1lZCArIGkgKyAxKTsgaWkrKykge1xuICAgICAgc2V0QXJnKGtleSwgYXJnc1tpaV0pXG4gICAgfVxuXG4gICAgcmV0dXJuIChpICsgY29uc3VtZWQpXG4gIH1cblxuICAvLyBpZiBhbiBvcHRpb24gaXMgYW4gYXJyYXksIGVhdCBhbGwgbm9uLWh5cGhlbmF0ZWQgYXJndW1lbnRzXG4gIC8vIGZvbGxvd2luZyBpdC4uLiBZVU0hXG4gIC8vIGUuZy4sIC0tZm9vIGFwcGxlIGJhbmFuYSBjYXQgYmVjb21lcyBbXCJhcHBsZVwiLCBcImJhbmFuYVwiLCBcImNhdFwiXVxuICBmdW5jdGlvbiBlYXRBcnJheSAoaSwga2V5LCBhcmdzLCBhcmdBZnRlckVxdWFsU2lnbikge1xuICAgIGxldCBhcmdzVG9TZXQgPSBbXVxuICAgIGxldCBuZXh0ID0gYXJnQWZ0ZXJFcXVhbFNpZ24gfHwgYXJnc1tpICsgMV1cbiAgICAvLyBJZiBib3RoIGFycmF5IGFuZCBuYXJncyBhcmUgY29uZmlndXJlZCwgZW5mb3JjZSB0aGUgbmFyZ3MgY291bnQ6XG4gICAgY29uc3QgbmFyZ3NDb3VudCA9IGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLm5hcmdzKVxuXG4gICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmJvb2xzKSAmJiAhKC9eKHRydWV8ZmFsc2UpJC8udGVzdChuZXh0KSkpIHtcbiAgICAgIGFyZ3NUb1NldC5wdXNoKHRydWUpXG4gICAgfSBlbHNlIGlmIChpc1VuZGVmaW5lZChuZXh0KSB8fFxuICAgICAgICAoaXNVbmRlZmluZWQoYXJnQWZ0ZXJFcXVhbFNpZ24pICYmIC9eLS8udGVzdChuZXh0KSAmJiAhbmVnYXRpdmUudGVzdChuZXh0KSAmJiAhaXNVbmtub3duT3B0aW9uQXNBcmcobmV4dCkpKSB7XG4gICAgICAvLyBmb3Iga2V5cyB3aXRob3V0IHZhbHVlID09PiBhcmdzVG9TZXQgcmVtYWlucyBhbiBlbXB0eSBbXVxuICAgICAgLy8gc2V0IHVzZXIgZGVmYXVsdCB2YWx1ZSwgaWYgYXZhaWxhYmxlXG4gICAgICBpZiAoZGVmYXVsdHNba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGRlZlZhbCA9IGRlZmF1bHRzW2tleV1cbiAgICAgICAgYXJnc1RvU2V0ID0gQXJyYXkuaXNBcnJheShkZWZWYWwpID8gZGVmVmFsIDogW2RlZlZhbF1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gdmFsdWUgaW4gLS1vcHRpb249dmFsdWUgaXMgZWF0ZW4gYXMgaXNcbiAgICAgIGlmICghaXNVbmRlZmluZWQoYXJnQWZ0ZXJFcXVhbFNpZ24pKSB7XG4gICAgICAgIGFyZ3NUb1NldC5wdXNoKHByb2Nlc3NWYWx1ZShrZXksIGFyZ0FmdGVyRXF1YWxTaWduKSlcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGlpID0gaSArIDE7IGlpIDwgYXJncy5sZW5ndGg7IGlpKyspIHtcbiAgICAgICAgaWYgKCghY29uZmlndXJhdGlvblsnZ3JlZWR5LWFycmF5cyddICYmIGFyZ3NUb1NldC5sZW5ndGggPiAwKSB8fFxuICAgICAgICAgIChuYXJnc0NvdW50ICYmIGFyZ3NUb1NldC5sZW5ndGggPj0gbmFyZ3NDb3VudCkpIGJyZWFrXG4gICAgICAgIG5leHQgPSBhcmdzW2lpXVxuICAgICAgICBpZiAoL14tLy50ZXN0KG5leHQpICYmICFuZWdhdGl2ZS50ZXN0KG5leHQpICYmICFpc1Vua25vd25PcHRpb25Bc0FyZyhuZXh0KSkgYnJlYWtcbiAgICAgICAgaSA9IGlpXG4gICAgICAgIGFyZ3NUb1NldC5wdXNoKHByb2Nlc3NWYWx1ZShrZXksIG5leHQpKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIGJvdGggYXJyYXkgYW5kIG5hcmdzIGFyZSBjb25maWd1cmVkLCBjcmVhdGUgYW4gZXJyb3IgaWYgbGVzcyB0aGFuXG4gICAgLy8gbmFyZ3MgcG9zaXRpb25hbHMgd2VyZSBmb3VuZC4gTmFOIGhhcyBzcGVjaWFsIG1lYW5pbmcsIGluZGljYXRpbmdcbiAgICAvLyB0aGF0IGF0IGxlYXN0IG9uZSB2YWx1ZSBpcyByZXF1aXJlZCAobW9yZSBhcmUgb2theSkuXG4gICAgaWYgKChuYXJnc0NvdW50ICYmIGFyZ3NUb1NldC5sZW5ndGggPCBuYXJnc0NvdW50KSB8fFxuICAgICAgICAoaXNOYU4obmFyZ3NDb3VudCkgJiYgYXJnc1RvU2V0Lmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgIGVycm9yID0gRXJyb3IoX18oJ05vdCBlbm91Z2ggYXJndW1lbnRzIGZvbGxvd2luZzogJXMnLCBrZXkpKVxuICAgIH1cblxuICAgIHNldEFyZyhrZXksIGFyZ3NUb1NldClcbiAgICByZXR1cm4gaVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0QXJnIChrZXksIHZhbCkge1xuICAgIGlmICgvLS8udGVzdChrZXkpICYmIGNvbmZpZ3VyYXRpb25bJ2NhbWVsLWNhc2UtZXhwYW5zaW9uJ10pIHtcbiAgICAgIGNvbnN0IGFsaWFzID0ga2V5LnNwbGl0KCcuJykubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgIHJldHVybiBjYW1lbENhc2UocHJvcClcbiAgICAgIH0pLmpvaW4oJy4nKVxuICAgICAgYWRkTmV3QWxpYXMoa2V5LCBhbGlhcylcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IHByb2Nlc3NWYWx1ZShrZXksIHZhbClcbiAgICBjb25zdCBzcGxpdEtleSA9IGtleS5zcGxpdCgnLicpXG4gICAgc2V0S2V5KGFyZ3YsIHNwbGl0S2V5LCB2YWx1ZSlcblxuICAgIC8vIGhhbmRsZSBwb3B1bGF0aW5nIGFsaWFzZXMgb2YgdGhlIGZ1bGwga2V5XG4gICAgaWYgKGZsYWdzLmFsaWFzZXNba2V5XSkge1xuICAgICAgZmxhZ3MuYWxpYXNlc1trZXldLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgeCA9IHguc3BsaXQoJy4nKVxuICAgICAgICBzZXRLZXkoYXJndiwgeCwgdmFsdWUpXG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIGhhbmRsZSBwb3B1bGF0aW5nIGFsaWFzZXMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGRvdC1ub3RhdGlvbiBrZXlcbiAgICBpZiAoc3BsaXRLZXkubGVuZ3RoID4gMSAmJiBjb25maWd1cmF0aW9uWydkb3Qtbm90YXRpb24nXSkge1xuICAgICAgOyhmbGFncy5hbGlhc2VzW3NwbGl0S2V5WzBdXSB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICB4ID0geC5zcGxpdCgnLicpXG5cbiAgICAgICAgLy8gZXhwYW5kIGFsaWFzIHdpdGggbmVzdGVkIG9iamVjdHMgaW4ga2V5XG4gICAgICAgIGNvbnN0IGEgPSBbXS5jb25jYXQoc3BsaXRLZXkpXG4gICAgICAgIGEuc2hpZnQoKSAvLyBudWtlIHRoZSBvbGQga2V5LlxuICAgICAgICB4ID0geC5jb25jYXQoYSlcblxuICAgICAgICAvLyBwb3B1bGF0ZSBhbGlhcyBvbmx5IGlmIGlzIG5vdCBhbHJlYWR5IGFuIGFsaWFzIG9mIHRoZSBmdWxsIGtleVxuICAgICAgICAvLyAoYWxyZWFkeSBwb3B1bGF0ZWQgYWJvdmUpXG4gICAgICAgIGlmICghKGZsYWdzLmFsaWFzZXNba2V5XSB8fCBbXSkuaW5jbHVkZXMoeC5qb2luKCcuJykpKSB7XG4gICAgICAgICAgc2V0S2V5KGFyZ3YsIHgsIHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIFNldCBub3JtYWxpemUgZ2V0dGVyIGFuZCBzZXR0ZXIgd2hlbiBrZXkgaXMgaW4gJ25vcm1hbGl6ZScgYnV0IGlzbid0IGFuIGFycmF5XG4gICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLm5vcm1hbGl6ZSkgJiYgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmFycmF5cykpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBba2V5XS5jb25jYXQoZmxhZ3MuYWxpYXNlc1trZXldIHx8IFtdKVxuICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGFyZ3ZSZXR1cm4sIGtleSwge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0ICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNldCAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBwYXRoLm5vcm1hbGl6ZSh2YWx1ZSkgOiB2YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkTmV3QWxpYXMgKGtleSwgYWxpYXMpIHtcbiAgICBpZiAoIShmbGFncy5hbGlhc2VzW2tleV0gJiYgZmxhZ3MuYWxpYXNlc1trZXldLmxlbmd0aCkpIHtcbiAgICAgIGZsYWdzLmFsaWFzZXNba2V5XSA9IFthbGlhc11cbiAgICAgIG5ld0FsaWFzZXNbYWxpYXNdID0gdHJ1ZVxuICAgIH1cbiAgICBpZiAoIShmbGFncy5hbGlhc2VzW2FsaWFzXSAmJiBmbGFncy5hbGlhc2VzW2FsaWFzXS5sZW5ndGgpKSB7XG4gICAgICBhZGROZXdBbGlhcyhhbGlhcywga2V5KVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NWYWx1ZSAoa2V5LCB2YWwpIHtcbiAgICAvLyBzdHJpbmdzIG1heSBiZSBxdW90ZWQsIGNsZWFuIHRoaXMgdXAgYXMgd2UgYXNzaWduIHZhbHVlcy5cbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICh2YWxbMF0gPT09IFwiJ1wiIHx8IHZhbFswXSA9PT0gJ1wiJykgJiZcbiAgICAgIHZhbFt2YWwubGVuZ3RoIC0gMV0gPT09IHZhbFswXVxuICAgICkge1xuICAgICAgdmFsID0gdmFsLnN1YnN0cmluZygxLCB2YWwubGVuZ3RoIC0gMSlcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgcGFyc2luZyBib29sZWFuIGFyZ3VtZW50cyAtLWZvbz10cnVlIC0tYmFyIGZhbHNlLlxuICAgIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5ib29scykgfHwgY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuY291bnRzKSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB2YWwgPSB2YWwgPT09ICd0cnVlJ1xuICAgIH1cblxuICAgIGxldCB2YWx1ZSA9IEFycmF5LmlzQXJyYXkodmFsKVxuICAgICAgPyB2YWwubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBtYXliZUNvZXJjZU51bWJlcihrZXksIHYpIH0pXG4gICAgICA6IG1heWJlQ29lcmNlTnVtYmVyKGtleSwgdmFsKVxuXG4gICAgLy8gaW5jcmVtZW50IGEgY291bnQgZ2l2ZW4gYXMgYXJnIChlaXRoZXIgbm8gdmFsdWUgb3IgdmFsdWUgcGFyc2VkIGFzIGJvb2xlYW4pXG4gICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmNvdW50cykgJiYgKGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykpIHtcbiAgICAgIHZhbHVlID0gaW5jcmVtZW50XG4gICAgfVxuXG4gICAgLy8gU2V0IG5vcm1hbGl6ZWQgdmFsdWUgd2hlbiBrZXkgaXMgaW4gJ25vcm1hbGl6ZScgYW5kIGluICdhcnJheXMnXG4gICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLm5vcm1hbGl6ZSkgJiYgY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYXJyYXlzKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkgdmFsdWUgPSB2YWwubWFwKHBhdGgubm9ybWFsaXplKVxuICAgICAgZWxzZSB2YWx1ZSA9IHBhdGgubm9ybWFsaXplKHZhbClcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBmdW5jdGlvbiBtYXliZUNvZXJjZU51bWJlciAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICghY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3Muc3RyaW5ncykgJiYgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmJvb2xzKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IHNob3VsZENvZXJjZU51bWJlciA9IGlzTnVtYmVyKHZhbHVlKSAmJiBjb25maWd1cmF0aW9uWydwYXJzZS1udW1iZXJzJ10gJiYgKFxuICAgICAgICBOdW1iZXIuaXNTYWZlSW50ZWdlcihNYXRoLmZsb29yKHZhbHVlKSlcbiAgICAgIClcbiAgICAgIGlmIChzaG91bGRDb2VyY2VOdW1iZXIgfHwgKCFpc1VuZGVmaW5lZCh2YWx1ZSkgJiYgY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MubnVtYmVycykpKSB2YWx1ZSA9IE51bWJlcih2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvLyBzZXQgYXJncyBmcm9tIGNvbmZpZy5qc29uIGZpbGUsIHRoaXMgc2hvdWxkIGJlXG4gIC8vIGFwcGxpZWQgbGFzdCBzbyB0aGF0IGRlZmF1bHRzIGNhbiBiZSBhcHBsaWVkLlxuICBmdW5jdGlvbiBzZXRDb25maWcgKGFyZ3YpIHtcbiAgICBjb25zdCBjb25maWdMb29rdXAgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbiAgICAvLyBleHBhbmQgZGVmYXVsdHMvYWxpYXNlcywgaW4tY2FzZSBhbnkgaGFwcGVuIHRvIHJlZmVyZW5jZVxuICAgIC8vIHRoZSBjb25maWcuanNvbiBmaWxlLlxuICAgIGFwcGx5RGVmYXVsdHNBbmRBbGlhc2VzKGNvbmZpZ0xvb2t1cCwgZmxhZ3MuYWxpYXNlcywgZGVmYXVsdHMpXG5cbiAgICBPYmplY3Qua2V5cyhmbGFncy5jb25maWdzKS5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWdLZXkpIHtcbiAgICAgIGNvbnN0IGNvbmZpZ1BhdGggPSBhcmd2W2NvbmZpZ0tleV0gfHwgY29uZmlnTG9va3VwW2NvbmZpZ0tleV1cbiAgICAgIGlmIChjb25maWdQYXRoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbGV0IGNvbmZpZyA9IG51bGxcbiAgICAgICAgICBjb25zdCByZXNvbHZlZENvbmZpZ1BhdGggPSBwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgY29uZmlnUGF0aClcblxuICAgICAgICAgIGlmICh0eXBlb2YgZmxhZ3MuY29uZmlnc1tjb25maWdLZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25maWcgPSBmbGFncy5jb25maWdzW2NvbmZpZ0tleV0ocmVzb2x2ZWRDb25maWdQYXRoKVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25maWcgPSBlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgZXJyb3IgPSBjb25maWdcbiAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZyA9IHJlcXVpcmUocmVzb2x2ZWRDb25maWdQYXRoKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldENvbmZpZ09iamVjdChjb25maWcpXG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgaWYgKGFyZ3ZbY29uZmlnS2V5XSkgZXJyb3IgPSBFcnJvcihfXygnSW52YWxpZCBKU09OIGNvbmZpZyBmaWxlOiAlcycsIGNvbmZpZ1BhdGgpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIHNldCBhcmdzIGZyb20gY29uZmlnIG9iamVjdC5cbiAgLy8gaXQgcmVjdXJzaXZlbHkgY2hlY2tzIG5lc3RlZCBvYmplY3RzLlxuICBmdW5jdGlvbiBzZXRDb25maWdPYmplY3QgKGNvbmZpZywgcHJldikge1xuICAgIE9iamVjdC5rZXlzKGNvbmZpZykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNvbmZpZ1trZXldXG4gICAgICBjb25zdCBmdWxsS2V5ID0gcHJldiA/IHByZXYgKyAnLicgKyBrZXkgOiBrZXlcblxuICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIGFuIGlubmVyIG9iamVjdCBhbmQgd2UgaGF2ZSBkb3Qtbm90YXRpb25cbiAgICAgIC8vIGVuYWJsZWQsIHRyZWF0IGlubmVyIG9iamVjdHMgaW4gY29uZmlnIHRoZSBzYW1lIGFzXG4gICAgICAvLyBoZWF2aWx5IG5lc3RlZCBkb3Qgbm90YXRpb25zIChmb28uYmFyLmFwcGxlKS5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJiBjb25maWd1cmF0aW9uWydkb3Qtbm90YXRpb24nXSkge1xuICAgICAgICAvLyBpZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IGJ1dCBub3QgYW4gYXJyYXksIGNoZWNrIG5lc3RlZCBvYmplY3RcbiAgICAgICAgc2V0Q29uZmlnT2JqZWN0KHZhbHVlLCBmdWxsS2V5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2V0dGluZyBhcmd1bWVudHMgdmlhIENMSSB0YWtlcyBwcmVjZWRlbmNlIG92ZXJcbiAgICAgICAgLy8gdmFsdWVzIHdpdGhpbiB0aGUgY29uZmlnIGZpbGUuXG4gICAgICAgIGlmICghaGFzS2V5KGFyZ3YsIGZ1bGxLZXkuc3BsaXQoJy4nKSkgfHwgKGNoZWNrQWxsQWxpYXNlcyhmdWxsS2V5LCBmbGFncy5hcnJheXMpICYmIGNvbmZpZ3VyYXRpb25bJ2NvbWJpbmUtYXJyYXlzJ10pKSB7XG4gICAgICAgICAgc2V0QXJnKGZ1bGxLZXksIHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIHNldCBhbGwgY29uZmlnIG9iamVjdHMgcGFzc2VkIGluIG9wdHNcbiAgZnVuY3Rpb24gc2V0Q29uZmlnT2JqZWN0cyAoKSB7XG4gICAgaWYgKHR5cGVvZiBjb25maWdPYmplY3RzID09PSAndW5kZWZpbmVkJykgcmV0dXJuXG4gICAgY29uZmlnT2JqZWN0cy5mb3JFYWNoKGZ1bmN0aW9uIChjb25maWdPYmplY3QpIHtcbiAgICAgIHNldENvbmZpZ09iamVjdChjb25maWdPYmplY3QpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5RW52VmFycyAoYXJndiwgY29uZmlnT25seSkge1xuICAgIGlmICh0eXBlb2YgZW52UHJlZml4ID09PSAndW5kZWZpbmVkJykgcmV0dXJuXG5cbiAgICBjb25zdCBwcmVmaXggPSB0eXBlb2YgZW52UHJlZml4ID09PSAnc3RyaW5nJyA/IGVudlByZWZpeCA6ICcnXG4gICAgT2JqZWN0LmtleXMocHJvY2Vzcy5lbnYpLmZvckVhY2goZnVuY3Rpb24gKGVudlZhcikge1xuICAgICAgaWYgKHByZWZpeCA9PT0gJycgfHwgZW52VmFyLmxhc3RJbmRleE9mKHByZWZpeCwgMCkgPT09IDApIHtcbiAgICAgICAgLy8gZ2V0IGFycmF5IG9mIG5lc3RlZCBrZXlzIGFuZCBjb252ZXJ0IHRoZW0gdG8gY2FtZWwgY2FzZVxuICAgICAgICBjb25zdCBrZXlzID0gZW52VmFyLnNwbGl0KCdfXycpLm1hcChmdW5jdGlvbiAoa2V5LCBpKSB7XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIGtleSA9IGtleS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbWVsQ2FzZShrZXkpXG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKCgoY29uZmlnT25seSAmJiBmbGFncy5jb25maWdzW2tleXMuam9pbignLicpXSkgfHwgIWNvbmZpZ09ubHkpICYmICFoYXNLZXkoYXJndiwga2V5cykpIHtcbiAgICAgICAgICBzZXRBcmcoa2V5cy5qb2luKCcuJyksIHByb2Nlc3MuZW52W2VudlZhcl0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlDb2VyY2lvbnMgKGFyZ3YpIHtcbiAgICBsZXQgY29lcmNlXG4gICAgY29uc3QgYXBwbGllZCA9IG5ldyBTZXQoKVxuICAgIE9iamVjdC5rZXlzKGFyZ3YpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCFhcHBsaWVkLmhhcyhrZXkpKSB7IC8vIElmIHdlIGhhdmVuJ3QgYWxyZWFkeSBjb2VyY2VkIHRoaXMgb3B0aW9uIHZpYSBvbmUgb2YgaXRzIGFsaWFzZXNcbiAgICAgICAgY29lcmNlID0gY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuY29lcmNpb25zKVxuICAgICAgICBpZiAodHlwZW9mIGNvZXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1heWJlQ29lcmNlTnVtYmVyKGtleSwgY29lcmNlKGFyZ3Zba2V5XSkpXG4gICAgICAgICAgICA7KFtdLmNvbmNhdChmbGFncy5hbGlhc2VzW2tleV0gfHwgW10sIGtleSkpLmZvckVhY2goYWxpID0+IHtcbiAgICAgICAgICAgICAgYXBwbGllZC5hZGQoYWxpKVxuICAgICAgICAgICAgICBhcmd2W2FsaV0gPSB2YWx1ZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGVycm9yID0gZXJyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFBsYWNlaG9sZGVyS2V5cyAoYXJndikge1xuICAgIGZsYWdzLmtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAvLyBkb24ndCBzZXQgcGxhY2Vob2xkZXIga2V5cyBmb3IgZG90IG5vdGF0aW9uIG9wdGlvbnMgJ2Zvby5iYXInLlxuICAgICAgaWYgKH5rZXkuaW5kZXhPZignLicpKSByZXR1cm5cbiAgICAgIGlmICh0eXBlb2YgYXJndltrZXldID09PSAndW5kZWZpbmVkJykgYXJndltrZXldID0gdW5kZWZpbmVkXG4gICAgfSlcbiAgICByZXR1cm4gYXJndlxuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlEZWZhdWx0c0FuZEFsaWFzZXMgKG9iaiwgYWxpYXNlcywgZGVmYXVsdHMsIGNhbkxvZyA9IGZhbHNlKSB7XG4gICAgT2JqZWN0LmtleXMoZGVmYXVsdHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgaWYgKCFoYXNLZXkob2JqLCBrZXkuc3BsaXQoJy4nKSkpIHtcbiAgICAgICAgc2V0S2V5KG9iaiwga2V5LnNwbGl0KCcuJyksIGRlZmF1bHRzW2tleV0pXG4gICAgICAgIGlmIChjYW5Mb2cpIGRlZmF1bHRlZFtrZXldID0gdHJ1ZVxuXG4gICAgICAgIDsoYWxpYXNlc1trZXldIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgaWYgKGhhc0tleShvYmosIHguc3BsaXQoJy4nKSkpIHJldHVyblxuICAgICAgICAgIHNldEtleShvYmosIHguc3BsaXQoJy4nKSwgZGVmYXVsdHNba2V5XSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gaGFzS2V5IChvYmosIGtleXMpIHtcbiAgICBsZXQgbyA9IG9ialxuXG4gICAgaWYgKCFjb25maWd1cmF0aW9uWydkb3Qtbm90YXRpb24nXSkga2V5cyA9IFtrZXlzLmpvaW4oJy4nKV1cblxuICAgIGtleXMuc2xpY2UoMCwgLTEpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgbyA9IChvW2tleV0gfHwge30pXG4gICAgfSlcblxuICAgIGNvbnN0IGtleSA9IGtleXNba2V5cy5sZW5ndGggLSAxXVxuXG4gICAgaWYgKHR5cGVvZiBvICE9PSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlXG4gICAgZWxzZSByZXR1cm4ga2V5IGluIG9cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEtleSAob2JqLCBrZXlzLCB2YWx1ZSkge1xuICAgIGxldCBvID0gb2JqXG5cbiAgICBpZiAoIWNvbmZpZ3VyYXRpb25bJ2RvdC1ub3RhdGlvbiddKSBrZXlzID0gW2tleXMuam9pbignLicpXVxuXG4gICAga2V5cy5zbGljZSgwLCAtMSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpbmRleCkge1xuICAgICAgLy8gVE9ETyhiY29lKTogaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiB5YXJncywgc3dpdGNoIHRvXG4gICAgICAvLyBPYmplY3QuY3JlYXRlKG51bGwpIGZvciBkb3Qgbm90YXRpb246XG4gICAgICBrZXkgPSBzYW5pdGl6ZUtleShrZXkpXG5cbiAgICAgIGlmICh0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgb1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb1trZXldID0ge31cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBvW2tleV0gIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkob1trZXldKSkge1xuICAgICAgICAvLyBlbnN1cmUgdGhhdCBvW2tleV0gaXMgYW4gYXJyYXksIGFuZCB0aGF0IHRoZSBsYXN0IGl0ZW0gaXMgYW4gZW1wdHkgb2JqZWN0LlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvW2tleV0pKSB7XG4gICAgICAgICAgb1trZXldLnB1c2goe30pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb1trZXldID0gW29ba2V5XSwge31dXG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSB3YW50IHRvIHVwZGF0ZSB0aGUgZW1wdHkgb2JqZWN0IGF0IHRoZSBlbmQgb2YgdGhlIG9ba2V5XSBhcnJheSwgc28gc2V0IG8gdG8gdGhhdCBvYmplY3RcbiAgICAgICAgbyA9IG9ba2V5XVtvW2tleV0ubGVuZ3RoIC0gMV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG8gPSBvW2tleV1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gVE9ETyhiY29lKTogaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiB5YXJncywgc3dpdGNoIHRvXG4gICAgLy8gT2JqZWN0LmNyZWF0ZShudWxsKSBmb3IgZG90IG5vdGF0aW9uOlxuICAgIGNvbnN0IGtleSA9IHNhbml0aXplS2V5KGtleXNba2V5cy5sZW5ndGggLSAxXSlcblxuICAgIGNvbnN0IGlzVHlwZUFycmF5ID0gY2hlY2tBbGxBbGlhc2VzKGtleXMuam9pbignLicpLCBmbGFncy5hcnJheXMpXG4gICAgY29uc3QgaXNWYWx1ZUFycmF5ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSlcbiAgICBsZXQgZHVwbGljYXRlID0gY29uZmlndXJhdGlvblsnZHVwbGljYXRlLWFyZ3VtZW50cy1hcnJheSddXG5cbiAgICAvLyBuYXJncyBoYXMgaGlnaGVyIHByaW9yaXR5IHRoYW4gZHVwbGljYXRlXG4gICAgaWYgKCFkdXBsaWNhdGUgJiYgY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MubmFyZ3MpKSB7XG4gICAgICBkdXBsaWNhdGUgPSB0cnVlXG4gICAgICBpZiAoKCFpc1VuZGVmaW5lZChvW2tleV0pICYmIGZsYWdzLm5hcmdzW2tleV0gPT09IDEpIHx8IChBcnJheS5pc0FycmF5KG9ba2V5XSkgJiYgb1trZXldLmxlbmd0aCA9PT0gZmxhZ3MubmFyZ3Nba2V5XSkpIHtcbiAgICAgICAgb1trZXldID0gdW5kZWZpbmVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHZhbHVlID09PSBpbmNyZW1lbnQpIHtcbiAgICAgIG9ba2V5XSA9IGluY3JlbWVudChvW2tleV0pXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ba2V5XSkpIHtcbiAgICAgIGlmIChkdXBsaWNhdGUgJiYgaXNUeXBlQXJyYXkgJiYgaXNWYWx1ZUFycmF5KSB7XG4gICAgICAgIG9ba2V5XSA9IGNvbmZpZ3VyYXRpb25bJ2ZsYXR0ZW4tZHVwbGljYXRlLWFycmF5cyddID8gb1trZXldLmNvbmNhdCh2YWx1ZSkgOiAoQXJyYXkuaXNBcnJheShvW2tleV1bMF0pID8gb1trZXldIDogW29ba2V5XV0pLmNvbmNhdChbdmFsdWVdKVxuICAgICAgfSBlbHNlIGlmICghZHVwbGljYXRlICYmIEJvb2xlYW4oaXNUeXBlQXJyYXkpID09PSBCb29sZWFuKGlzVmFsdWVBcnJheSkpIHtcbiAgICAgICAgb1trZXldID0gdmFsdWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9ba2V5XSA9IG9ba2V5XS5jb25jYXQoW3ZhbHVlXSlcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9ba2V5XSA9PT0gdW5kZWZpbmVkICYmIGlzVHlwZUFycmF5KSB7XG4gICAgICBvW2tleV0gPSBpc1ZhbHVlQXJyYXkgPyB2YWx1ZSA6IFt2YWx1ZV1cbiAgICB9IGVsc2UgaWYgKGR1cGxpY2F0ZSAmJiAhKFxuICAgICAgb1trZXldID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuY291bnRzKSB8fFxuICAgICAgICBjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5ib29scylcbiAgICApKSB7XG4gICAgICBvW2tleV0gPSBbb1trZXldLCB2YWx1ZV1cbiAgICB9IGVsc2Uge1xuICAgICAgb1trZXldID0gdmFsdWVcbiAgICB9XG4gIH1cblxuICAvLyBleHRlbmQgdGhlIGFsaWFzZXMgbGlzdCB3aXRoIGluZmVycmVkIGFsaWFzZXMuXG4gIGZ1bmN0aW9uIGV4dGVuZEFsaWFzZXMgKC4uLmFyZ3MpIHtcbiAgICBhcmdzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgT2JqZWN0LmtleXMob2JqIHx8IHt9KS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLy8gc2hvcnQtY2lyY3VpdCBpZiB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGEga2V5XG4gICAgICAgIC8vIHRvIHRoZSBhbGlhc2VzIGFycmF5LCBmb3IgZXhhbXBsZSBpdCBtaWdodFxuICAgICAgICAvLyBleGlzdCBpbiBib3RoICdvcHRzLmRlZmF1bHQnIGFuZCAnb3B0cy5rZXknLlxuICAgICAgICBpZiAoZmxhZ3MuYWxpYXNlc1trZXldKSByZXR1cm5cblxuICAgICAgICBmbGFncy5hbGlhc2VzW2tleV0gPSBbXS5jb25jYXQoYWxpYXNlc1trZXldIHx8IFtdKVxuICAgICAgICAvLyBGb3IgXCItLW9wdGlvbi1uYW1lXCIsIGFsc28gc2V0IGFyZ3Yub3B0aW9uTmFtZVxuICAgICAgICBmbGFncy5hbGlhc2VzW2tleV0uY29uY2F0KGtleSkuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgIGlmICgvLS8udGVzdCh4KSAmJiBjb25maWd1cmF0aW9uWydjYW1lbC1jYXNlLWV4cGFuc2lvbiddKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gY2FtZWxDYXNlKHgpXG4gICAgICAgICAgICBpZiAoYyAhPT0ga2V5ICYmIGZsYWdzLmFsaWFzZXNba2V5XS5pbmRleE9mKGMpID09PSAtMSkge1xuICAgICAgICAgICAgICBmbGFncy5hbGlhc2VzW2tleV0ucHVzaChjKVxuICAgICAgICAgICAgICBuZXdBbGlhc2VzW2NdID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLy8gRm9yIFwiLS1vcHRpb25OYW1lXCIsIGFsc28gc2V0IGFyZ3ZbJ29wdGlvbi1uYW1lJ11cbiAgICAgICAgZmxhZ3MuYWxpYXNlc1trZXldLmNvbmNhdChrZXkpLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICBpZiAoeC5sZW5ndGggPiAxICYmIC9bQS1aXS8udGVzdCh4KSAmJiBjb25maWd1cmF0aW9uWydjYW1lbC1jYXNlLWV4cGFuc2lvbiddKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gZGVjYW1lbGl6ZSh4LCAnLScpXG4gICAgICAgICAgICBpZiAoYyAhPT0ga2V5ICYmIGZsYWdzLmFsaWFzZXNba2V5XS5pbmRleE9mKGMpID09PSAtMSkge1xuICAgICAgICAgICAgICBmbGFncy5hbGlhc2VzW2tleV0ucHVzaChjKVxuICAgICAgICAgICAgICBuZXdBbGlhc2VzW2NdID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgZmxhZ3MuYWxpYXNlc1trZXldLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICBmbGFncy5hbGlhc2VzW3hdID0gW2tleV0uY29uY2F0KGZsYWdzLmFsaWFzZXNba2V5XS5maWx0ZXIoZnVuY3Rpb24gKHkpIHtcbiAgICAgICAgICAgIHJldHVybiB4ICE9PSB5XG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvLyByZXR1cm4gdGhlIDFzdCBzZXQgZmxhZyBmb3IgYW55IG9mIGEga2V5J3MgYWxpYXNlcyAob3IgZmFsc2UgaWYgbm8gZmxhZyBzZXQpXG4gIGZ1bmN0aW9uIGNoZWNrQWxsQWxpYXNlcyAoa2V5LCBmbGFnKSB7XG4gICAgY29uc3QgdG9DaGVjayA9IFtdLmNvbmNhdChmbGFncy5hbGlhc2VzW2tleV0gfHwgW10sIGtleSlcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZmxhZylcbiAgICBjb25zdCBzZXRBbGlhcyA9IHRvQ2hlY2suZmluZChrZXkgPT4ga2V5cy5pbmNsdWRlcyhrZXkpKVxuICAgIHJldHVybiBzZXRBbGlhcyA/IGZsYWdbc2V0QWxpYXNdIDogZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0FueUZsYWcgKGtleSkge1xuICAgIGNvbnN0IHRvQ2hlY2sgPSBbXS5jb25jYXQoT2JqZWN0LmtleXMoZmxhZ3MpLm1hcChrID0+IGZsYWdzW2tdKSlcbiAgICByZXR1cm4gdG9DaGVjay5zb21lKGZ1bmN0aW9uIChmbGFnKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShmbGFnKSA/IGZsYWcuaW5jbHVkZXMoa2V5KSA6IGZsYWdba2V5XVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBoYXNGbGFnc01hdGNoaW5nIChhcmcsIC4uLnBhdHRlcm5zKSB7XG4gICAgY29uc3QgdG9DaGVjayA9IFtdLmNvbmNhdCguLi5wYXR0ZXJucylcbiAgICByZXR1cm4gdG9DaGVjay5zb21lKGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGFyZy5tYXRjaChwYXR0ZXJuKVxuICAgICAgcmV0dXJuIG1hdGNoICYmIGhhc0FueUZsYWcobWF0Y2hbMV0pXG4gICAgfSlcbiAgfVxuXG4gIC8vIGJhc2VkIG9uIGEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHRoZSBzaG9ydCBmbGFnIGdyb3VwIHBhcnNpbmcgbG9naWNcbiAgZnVuY3Rpb24gaGFzQWxsU2hvcnRGbGFncyAoYXJnKSB7XG4gICAgLy8gaWYgdGhpcyBpcyBhIG5lZ2F0aXZlIG51bWJlciwgb3IgZG9lc24ndCBzdGFydCB3aXRoIGEgc2luZ2xlIGh5cGhlbiwgaXQncyBub3QgYSBzaG9ydCBmbGFnIGdyb3VwXG4gICAgaWYgKGFyZy5tYXRjaChuZWdhdGl2ZSkgfHwgIWFyZy5tYXRjaCgvXi1bXi1dKy8pKSB7IHJldHVybiBmYWxzZSB9XG4gICAgbGV0IGhhc0FsbEZsYWdzID0gdHJ1ZVxuICAgIGxldCBuZXh0XG4gICAgY29uc3QgbGV0dGVycyA9IGFyZy5zbGljZSgxKS5zcGxpdCgnJylcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxldHRlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgIG5leHQgPSBhcmcuc2xpY2UoaiArIDIpXG5cbiAgICAgIGlmICghaGFzQW55RmxhZyhsZXR0ZXJzW2pdKSkge1xuICAgICAgICBoYXNBbGxGbGFncyA9IGZhbHNlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGlmICgobGV0dGVyc1tqICsgMV0gJiYgbGV0dGVyc1tqICsgMV0gPT09ICc9JykgfHxcbiAgICAgICAgbmV4dCA9PT0gJy0nIHx8XG4gICAgICAgICgvW0EtWmEtel0vLnRlc3QobGV0dGVyc1tqXSkgJiYgL14tP1xcZCsoXFwuXFxkKik/KGUtP1xcZCspPyQvLnRlc3QobmV4dCkpIHx8XG4gICAgICAgIChsZXR0ZXJzW2ogKyAxXSAmJiBsZXR0ZXJzW2ogKyAxXS5tYXRjaCgvXFxXLykpKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNBbGxGbGFnc1xuICB9XG5cbiAgZnVuY3Rpb24gaXNVbmtub3duT3B0aW9uQXNBcmcgKGFyZykge1xuICAgIHJldHVybiBjb25maWd1cmF0aW9uWyd1bmtub3duLW9wdGlvbnMtYXMtYXJncyddICYmIGlzVW5rbm93bk9wdGlvbihhcmcpXG4gIH1cblxuICBmdW5jdGlvbiBpc1Vua25vd25PcHRpb24gKGFyZykge1xuICAgIC8vIGlnbm9yZSBuZWdhdGl2ZSBudW1iZXJzXG4gICAgaWYgKGFyZy5tYXRjaChuZWdhdGl2ZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAvLyBpZiB0aGlzIGlzIGEgc2hvcnQgb3B0aW9uIGdyb3VwIGFuZCBhbGwgb2YgdGhlbSBhcmUgY29uZmlndXJlZCwgaXQgaXNuJ3QgdW5rbm93blxuICAgIGlmIChoYXNBbGxTaG9ydEZsYWdzKGFyZykpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAvLyBlLmcuICctLWNvdW50PTInXG4gICAgY29uc3QgZmxhZ1dpdGhFcXVhbHMgPSAvXi0rKFtePV0rPyk9W1xcc1xcU10qJC9cbiAgICAvLyBlLmcuICctYScgb3IgJy0tYXJnJ1xuICAgIGNvbnN0IG5vcm1hbEZsYWcgPSAvXi0rKFtePV0rPykkL1xuICAgIC8vIGUuZy4gJy1hLSdcbiAgICBjb25zdCBmbGFnRW5kaW5nSW5IeXBoZW4gPSAvXi0rKFtePV0rPyktJC9cbiAgICAvLyBlLmcuICctYWJjMTIzJ1xuICAgIGNvbnN0IGZsYWdFbmRpbmdJbkRpZ2l0cyA9IC9eLSsoW149XSs/XFxkKykkL1xuICAgIC8vIGUuZy4gJy1hL3Vzci9sb2NhbCdcbiAgICBjb25zdCBmbGFnRW5kaW5nSW5Ob25Xb3JkQ2hhcmFjdGVycyA9IC9eLSsoW149XSs/KVxcVysuKiQvXG4gICAgLy8gY2hlY2sgdGhlIGRpZmZlcmVudCB0eXBlcyBvZiBmbGFnIHN0eWxlcywgaW5jbHVkaW5nIG5lZ2F0ZWRCb29sZWFuLCBhIHBhdHRlcm4gZGVmaW5lZCBuZWFyIHRoZSBzdGFydCBvZiB0aGUgcGFyc2UgbWV0aG9kXG4gICAgcmV0dXJuICFoYXNGbGFnc01hdGNoaW5nKGFyZywgZmxhZ1dpdGhFcXVhbHMsIG5lZ2F0ZWRCb29sZWFuLCBub3JtYWxGbGFnLCBmbGFnRW5kaW5nSW5IeXBoZW4sIGZsYWdFbmRpbmdJbkRpZ2l0cywgZmxhZ0VuZGluZ0luTm9uV29yZENoYXJhY3RlcnMpXG4gIH1cblxuICAvLyBtYWtlIGEgYmVzdCBlZmZvciB0byBwaWNrIGEgZGVmYXVsdCB2YWx1ZVxuICAvLyBmb3IgYW4gb3B0aW9uIGJhc2VkIG9uIG5hbWUgYW5kIHR5cGUuXG4gIGZ1bmN0aW9uIGRlZmF1bHRWYWx1ZSAoa2V5KSB7XG4gICAgaWYgKCFjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5ib29scykgJiZcbiAgICAgICAgIWNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLmNvdW50cykgJiZcbiAgICAgICAgYCR7a2V5fWAgaW4gZGVmYXVsdHMpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0c1trZXldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkZWZhdWx0Rm9yVHlwZShndWVzc1R5cGUoa2V5KSlcbiAgICB9XG4gIH1cblxuICAvLyByZXR1cm4gYSBkZWZhdWx0IHZhbHVlLCBnaXZlbiB0aGUgdHlwZSBvZiBhIGZsYWcuLFxuICAvLyBlLmcuLCBrZXkgb2YgdHlwZSAnc3RyaW5nJyB3aWxsIGRlZmF1bHQgdG8gJycsIHJhdGhlciB0aGFuICd0cnVlJy5cbiAgZnVuY3Rpb24gZGVmYXVsdEZvclR5cGUgKHR5cGUpIHtcbiAgICBjb25zdCBkZWYgPSB7XG4gICAgICBib29sZWFuOiB0cnVlLFxuICAgICAgc3RyaW5nOiAnJyxcbiAgICAgIG51bWJlcjogdW5kZWZpbmVkLFxuICAgICAgYXJyYXk6IFtdXG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZlt0eXBlXVxuICB9XG5cbiAgLy8gZ2l2ZW4gYSBmbGFnLCBlbmZvcmNlIGEgZGVmYXVsdCB0eXBlLlxuICBmdW5jdGlvbiBndWVzc1R5cGUgKGtleSkge1xuICAgIGxldCB0eXBlID0gJ2Jvb2xlYW4nXG4gICAgaWYgKGNoZWNrQWxsQWxpYXNlcyhrZXksIGZsYWdzLnN0cmluZ3MpKSB0eXBlID0gJ3N0cmluZydcbiAgICBlbHNlIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5udW1iZXJzKSkgdHlwZSA9ICdudW1iZXInXG4gICAgZWxzZSBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYm9vbHMpKSB0eXBlID0gJ2Jvb2xlYW4nXG4gICAgZWxzZSBpZiAoY2hlY2tBbGxBbGlhc2VzKGtleSwgZmxhZ3MuYXJyYXlzKSkgdHlwZSA9ICdhcnJheSdcbiAgICByZXR1cm4gdHlwZVxuICB9XG5cbiAgZnVuY3Rpb24gaXNOdW1iZXIgKHgpIHtcbiAgICBpZiAoeCA9PT0gbnVsbCB8fCB4ID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZVxuICAgIC8vIGlmIGxvYWRlZCBmcm9tIGNvbmZpZywgbWF5IGFscmVhZHkgYmUgYSBudW1iZXIuXG4gICAgaWYgKHR5cGVvZiB4ID09PSAnbnVtYmVyJykgcmV0dXJuIHRydWVcbiAgICAvLyBoZXhhZGVjaW1hbC5cbiAgICBpZiAoL14weFswLTlhLWZdKyQvaS50ZXN0KHgpKSByZXR1cm4gdHJ1ZVxuICAgIC8vIGRvbid0IHRyZWF0IDAxMjMgYXMgYSBudW1iZXI7IGFzIGl0IGRyb3BzIHRoZSBsZWFkaW5nICcwJy5cbiAgICBpZiAoeC5sZW5ndGggPiAxICYmIHhbMF0gPT09ICcwJykgcmV0dXJuIGZhbHNlXG4gICAgcmV0dXJuIC9eWy1dPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoZVstK10/XFxkKyk/JC8udGVzdCh4KVxuICB9XG5cbiAgZnVuY3Rpb24gaXNVbmRlZmluZWQgKG51bSkge1xuICAgIHJldHVybiBudW0gPT09IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gY2hlY2sgdXNlciBjb25maWd1cmF0aW9uIHNldHRpbmdzIGZvciBpbmNvbnNpc3RlbmNpZXNcbiAgZnVuY3Rpb24gY2hlY2tDb25maWd1cmF0aW9uICgpIHtcbiAgICAvLyBjb3VudCBrZXlzIHNob3VsZCBub3QgYmUgc2V0IGFzIGFycmF5L25hcmdcbiAgICBPYmplY3Qua2V5cyhmbGFncy5jb3VudHMpLmZpbmQoa2V5ID0+IHtcbiAgICAgIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5hcnJheXMpKSB7XG4gICAgICAgIGVycm9yID0gRXJyb3IoX18oJ0ludmFsaWQgY29uZmlndXJhdGlvbjogJXMsIG9wdHMuY291bnQgZXhjbHVkZXMgb3B0cy5hcnJheS4nLCBrZXkpKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChjaGVja0FsbEFsaWFzZXMoa2V5LCBmbGFncy5uYXJncykpIHtcbiAgICAgICAgZXJyb3IgPSBFcnJvcihfXygnSW52YWxpZCBjb25maWd1cmF0aW9uOiAlcywgb3B0cy5jb3VudCBleGNsdWRlcyBvcHRzLm5hcmcuJywga2V5KSlcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhcmd2OiBPYmplY3QuYXNzaWduKGFyZ3ZSZXR1cm4sIGFyZ3YpLFxuICAgIGVycm9yOiBlcnJvcixcbiAgICBhbGlhc2VzOiBPYmplY3QuYXNzaWduKHt9LCBmbGFncy5hbGlhc2VzKSxcbiAgICBuZXdBbGlhc2VzOiBPYmplY3QuYXNzaWduKHt9LCBuZXdBbGlhc2VzKSxcbiAgICBkZWZhdWx0ZWQ6IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRlZCksXG4gICAgY29uZmlndXJhdGlvbjogY29uZmlndXJhdGlvblxuICB9XG59XG5cbi8vIGlmIGFueSBhbGlhc2VzIHJlZmVyZW5jZSBlYWNoIG90aGVyLCB3ZSBzaG91bGRcbi8vIG1lcmdlIHRoZW0gdG9nZXRoZXIuXG5mdW5jdGlvbiBjb21iaW5lQWxpYXNlcyAoYWxpYXNlcykge1xuICBjb25zdCBhbGlhc0FycmF5cyA9IFtdXG4gIGNvbnN0IGNvbWJpbmVkID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuICBsZXQgY2hhbmdlID0gdHJ1ZVxuXG4gIC8vIHR1cm4gYWxpYXMgbG9va3VwIGhhc2gge2tleTogWydhbGlhczEnLCAnYWxpYXMyJ119IGludG9cbiAgLy8gYSBzaW1wbGUgYXJyYXkgWydrZXknLCAnYWxpYXMxJywgJ2FsaWFzMiddXG4gIE9iamVjdC5rZXlzKGFsaWFzZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGFsaWFzQXJyYXlzLnB1c2goXG4gICAgICBbXS5jb25jYXQoYWxpYXNlc1trZXldLCBrZXkpXG4gICAgKVxuICB9KVxuXG4gIC8vIGNvbWJpbmUgYXJyYXlzIHVudGlsIHplcm8gY2hhbmdlcyBhcmVcbiAgLy8gbWFkZSBpbiBhbiBpdGVyYXRpb24uXG4gIHdoaWxlIChjaGFuZ2UpIHtcbiAgICBjaGFuZ2UgPSBmYWxzZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxpYXNBcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGlpID0gaSArIDE7IGlpIDwgYWxpYXNBcnJheXMubGVuZ3RoOyBpaSsrKSB7XG4gICAgICAgIGNvbnN0IGludGVyc2VjdCA9IGFsaWFzQXJyYXlzW2ldLmZpbHRlcihmdW5jdGlvbiAodikge1xuICAgICAgICAgIHJldHVybiBhbGlhc0FycmF5c1tpaV0uaW5kZXhPZih2KSAhPT0gLTFcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoaW50ZXJzZWN0Lmxlbmd0aCkge1xuICAgICAgICAgIGFsaWFzQXJyYXlzW2ldID0gYWxpYXNBcnJheXNbaV0uY29uY2F0KGFsaWFzQXJyYXlzW2lpXSlcbiAgICAgICAgICBhbGlhc0FycmF5cy5zcGxpY2UoaWksIDEpXG4gICAgICAgICAgY2hhbmdlID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBtYXAgYXJyYXlzIGJhY2sgdG8gdGhlIGhhc2gtbG9va3VwIChkZS1kdXBlIHdoaWxlXG4gIC8vIHdlJ3JlIGF0IGl0KS5cbiAgYWxpYXNBcnJheXMuZm9yRWFjaChmdW5jdGlvbiAoYWxpYXNBcnJheSkge1xuICAgIGFsaWFzQXJyYXkgPSBhbGlhc0FycmF5LmZpbHRlcihmdW5jdGlvbiAodiwgaSwgc2VsZikge1xuICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZih2KSA9PT0gaVxuICAgIH0pXG4gICAgY29tYmluZWRbYWxpYXNBcnJheS5wb3AoKV0gPSBhbGlhc0FycmF5XG4gIH0pXG5cbiAgcmV0dXJuIGNvbWJpbmVkXG59XG5cbi8vIHRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW4gYSBjb3VudCBpcyBnaXZlbiBhcyBhbiBhcmdcbi8vIGl0IGlzIE5PVCBjYWxsZWQgdG8gc2V0IGEgZGVmYXVsdCB2YWx1ZVxuLy8gdGh1cyB3ZSBjYW4gc3RhcnQgdGhlIGNvdW50IGF0IDEgaW5zdGVhZCBvZiAwXG5mdW5jdGlvbiBpbmNyZW1lbnQgKG9yaWcpIHtcbiAgcmV0dXJuIG9yaWcgIT09IHVuZGVmaW5lZCA/IG9yaWcgKyAxIDogMVxufVxuXG5mdW5jdGlvbiBQYXJzZXIgKGFyZ3MsIG9wdHMpIHtcbiAgY29uc3QgcmVzdWx0ID0gcGFyc2UoYXJncy5zbGljZSgpLCBvcHRzKVxuICByZXR1cm4gcmVzdWx0LmFyZ3Zcbn1cblxuLy8gcGFyc2UgYXJndW1lbnRzIGFuZCByZXR1cm4gZGV0YWlsZWRcbi8vIG1ldGEgaW5mb3JtYXRpb24sIGFsaWFzZXMsIGV0Yy5cblBhcnNlci5kZXRhaWxlZCA9IGZ1bmN0aW9uIChhcmdzLCBvcHRzKSB7XG4gIHJldHVybiBwYXJzZShhcmdzLnNsaWNlKCksIG9wdHMpXG59XG5cbi8vIFRPRE8oYmNvZSk6IGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgeWFyZ3MsIHN3aXRjaCB0b1xuLy8gT2JqZWN0LmNyZWF0ZShudWxsKSBmb3IgZG90IG5vdGF0aW9uOlxuZnVuY3Rpb24gc2FuaXRpemVLZXkgKGtleSkge1xuICBpZiAoa2V5ID09PSAnX19wcm90b19fJykgcmV0dXJuICdfX19wcm90b19fXydcbiAgcmV0dXJuIGtleVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBhcnNlclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.objFilter = void 0;\nconst common_types_1 = __webpack_require__(1);\nfunction objFilter(original = {}, filter = () => true) {\n    const obj = {};\n    common_types_1.objectKeys(original).forEach((key) => {\n        if (filter(key, original[key])) {\n            obj[key] = original[key];\n        }\n    });\n    return obj;\n}\nexports.objFilter = objFilter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliL29iai1maWx0ZXIuanM/OWY3OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsQ0FBZ0I7QUFDL0MsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm9iakZpbHRlciA9IHZvaWQgMDtcbmNvbnN0IGNvbW1vbl90eXBlc18xID0gcmVxdWlyZShcIi4vY29tbW9uLXR5cGVzXCIpO1xuZnVuY3Rpb24gb2JqRmlsdGVyKG9yaWdpbmFsID0ge30sIGZpbHRlciA9ICgpID0+IHRydWUpIHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBjb21tb25fdHlwZXNfMS5vYmplY3RLZXlzKG9yaWdpbmFsKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKGZpbHRlcihrZXksIG9yaWdpbmFsW2tleV0pKSB7XG4gICAgICAgICAgICBvYmpba2V5XSA9IG9yaWdpbmFsW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gb2JqO1xufVxuZXhwb3J0cy5vYmpGaWx0ZXIgPSBvYmpGaWx0ZXI7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n')},function(module,exports,__webpack_require__){"use strict";eval("\nconst stripAnsi = __webpack_require__(4);\nconst isFullwidthCodePoint = __webpack_require__(57);\nconst emojiRegex = __webpack_require__(58);\n\nconst stringWidth = string => {\n\tstring = string.replace(emojiRegex(), '  ');\n\n\tif (typeof string !== 'string' || string.length === 0) {\n\t\treturn 0;\n\t}\n\n\tstring = stripAnsi(string);\n\n\tlet width = 0;\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tconst code = string.codePointAt(i);\n\n\t\t// Ignore control characters\n\t\tif (code <= 0x1F || (code >= 0x7F && code <= 0x9F)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Ignore combining characters\n\t\tif (code >= 0x300 && code <= 0x36F) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Surrogates\n\t\tif (code > 0xFFFF) {\n\t\t\ti++;\n\t\t}\n\n\t\twidth += isFullwidthCodePoint(code) ? 2 : 1;\n\t}\n\n\treturn width;\n};\n\nmodule.exports = stringWidth;\n// TODO: remove this in the next major version\nmodule.exports.default = stringWidth;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyaW5nLXdpZHRoL2luZGV4LmpzP2FjZWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixrQkFBa0IsbUJBQU8sQ0FBQyxDQUFZO0FBQ3RDLDZCQUE2QixtQkFBTyxDQUFDLEVBQXlCO0FBQzlELG1CQUFtQixtQkFBTyxDQUFDLEVBQWE7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLGdCQUFnQixtQkFBbUI7QUFDbkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IHN0cmlwQW5zaSA9IHJlcXVpcmUoJ3N0cmlwLWFuc2knKTtcbmNvbnN0IGlzRnVsbHdpZHRoQ29kZVBvaW50ID0gcmVxdWlyZSgnaXMtZnVsbHdpZHRoLWNvZGUtcG9pbnQnKTtcbmNvbnN0IGVtb2ppUmVnZXggPSByZXF1aXJlKCdlbW9qaS1yZWdleCcpO1xuXG5jb25zdCBzdHJpbmdXaWR0aCA9IHN0cmluZyA9PiB7XG5cdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGVtb2ppUmVnZXgoKSwgJyAgJyk7XG5cblx0aWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnIHx8IHN0cmluZy5sZW5ndGggPT09IDApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdHN0cmluZyA9IHN0cmlwQW5zaShzdHJpbmcpO1xuXG5cdGxldCB3aWR0aCA9IDA7XG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcblx0XHRjb25zdCBjb2RlID0gc3RyaW5nLmNvZGVQb2ludEF0KGkpO1xuXG5cdFx0Ly8gSWdub3JlIGNvbnRyb2wgY2hhcmFjdGVyc1xuXHRcdGlmIChjb2RlIDw9IDB4MUYgfHwgKGNvZGUgPj0gMHg3RiAmJiBjb2RlIDw9IDB4OUYpKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHQvLyBJZ25vcmUgY29tYmluaW5nIGNoYXJhY3RlcnNcblx0XHRpZiAoY29kZSA+PSAweDMwMCAmJiBjb2RlIDw9IDB4MzZGKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHQvLyBTdXJyb2dhdGVzXG5cdFx0aWYgKGNvZGUgPiAweEZGRkYpIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHR3aWR0aCArPSBpc0Z1bGx3aWR0aENvZGVQb2ludChjb2RlKSA/IDIgOiAxO1xuXHR9XG5cblx0cmV0dXJuIHdpZHRoO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdXaWR0aDtcbi8vIFRPRE86IHJlbW92ZSB0aGlzIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb25cbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBzdHJpbmdXaWR0aDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///14\n")},function(module,exports,__webpack_require__){"use strict";eval("\nconst ansiStyles = __webpack_require__(16);\nconst {stdout: stdoutColor, stderr: stderrColor} = __webpack_require__(31);\nconst {\n\tstringReplaceAll,\n\tstringEncaseCRLFWithFirstIndex\n} = __webpack_require__(35);\n\nconst {isArray} = Array;\n\n// `supportsColor.level` → `ansiStyles.color[name]` mapping\nconst levelMapping = [\n\t'ansi',\n\t'ansi',\n\t'ansi256',\n\t'ansi16m'\n];\n\nconst styles = Object.create(null);\n\nconst applyOptions = (object, options = {}) => {\n\tif (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {\n\t\tthrow new Error('The `level` option should be an integer from 0 to 3');\n\t}\n\n\t// Detect level if not set manually\n\tconst colorLevel = stdoutColor ? stdoutColor.level : 0;\n\tobject.level = options.level === undefined ? colorLevel : options.level;\n};\n\nclass ChalkClass {\n\tconstructor(options) {\n\t\t// eslint-disable-next-line no-constructor-return\n\t\treturn chalkFactory(options);\n\t}\n}\n\nconst chalkFactory = options => {\n\tconst chalk = {};\n\tapplyOptions(chalk, options);\n\n\tchalk.template = (...arguments_) => chalkTag(chalk.template, ...arguments_);\n\n\tObject.setPrototypeOf(chalk, Chalk.prototype);\n\tObject.setPrototypeOf(chalk.template, chalk);\n\n\tchalk.template.constructor = () => {\n\t\tthrow new Error('`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.');\n\t};\n\n\tchalk.template.Instance = ChalkClass;\n\n\treturn chalk.template;\n};\n\nfunction Chalk(options) {\n\treturn chalkFactory(options);\n}\n\nfor (const [styleName, style] of Object.entries(ansiStyles)) {\n\tstyles[styleName] = {\n\t\tget() {\n\t\t\tconst builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);\n\t\t\tObject.defineProperty(this, styleName, {value: builder});\n\t\t\treturn builder;\n\t\t}\n\t};\n}\n\nstyles.visible = {\n\tget() {\n\t\tconst builder = createBuilder(this, this._styler, true);\n\t\tObject.defineProperty(this, 'visible', {value: builder});\n\t\treturn builder;\n\t}\n};\n\nconst usedModels = ['rgb', 'hex', 'keyword', 'hsl', 'hsv', 'hwb', 'ansi', 'ansi256'];\n\nfor (const model of usedModels) {\n\tstyles[model] = {\n\t\tget() {\n\t\t\tconst {level} = this;\n\t\t\treturn function (...arguments_) {\n\t\t\t\tconst styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);\n\t\t\t\treturn createBuilder(this, styler, this._isEmpty);\n\t\t\t};\n\t\t}\n\t};\n}\n\nfor (const model of usedModels) {\n\tconst bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);\n\tstyles[bgModel] = {\n\t\tget() {\n\t\t\tconst {level} = this;\n\t\t\treturn function (...arguments_) {\n\t\t\t\tconst styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);\n\t\t\t\treturn createBuilder(this, styler, this._isEmpty);\n\t\t\t};\n\t\t}\n\t};\n}\n\nconst proto = Object.defineProperties(() => {}, {\n\t...styles,\n\tlevel: {\n\t\tenumerable: true,\n\t\tget() {\n\t\t\treturn this._generator.level;\n\t\t},\n\t\tset(level) {\n\t\t\tthis._generator.level = level;\n\t\t}\n\t}\n});\n\nconst createStyler = (open, close, parent) => {\n\tlet openAll;\n\tlet closeAll;\n\tif (parent === undefined) {\n\t\topenAll = open;\n\t\tcloseAll = close;\n\t} else {\n\t\topenAll = parent.openAll + open;\n\t\tcloseAll = close + parent.closeAll;\n\t}\n\n\treturn {\n\t\topen,\n\t\tclose,\n\t\topenAll,\n\t\tcloseAll,\n\t\tparent\n\t};\n};\n\nconst createBuilder = (self, _styler, _isEmpty) => {\n\tconst builder = (...arguments_) => {\n\t\tif (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {\n\t\t\t// Called as a template literal, for example: chalk.red`2 + 3 = {bold ${2+3}}`\n\t\t\treturn applyStyle(builder, chalkTag(builder, ...arguments_));\n\t\t}\n\n\t\t// Single argument is hot path, implicit coercion is faster than anything\n\t\t// eslint-disable-next-line no-implicit-coercion\n\t\treturn applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));\n\t};\n\n\t// We alter the prototype because we must return a function, but there is\n\t// no way to create a function with a different prototype\n\tObject.setPrototypeOf(builder, proto);\n\n\tbuilder._generator = self;\n\tbuilder._styler = _styler;\n\tbuilder._isEmpty = _isEmpty;\n\n\treturn builder;\n};\n\nconst applyStyle = (self, string) => {\n\tif (self.level <= 0 || !string) {\n\t\treturn self._isEmpty ? '' : string;\n\t}\n\n\tlet styler = self._styler;\n\n\tif (styler === undefined) {\n\t\treturn string;\n\t}\n\n\tconst {openAll, closeAll} = styler;\n\tif (string.indexOf('\\u001B') !== -1) {\n\t\twhile (styler !== undefined) {\n\t\t\t// Replace any instances already present with a re-opening code\n\t\t\t// otherwise only the part of the string until said closing code\n\t\t\t// will be colored, and the rest will simply be 'plain'.\n\t\t\tstring = stringReplaceAll(string, styler.close, styler.open);\n\n\t\t\tstyler = styler.parent;\n\t\t}\n\t}\n\n\t// We can move both next actions out of loop, because remaining actions in loop won't have\n\t// any/visible effect on parts we add here. Close the styling before a linebreak and reopen\n\t// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92\n\tconst lfIndex = string.indexOf('\\n');\n\tif (lfIndex !== -1) {\n\t\tstring = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);\n\t}\n\n\treturn openAll + string + closeAll;\n};\n\nlet template;\nconst chalkTag = (chalk, ...strings) => {\n\tconst [firstString] = strings;\n\n\tif (!isArray(firstString) || !isArray(firstString.raw)) {\n\t\t// If chalk() was called by itself or with a string,\n\t\t// return the string itself as a string.\n\t\treturn strings.join(' ');\n\t}\n\n\tconst arguments_ = strings.slice(1);\n\tconst parts = [firstString.raw[0]];\n\n\tfor (let i = 1; i < firstString.length; i++) {\n\t\tparts.push(\n\t\t\tString(arguments_[i - 1]).replace(/[{}\\\\]/g, '\\\\$&'),\n\t\t\tString(firstString.raw[i])\n\t\t);\n\t}\n\n\tif (template === undefined) {\n\t\ttemplate = __webpack_require__(36);\n\t}\n\n\treturn template(chalk, parts.join(''));\n};\n\nObject.defineProperties(Chalk.prototype, styles);\n\nconst chalk = Chalk(); // eslint-disable-line new-cap\nchalk.supportsColor = stdoutColor;\nchalk.stderr = Chalk({level: stderrColor ? stderrColor.level : 0}); // eslint-disable-line new-cap\nchalk.stderr.supportsColor = stderrColor;\n\nmodule.exports = chalk;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hhbGsvc291cmNlL2luZGV4LmpzPzUzZjQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixtQkFBbUIsbUJBQU8sQ0FBQyxFQUFhO0FBQ3hDLE9BQU8seUNBQXlDLEdBQUcsbUJBQU8sQ0FBQyxFQUFnQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUcsbUJBQU8sQ0FBQyxFQUFROztBQUVwQixPQUFPLFFBQVE7O0FBRWY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGVBQWU7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGVBQWU7QUFDekQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsTUFBTTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxPQUFPLEtBQUs7QUFDaEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFFBQVEsa0JBQWtCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQix3QkFBd0I7QUFDeEM7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLEVBQWE7QUFDbEM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0IsMkNBQTJDLEVBQUU7QUFDbkU7O0FBRUEiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBhbnNpU3R5bGVzID0gcmVxdWlyZSgnYW5zaS1zdHlsZXMnKTtcbmNvbnN0IHtzdGRvdXQ6IHN0ZG91dENvbG9yLCBzdGRlcnI6IHN0ZGVyckNvbG9yfSA9IHJlcXVpcmUoJ3N1cHBvcnRzLWNvbG9yJyk7XG5jb25zdCB7XG5cdHN0cmluZ1JlcGxhY2VBbGwsXG5cdHN0cmluZ0VuY2FzZUNSTEZXaXRoRmlyc3RJbmRleFxufSA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5jb25zdCB7aXNBcnJheX0gPSBBcnJheTtcblxuLy8gYHN1cHBvcnRzQ29sb3IubGV2ZWxgIOKGkiBgYW5zaVN0eWxlcy5jb2xvcltuYW1lXWAgbWFwcGluZ1xuY29uc3QgbGV2ZWxNYXBwaW5nID0gW1xuXHQnYW5zaScsXG5cdCdhbnNpJyxcblx0J2Fuc2kyNTYnLFxuXHQnYW5zaTE2bSdcbl07XG5cbmNvbnN0IHN0eWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmNvbnN0IGFwcGx5T3B0aW9ucyA9IChvYmplY3QsIG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRpZiAob3B0aW9ucy5sZXZlbCAmJiAhKE51bWJlci5pc0ludGVnZXIob3B0aW9ucy5sZXZlbCkgJiYgb3B0aW9ucy5sZXZlbCA+PSAwICYmIG9wdGlvbnMubGV2ZWwgPD0gMykpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RoZSBgbGV2ZWxgIG9wdGlvbiBzaG91bGQgYmUgYW4gaW50ZWdlciBmcm9tIDAgdG8gMycpO1xuXHR9XG5cblx0Ly8gRGV0ZWN0IGxldmVsIGlmIG5vdCBzZXQgbWFudWFsbHlcblx0Y29uc3QgY29sb3JMZXZlbCA9IHN0ZG91dENvbG9yID8gc3Rkb3V0Q29sb3IubGV2ZWwgOiAwO1xuXHRvYmplY3QubGV2ZWwgPSBvcHRpb25zLmxldmVsID09PSB1bmRlZmluZWQgPyBjb2xvckxldmVsIDogb3B0aW9ucy5sZXZlbDtcbn07XG5cbmNsYXNzIENoYWxrQ2xhc3Mge1xuXHRjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0cnVjdG9yLXJldHVyblxuXHRcdHJldHVybiBjaGFsa0ZhY3Rvcnkob3B0aW9ucyk7XG5cdH1cbn1cblxuY29uc3QgY2hhbGtGYWN0b3J5ID0gb3B0aW9ucyA9PiB7XG5cdGNvbnN0IGNoYWxrID0ge307XG5cdGFwcGx5T3B0aW9ucyhjaGFsaywgb3B0aW9ucyk7XG5cblx0Y2hhbGsudGVtcGxhdGUgPSAoLi4uYXJndW1lbnRzXykgPT4gY2hhbGtUYWcoY2hhbGsudGVtcGxhdGUsIC4uLmFyZ3VtZW50c18pO1xuXG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZihjaGFsaywgQ2hhbGsucHJvdG90eXBlKTtcblx0T2JqZWN0LnNldFByb3RvdHlwZU9mKGNoYWxrLnRlbXBsYXRlLCBjaGFsayk7XG5cblx0Y2hhbGsudGVtcGxhdGUuY29uc3RydWN0b3IgPSAoKSA9PiB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdgY2hhbGsuY29uc3RydWN0b3IoKWAgaXMgZGVwcmVjYXRlZC4gVXNlIGBuZXcgY2hhbGsuSW5zdGFuY2UoKWAgaW5zdGVhZC4nKTtcblx0fTtcblxuXHRjaGFsay50ZW1wbGF0ZS5JbnN0YW5jZSA9IENoYWxrQ2xhc3M7XG5cblx0cmV0dXJuIGNoYWxrLnRlbXBsYXRlO1xufTtcblxuZnVuY3Rpb24gQ2hhbGsob3B0aW9ucykge1xuXHRyZXR1cm4gY2hhbGtGYWN0b3J5KG9wdGlvbnMpO1xufVxuXG5mb3IgKGNvbnN0IFtzdHlsZU5hbWUsIHN0eWxlXSBvZiBPYmplY3QuZW50cmllcyhhbnNpU3R5bGVzKSkge1xuXHRzdHlsZXNbc3R5bGVOYW1lXSA9IHtcblx0XHRnZXQoKSB7XG5cdFx0XHRjb25zdCBidWlsZGVyID0gY3JlYXRlQnVpbGRlcih0aGlzLCBjcmVhdGVTdHlsZXIoc3R5bGUub3Blbiwgc3R5bGUuY2xvc2UsIHRoaXMuX3N0eWxlciksIHRoaXMuX2lzRW1wdHkpO1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHN0eWxlTmFtZSwge3ZhbHVlOiBidWlsZGVyfSk7XG5cdFx0XHRyZXR1cm4gYnVpbGRlcjtcblx0XHR9XG5cdH07XG59XG5cbnN0eWxlcy52aXNpYmxlID0ge1xuXHRnZXQoKSB7XG5cdFx0Y29uc3QgYnVpbGRlciA9IGNyZWF0ZUJ1aWxkZXIodGhpcywgdGhpcy5fc3R5bGVyLCB0cnVlKTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3Zpc2libGUnLCB7dmFsdWU6IGJ1aWxkZXJ9KTtcblx0XHRyZXR1cm4gYnVpbGRlcjtcblx0fVxufTtcblxuY29uc3QgdXNlZE1vZGVscyA9IFsncmdiJywgJ2hleCcsICdrZXl3b3JkJywgJ2hzbCcsICdoc3YnLCAnaHdiJywgJ2Fuc2knLCAnYW5zaTI1NiddO1xuXG5mb3IgKGNvbnN0IG1vZGVsIG9mIHVzZWRNb2RlbHMpIHtcblx0c3R5bGVzW21vZGVsXSA9IHtcblx0XHRnZXQoKSB7XG5cdFx0XHRjb25zdCB7bGV2ZWx9ID0gdGhpcztcblx0XHRcdHJldHVybiBmdW5jdGlvbiAoLi4uYXJndW1lbnRzXykge1xuXHRcdFx0XHRjb25zdCBzdHlsZXIgPSBjcmVhdGVTdHlsZXIoYW5zaVN0eWxlcy5jb2xvcltsZXZlbE1hcHBpbmdbbGV2ZWxdXVttb2RlbF0oLi4uYXJndW1lbnRzXyksIGFuc2lTdHlsZXMuY29sb3IuY2xvc2UsIHRoaXMuX3N0eWxlcik7XG5cdFx0XHRcdHJldHVybiBjcmVhdGVCdWlsZGVyKHRoaXMsIHN0eWxlciwgdGhpcy5faXNFbXB0eSk7XG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcbn1cblxuZm9yIChjb25zdCBtb2RlbCBvZiB1c2VkTW9kZWxzKSB7XG5cdGNvbnN0IGJnTW9kZWwgPSAnYmcnICsgbW9kZWxbMF0udG9VcHBlckNhc2UoKSArIG1vZGVsLnNsaWNlKDEpO1xuXHRzdHlsZXNbYmdNb2RlbF0gPSB7XG5cdFx0Z2V0KCkge1xuXHRcdFx0Y29uc3Qge2xldmVsfSA9IHRoaXM7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3VtZW50c18pIHtcblx0XHRcdFx0Y29uc3Qgc3R5bGVyID0gY3JlYXRlU3R5bGVyKGFuc2lTdHlsZXMuYmdDb2xvcltsZXZlbE1hcHBpbmdbbGV2ZWxdXVttb2RlbF0oLi4uYXJndW1lbnRzXyksIGFuc2lTdHlsZXMuYmdDb2xvci5jbG9zZSwgdGhpcy5fc3R5bGVyKTtcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZUJ1aWxkZXIodGhpcywgc3R5bGVyLCB0aGlzLl9pc0VtcHR5KTtcblx0XHRcdH07XG5cdFx0fVxuXHR9O1xufVxuXG5jb25zdCBwcm90byA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCgpID0+IHt9LCB7XG5cdC4uLnN0eWxlcyxcblx0bGV2ZWw6IHtcblx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9nZW5lcmF0b3IubGV2ZWw7XG5cdFx0fSxcblx0XHRzZXQobGV2ZWwpIHtcblx0XHRcdHRoaXMuX2dlbmVyYXRvci5sZXZlbCA9IGxldmVsO1xuXHRcdH1cblx0fVxufSk7XG5cbmNvbnN0IGNyZWF0ZVN0eWxlciA9IChvcGVuLCBjbG9zZSwgcGFyZW50KSA9PiB7XG5cdGxldCBvcGVuQWxsO1xuXHRsZXQgY2xvc2VBbGw7XG5cdGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdG9wZW5BbGwgPSBvcGVuO1xuXHRcdGNsb3NlQWxsID0gY2xvc2U7XG5cdH0gZWxzZSB7XG5cdFx0b3BlbkFsbCA9IHBhcmVudC5vcGVuQWxsICsgb3Blbjtcblx0XHRjbG9zZUFsbCA9IGNsb3NlICsgcGFyZW50LmNsb3NlQWxsO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRvcGVuLFxuXHRcdGNsb3NlLFxuXHRcdG9wZW5BbGwsXG5cdFx0Y2xvc2VBbGwsXG5cdFx0cGFyZW50XG5cdH07XG59O1xuXG5jb25zdCBjcmVhdGVCdWlsZGVyID0gKHNlbGYsIF9zdHlsZXIsIF9pc0VtcHR5KSA9PiB7XG5cdGNvbnN0IGJ1aWxkZXIgPSAoLi4uYXJndW1lbnRzXykgPT4ge1xuXHRcdGlmIChpc0FycmF5KGFyZ3VtZW50c19bMF0pICYmIGlzQXJyYXkoYXJndW1lbnRzX1swXS5yYXcpKSB7XG5cdFx0XHQvLyBDYWxsZWQgYXMgYSB0ZW1wbGF0ZSBsaXRlcmFsLCBmb3IgZXhhbXBsZTogY2hhbGsucmVkYDIgKyAzID0ge2JvbGQgJHsyKzN9fWBcblx0XHRcdHJldHVybiBhcHBseVN0eWxlKGJ1aWxkZXIsIGNoYWxrVGFnKGJ1aWxkZXIsIC4uLmFyZ3VtZW50c18pKTtcblx0XHR9XG5cblx0XHQvLyBTaW5nbGUgYXJndW1lbnQgaXMgaG90IHBhdGgsIGltcGxpY2l0IGNvZXJjaW9uIGlzIGZhc3RlciB0aGFuIGFueXRoaW5nXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWltcGxpY2l0LWNvZXJjaW9uXG5cdFx0cmV0dXJuIGFwcGx5U3R5bGUoYnVpbGRlciwgKGFyZ3VtZW50c18ubGVuZ3RoID09PSAxKSA/ICgnJyArIGFyZ3VtZW50c19bMF0pIDogYXJndW1lbnRzXy5qb2luKCcgJykpO1xuXHR9O1xuXG5cdC8vIFdlIGFsdGVyIHRoZSBwcm90b3R5cGUgYmVjYXVzZSB3ZSBtdXN0IHJldHVybiBhIGZ1bmN0aW9uLCBidXQgdGhlcmUgaXNcblx0Ly8gbm8gd2F5IHRvIGNyZWF0ZSBhIGZ1bmN0aW9uIHdpdGggYSBkaWZmZXJlbnQgcHJvdG90eXBlXG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZihidWlsZGVyLCBwcm90byk7XG5cblx0YnVpbGRlci5fZ2VuZXJhdG9yID0gc2VsZjtcblx0YnVpbGRlci5fc3R5bGVyID0gX3N0eWxlcjtcblx0YnVpbGRlci5faXNFbXB0eSA9IF9pc0VtcHR5O1xuXG5cdHJldHVybiBidWlsZGVyO1xufTtcblxuY29uc3QgYXBwbHlTdHlsZSA9IChzZWxmLCBzdHJpbmcpID0+IHtcblx0aWYgKHNlbGYubGV2ZWwgPD0gMCB8fCAhc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHNlbGYuX2lzRW1wdHkgPyAnJyA6IHN0cmluZztcblx0fVxuXG5cdGxldCBzdHlsZXIgPSBzZWxmLl9zdHlsZXI7XG5cblx0aWYgKHN0eWxlciA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIHN0cmluZztcblx0fVxuXG5cdGNvbnN0IHtvcGVuQWxsLCBjbG9zZUFsbH0gPSBzdHlsZXI7XG5cdGlmIChzdHJpbmcuaW5kZXhPZignXFx1MDAxQicpICE9PSAtMSkge1xuXHRcdHdoaWxlIChzdHlsZXIgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Ly8gUmVwbGFjZSBhbnkgaW5zdGFuY2VzIGFscmVhZHkgcHJlc2VudCB3aXRoIGEgcmUtb3BlbmluZyBjb2RlXG5cdFx0XHQvLyBvdGhlcndpc2Ugb25seSB0aGUgcGFydCBvZiB0aGUgc3RyaW5nIHVudGlsIHNhaWQgY2xvc2luZyBjb2RlXG5cdFx0XHQvLyB3aWxsIGJlIGNvbG9yZWQsIGFuZCB0aGUgcmVzdCB3aWxsIHNpbXBseSBiZSAncGxhaW4nLlxuXHRcdFx0c3RyaW5nID0gc3RyaW5nUmVwbGFjZUFsbChzdHJpbmcsIHN0eWxlci5jbG9zZSwgc3R5bGVyLm9wZW4pO1xuXG5cdFx0XHRzdHlsZXIgPSBzdHlsZXIucGFyZW50O1xuXHRcdH1cblx0fVxuXG5cdC8vIFdlIGNhbiBtb3ZlIGJvdGggbmV4dCBhY3Rpb25zIG91dCBvZiBsb29wLCBiZWNhdXNlIHJlbWFpbmluZyBhY3Rpb25zIGluIGxvb3Agd29uJ3QgaGF2ZVxuXHQvLyBhbnkvdmlzaWJsZSBlZmZlY3Qgb24gcGFydHMgd2UgYWRkIGhlcmUuIENsb3NlIHRoZSBzdHlsaW5nIGJlZm9yZSBhIGxpbmVicmVhayBhbmQgcmVvcGVuXG5cdC8vIGFmdGVyIG5leHQgbGluZSB0byBmaXggYSBibGVlZCBpc3N1ZSBvbiBtYWNPUzogaHR0cHM6Ly9naXRodWIuY29tL2NoYWxrL2NoYWxrL3B1bGwvOTJcblx0Y29uc3QgbGZJbmRleCA9IHN0cmluZy5pbmRleE9mKCdcXG4nKTtcblx0aWYgKGxmSW5kZXggIT09IC0xKSB7XG5cdFx0c3RyaW5nID0gc3RyaW5nRW5jYXNlQ1JMRldpdGhGaXJzdEluZGV4KHN0cmluZywgY2xvc2VBbGwsIG9wZW5BbGwsIGxmSW5kZXgpO1xuXHR9XG5cblx0cmV0dXJuIG9wZW5BbGwgKyBzdHJpbmcgKyBjbG9zZUFsbDtcbn07XG5cbmxldCB0ZW1wbGF0ZTtcbmNvbnN0IGNoYWxrVGFnID0gKGNoYWxrLCAuLi5zdHJpbmdzKSA9PiB7XG5cdGNvbnN0IFtmaXJzdFN0cmluZ10gPSBzdHJpbmdzO1xuXG5cdGlmICghaXNBcnJheShmaXJzdFN0cmluZykgfHwgIWlzQXJyYXkoZmlyc3RTdHJpbmcucmF3KSkge1xuXHRcdC8vIElmIGNoYWxrKCkgd2FzIGNhbGxlZCBieSBpdHNlbGYgb3Igd2l0aCBhIHN0cmluZyxcblx0XHQvLyByZXR1cm4gdGhlIHN0cmluZyBpdHNlbGYgYXMgYSBzdHJpbmcuXG5cdFx0cmV0dXJuIHN0cmluZ3Muam9pbignICcpO1xuXHR9XG5cblx0Y29uc3QgYXJndW1lbnRzXyA9IHN0cmluZ3Muc2xpY2UoMSk7XG5cdGNvbnN0IHBhcnRzID0gW2ZpcnN0U3RyaW5nLnJhd1swXV07XG5cblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBmaXJzdFN0cmluZy5sZW5ndGg7IGkrKykge1xuXHRcdHBhcnRzLnB1c2goXG5cdFx0XHRTdHJpbmcoYXJndW1lbnRzX1tpIC0gMV0pLnJlcGxhY2UoL1t7fVxcXFxdL2csICdcXFxcJCYnKSxcblx0XHRcdFN0cmluZyhmaXJzdFN0cmluZy5yYXdbaV0pXG5cdFx0KTtcblx0fVxuXG5cdGlmICh0ZW1wbGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlcycpO1xuXHR9XG5cblx0cmV0dXJuIHRlbXBsYXRlKGNoYWxrLCBwYXJ0cy5qb2luKCcnKSk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDaGFsay5wcm90b3R5cGUsIHN0eWxlcyk7XG5cbmNvbnN0IGNoYWxrID0gQ2hhbGsoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG5jaGFsay5zdXBwb3J0c0NvbG9yID0gc3Rkb3V0Q29sb3I7XG5jaGFsay5zdGRlcnIgPSBDaGFsayh7bGV2ZWw6IHN0ZGVyckNvbG9yID8gc3RkZXJyQ29sb3IubGV2ZWwgOiAwfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuY2hhbGsuc3RkZXJyLnN1cHBvcnRzQ29sb3IgPSBzdGRlcnJDb2xvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBjaGFsaztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///15\n")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(module) {\n\nconst wrapAnsi16 = (fn, offset) => (...args) => {\n\tconst code = fn(...args);\n\treturn `\\u001B[${code + offset}m`;\n};\n\nconst wrapAnsi256 = (fn, offset) => (...args) => {\n\tconst code = fn(...args);\n\treturn `\\u001B[${38 + offset};5;${code}m`;\n};\n\nconst wrapAnsi16m = (fn, offset) => (...args) => {\n\tconst rgb = fn(...args);\n\treturn `\\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;\n};\n\nconst ansi2ansi = n => n;\nconst rgb2rgb = (r, g, b) => [r, g, b];\n\nconst setLazyProperty = (object, property, get) => {\n\tObject.defineProperty(object, property, {\n\t\tget: () => {\n\t\t\tconst value = get();\n\n\t\t\tObject.defineProperty(object, property, {\n\t\t\t\tvalue,\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true\n\t\t\t});\n\n\t\t\treturn value;\n\t\t},\n\t\tenumerable: true,\n\t\tconfigurable: true\n\t});\n};\n\n/** @type {typeof import('color-convert')} */\nlet colorConvert;\nconst makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {\n\tif (colorConvert === undefined) {\n\t\tcolorConvert = __webpack_require__(28);\n\t}\n\n\tconst offset = isBackground ? 10 : 0;\n\tconst styles = {};\n\n\tfor (const [sourceSpace, suite] of Object.entries(colorConvert)) {\n\t\tconst name = sourceSpace === 'ansi16' ? 'ansi' : sourceSpace;\n\t\tif (sourceSpace === targetSpace) {\n\t\t\tstyles[name] = wrap(identity, offset);\n\t\t} else if (typeof suite === 'object') {\n\t\t\tstyles[name] = wrap(suite[targetSpace], offset);\n\t\t}\n\t}\n\n\treturn styles;\n};\n\nfunction assembleStyles() {\n\tconst codes = new Map();\n\tconst styles = {\n\t\tmodifier: {\n\t\t\treset: [0, 0],\n\t\t\t// 21 isn't widely supported and 22 does the same thing\n\t\t\tbold: [1, 22],\n\t\t\tdim: [2, 22],\n\t\t\titalic: [3, 23],\n\t\t\tunderline: [4, 24],\n\t\t\tinverse: [7, 27],\n\t\t\thidden: [8, 28],\n\t\t\tstrikethrough: [9, 29]\n\t\t},\n\t\tcolor: {\n\t\t\tblack: [30, 39],\n\t\t\tred: [31, 39],\n\t\t\tgreen: [32, 39],\n\t\t\tyellow: [33, 39],\n\t\t\tblue: [34, 39],\n\t\t\tmagenta: [35, 39],\n\t\t\tcyan: [36, 39],\n\t\t\twhite: [37, 39],\n\n\t\t\t// Bright color\n\t\t\tblackBright: [90, 39],\n\t\t\tredBright: [91, 39],\n\t\t\tgreenBright: [92, 39],\n\t\t\tyellowBright: [93, 39],\n\t\t\tblueBright: [94, 39],\n\t\t\tmagentaBright: [95, 39],\n\t\t\tcyanBright: [96, 39],\n\t\t\twhiteBright: [97, 39]\n\t\t},\n\t\tbgColor: {\n\t\t\tbgBlack: [40, 49],\n\t\t\tbgRed: [41, 49],\n\t\t\tbgGreen: [42, 49],\n\t\t\tbgYellow: [43, 49],\n\t\t\tbgBlue: [44, 49],\n\t\t\tbgMagenta: [45, 49],\n\t\t\tbgCyan: [46, 49],\n\t\t\tbgWhite: [47, 49],\n\n\t\t\t// Bright color\n\t\t\tbgBlackBright: [100, 49],\n\t\t\tbgRedBright: [101, 49],\n\t\t\tbgGreenBright: [102, 49],\n\t\t\tbgYellowBright: [103, 49],\n\t\t\tbgBlueBright: [104, 49],\n\t\t\tbgMagentaBright: [105, 49],\n\t\t\tbgCyanBright: [106, 49],\n\t\t\tbgWhiteBright: [107, 49]\n\t\t}\n\t};\n\n\t// Alias bright black as gray (and grey)\n\tstyles.color.gray = styles.color.blackBright;\n\tstyles.bgColor.bgGray = styles.bgColor.bgBlackBright;\n\tstyles.color.grey = styles.color.blackBright;\n\tstyles.bgColor.bgGrey = styles.bgColor.bgBlackBright;\n\n\tfor (const [groupName, group] of Object.entries(styles)) {\n\t\tfor (const [styleName, style] of Object.entries(group)) {\n\t\t\tstyles[styleName] = {\n\t\t\t\topen: `\\u001B[${style[0]}m`,\n\t\t\t\tclose: `\\u001B[${style[1]}m`\n\t\t\t};\n\n\t\t\tgroup[styleName] = styles[styleName];\n\n\t\t\tcodes.set(style[0], style[1]);\n\t\t}\n\n\t\tObject.defineProperty(styles, groupName, {\n\t\t\tvalue: group,\n\t\t\tenumerable: false\n\t\t});\n\t}\n\n\tObject.defineProperty(styles, 'codes', {\n\t\tvalue: codes,\n\t\tenumerable: false\n\t});\n\n\tstyles.color.close = '\\u001B[39m';\n\tstyles.bgColor.close = '\\u001B[49m';\n\n\tsetLazyProperty(styles.color, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, false));\n\tsetLazyProperty(styles.color, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, false));\n\tsetLazyProperty(styles.color, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, false));\n\tsetLazyProperty(styles.bgColor, 'ansi', () => makeDynamicStyles(wrapAnsi16, 'ansi16', ansi2ansi, true));\n\tsetLazyProperty(styles.bgColor, 'ansi256', () => makeDynamicStyles(wrapAnsi256, 'ansi256', ansi2ansi, true));\n\tsetLazyProperty(styles.bgColor, 'ansi16m', () => makeDynamicStyles(wrapAnsi16m, 'rgb', rgb2rgb, true));\n\n\treturn styles;\n}\n\n// Make the export immutable\nObject.defineProperty(module, 'exports', {\n\tenumerable: true,\n\tget: assembleStyles\n});\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(27)(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5zaS1zdHlsZXMvaW5kZXguanM/OGEzMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw4Q0FBYTs7QUFFYjtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixhQUFhLEVBQUUsRUFBRSxLQUFLO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYSxFQUFFLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxPQUFPO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsV0FBVywrQkFBK0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFPLENBQUMsRUFBZTtBQUN4Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QixxQkFBcUIsU0FBUztBQUM5Qjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwiZmlsZSI6IjE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB3cmFwQW5zaTE2ID0gKGZuLCBvZmZzZXQpID0+ICguLi5hcmdzKSA9PiB7XG5cdGNvbnN0IGNvZGUgPSBmbiguLi5hcmdzKTtcblx0cmV0dXJuIGBcXHUwMDFCWyR7Y29kZSArIG9mZnNldH1tYDtcbn07XG5cbmNvbnN0IHdyYXBBbnNpMjU2ID0gKGZuLCBvZmZzZXQpID0+ICguLi5hcmdzKSA9PiB7XG5cdGNvbnN0IGNvZGUgPSBmbiguLi5hcmdzKTtcblx0cmV0dXJuIGBcXHUwMDFCWyR7MzggKyBvZmZzZXR9OzU7JHtjb2RlfW1gO1xufTtcblxuY29uc3Qgd3JhcEFuc2kxNm0gPSAoZm4sIG9mZnNldCkgPT4gKC4uLmFyZ3MpID0+IHtcblx0Y29uc3QgcmdiID0gZm4oLi4uYXJncyk7XG5cdHJldHVybiBgXFx1MDAxQlskezM4ICsgb2Zmc2V0fTsyOyR7cmdiWzBdfTske3JnYlsxXX07JHtyZ2JbMl19bWA7XG59O1xuXG5jb25zdCBhbnNpMmFuc2kgPSBuID0+IG47XG5jb25zdCByZ2IycmdiID0gKHIsIGcsIGIpID0+IFtyLCBnLCBiXTtcblxuY29uc3Qgc2V0TGF6eVByb3BlcnR5ID0gKG9iamVjdCwgcHJvcGVydHksIGdldCkgPT4ge1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBwcm9wZXJ0eSwge1xuXHRcdGdldDogKCkgPT4ge1xuXHRcdFx0Y29uc3QgdmFsdWUgPSBnZXQoKTtcblxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHtcblx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9LFxuXHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdH0pO1xufTtcblxuLyoqIEB0eXBlIHt0eXBlb2YgaW1wb3J0KCdjb2xvci1jb252ZXJ0Jyl9ICovXG5sZXQgY29sb3JDb252ZXJ0O1xuY29uc3QgbWFrZUR5bmFtaWNTdHlsZXMgPSAod3JhcCwgdGFyZ2V0U3BhY2UsIGlkZW50aXR5LCBpc0JhY2tncm91bmQpID0+IHtcblx0aWYgKGNvbG9yQ29udmVydCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0Y29sb3JDb252ZXJ0ID0gcmVxdWlyZSgnY29sb3ItY29udmVydCcpO1xuXHR9XG5cblx0Y29uc3Qgb2Zmc2V0ID0gaXNCYWNrZ3JvdW5kID8gMTAgOiAwO1xuXHRjb25zdCBzdHlsZXMgPSB7fTtcblxuXHRmb3IgKGNvbnN0IFtzb3VyY2VTcGFjZSwgc3VpdGVdIG9mIE9iamVjdC5lbnRyaWVzKGNvbG9yQ29udmVydCkpIHtcblx0XHRjb25zdCBuYW1lID0gc291cmNlU3BhY2UgPT09ICdhbnNpMTYnID8gJ2Fuc2knIDogc291cmNlU3BhY2U7XG5cdFx0aWYgKHNvdXJjZVNwYWNlID09PSB0YXJnZXRTcGFjZSkge1xuXHRcdFx0c3R5bGVzW25hbWVdID0gd3JhcChpZGVudGl0eSwgb2Zmc2V0KTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBzdWl0ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdHN0eWxlc1tuYW1lXSA9IHdyYXAoc3VpdGVbdGFyZ2V0U3BhY2VdLCBvZmZzZXQpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBzdHlsZXM7XG59O1xuXG5mdW5jdGlvbiBhc3NlbWJsZVN0eWxlcygpIHtcblx0Y29uc3QgY29kZXMgPSBuZXcgTWFwKCk7XG5cdGNvbnN0IHN0eWxlcyA9IHtcblx0XHRtb2RpZmllcjoge1xuXHRcdFx0cmVzZXQ6IFswLCAwXSxcblx0XHRcdC8vIDIxIGlzbid0IHdpZGVseSBzdXBwb3J0ZWQgYW5kIDIyIGRvZXMgdGhlIHNhbWUgdGhpbmdcblx0XHRcdGJvbGQ6IFsxLCAyMl0sXG5cdFx0XHRkaW06IFsyLCAyMl0sXG5cdFx0XHRpdGFsaWM6IFszLCAyM10sXG5cdFx0XHR1bmRlcmxpbmU6IFs0LCAyNF0sXG5cdFx0XHRpbnZlcnNlOiBbNywgMjddLFxuXHRcdFx0aGlkZGVuOiBbOCwgMjhdLFxuXHRcdFx0c3RyaWtldGhyb3VnaDogWzksIDI5XVxuXHRcdH0sXG5cdFx0Y29sb3I6IHtcblx0XHRcdGJsYWNrOiBbMzAsIDM5XSxcblx0XHRcdHJlZDogWzMxLCAzOV0sXG5cdFx0XHRncmVlbjogWzMyLCAzOV0sXG5cdFx0XHR5ZWxsb3c6IFszMywgMzldLFxuXHRcdFx0Ymx1ZTogWzM0LCAzOV0sXG5cdFx0XHRtYWdlbnRhOiBbMzUsIDM5XSxcblx0XHRcdGN5YW46IFszNiwgMzldLFxuXHRcdFx0d2hpdGU6IFszNywgMzldLFxuXG5cdFx0XHQvLyBCcmlnaHQgY29sb3Jcblx0XHRcdGJsYWNrQnJpZ2h0OiBbOTAsIDM5XSxcblx0XHRcdHJlZEJyaWdodDogWzkxLCAzOV0sXG5cdFx0XHRncmVlbkJyaWdodDogWzkyLCAzOV0sXG5cdFx0XHR5ZWxsb3dCcmlnaHQ6IFs5MywgMzldLFxuXHRcdFx0Ymx1ZUJyaWdodDogWzk0LCAzOV0sXG5cdFx0XHRtYWdlbnRhQnJpZ2h0OiBbOTUsIDM5XSxcblx0XHRcdGN5YW5CcmlnaHQ6IFs5NiwgMzldLFxuXHRcdFx0d2hpdGVCcmlnaHQ6IFs5NywgMzldXG5cdFx0fSxcblx0XHRiZ0NvbG9yOiB7XG5cdFx0XHRiZ0JsYWNrOiBbNDAsIDQ5XSxcblx0XHRcdGJnUmVkOiBbNDEsIDQ5XSxcblx0XHRcdGJnR3JlZW46IFs0MiwgNDldLFxuXHRcdFx0YmdZZWxsb3c6IFs0MywgNDldLFxuXHRcdFx0YmdCbHVlOiBbNDQsIDQ5XSxcblx0XHRcdGJnTWFnZW50YTogWzQ1LCA0OV0sXG5cdFx0XHRiZ0N5YW46IFs0NiwgNDldLFxuXHRcdFx0YmdXaGl0ZTogWzQ3LCA0OV0sXG5cblx0XHRcdC8vIEJyaWdodCBjb2xvclxuXHRcdFx0YmdCbGFja0JyaWdodDogWzEwMCwgNDldLFxuXHRcdFx0YmdSZWRCcmlnaHQ6IFsxMDEsIDQ5XSxcblx0XHRcdGJnR3JlZW5CcmlnaHQ6IFsxMDIsIDQ5XSxcblx0XHRcdGJnWWVsbG93QnJpZ2h0OiBbMTAzLCA0OV0sXG5cdFx0XHRiZ0JsdWVCcmlnaHQ6IFsxMDQsIDQ5XSxcblx0XHRcdGJnTWFnZW50YUJyaWdodDogWzEwNSwgNDldLFxuXHRcdFx0YmdDeWFuQnJpZ2h0OiBbMTA2LCA0OV0sXG5cdFx0XHRiZ1doaXRlQnJpZ2h0OiBbMTA3LCA0OV1cblx0XHR9XG5cdH07XG5cblx0Ly8gQWxpYXMgYnJpZ2h0IGJsYWNrIGFzIGdyYXkgKGFuZCBncmV5KVxuXHRzdHlsZXMuY29sb3IuZ3JheSA9IHN0eWxlcy5jb2xvci5ibGFja0JyaWdodDtcblx0c3R5bGVzLmJnQ29sb3IuYmdHcmF5ID0gc3R5bGVzLmJnQ29sb3IuYmdCbGFja0JyaWdodDtcblx0c3R5bGVzLmNvbG9yLmdyZXkgPSBzdHlsZXMuY29sb3IuYmxhY2tCcmlnaHQ7XG5cdHN0eWxlcy5iZ0NvbG9yLmJnR3JleSA9IHN0eWxlcy5iZ0NvbG9yLmJnQmxhY2tCcmlnaHQ7XG5cblx0Zm9yIChjb25zdCBbZ3JvdXBOYW1lLCBncm91cF0gb2YgT2JqZWN0LmVudHJpZXMoc3R5bGVzKSkge1xuXHRcdGZvciAoY29uc3QgW3N0eWxlTmFtZSwgc3R5bGVdIG9mIE9iamVjdC5lbnRyaWVzKGdyb3VwKSkge1xuXHRcdFx0c3R5bGVzW3N0eWxlTmFtZV0gPSB7XG5cdFx0XHRcdG9wZW46IGBcXHUwMDFCWyR7c3R5bGVbMF19bWAsXG5cdFx0XHRcdGNsb3NlOiBgXFx1MDAxQlske3N0eWxlWzFdfW1gXG5cdFx0XHR9O1xuXG5cdFx0XHRncm91cFtzdHlsZU5hbWVdID0gc3R5bGVzW3N0eWxlTmFtZV07XG5cblx0XHRcdGNvZGVzLnNldChzdHlsZVswXSwgc3R5bGVbMV0pO1xuXHRcdH1cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdHlsZXMsIGdyb3VwTmFtZSwge1xuXHRcdFx0dmFsdWU6IGdyb3VwLFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2Vcblx0XHR9KTtcblx0fVxuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzdHlsZXMsICdjb2RlcycsIHtcblx0XHR2YWx1ZTogY29kZXMsXG5cdFx0ZW51bWVyYWJsZTogZmFsc2Vcblx0fSk7XG5cblx0c3R5bGVzLmNvbG9yLmNsb3NlID0gJ1xcdTAwMUJbMzltJztcblx0c3R5bGVzLmJnQ29sb3IuY2xvc2UgPSAnXFx1MDAxQls0OW0nO1xuXG5cdHNldExhenlQcm9wZXJ0eShzdHlsZXMuY29sb3IsICdhbnNpJywgKCkgPT4gbWFrZUR5bmFtaWNTdHlsZXMod3JhcEFuc2kxNiwgJ2Fuc2kxNicsIGFuc2kyYW5zaSwgZmFsc2UpKTtcblx0c2V0TGF6eVByb3BlcnR5KHN0eWxlcy5jb2xvciwgJ2Fuc2kyNTYnLCAoKSA9PiBtYWtlRHluYW1pY1N0eWxlcyh3cmFwQW5zaTI1NiwgJ2Fuc2kyNTYnLCBhbnNpMmFuc2ksIGZhbHNlKSk7XG5cdHNldExhenlQcm9wZXJ0eShzdHlsZXMuY29sb3IsICdhbnNpMTZtJywgKCkgPT4gbWFrZUR5bmFtaWNTdHlsZXMod3JhcEFuc2kxNm0sICdyZ2InLCByZ2IycmdiLCBmYWxzZSkpO1xuXHRzZXRMYXp5UHJvcGVydHkoc3R5bGVzLmJnQ29sb3IsICdhbnNpJywgKCkgPT4gbWFrZUR5bmFtaWNTdHlsZXMod3JhcEFuc2kxNiwgJ2Fuc2kxNicsIGFuc2kyYW5zaSwgdHJ1ZSkpO1xuXHRzZXRMYXp5UHJvcGVydHkoc3R5bGVzLmJnQ29sb3IsICdhbnNpMjU2JywgKCkgPT4gbWFrZUR5bmFtaWNTdHlsZXMod3JhcEFuc2kyNTYsICdhbnNpMjU2JywgYW5zaTJhbnNpLCB0cnVlKSk7XG5cdHNldExhenlQcm9wZXJ0eShzdHlsZXMuYmdDb2xvciwgJ2Fuc2kxNm0nLCAoKSA9PiBtYWtlRHluYW1pY1N0eWxlcyh3cmFwQW5zaTE2bSwgJ3JnYicsIHJnYjJyZ2IsIHRydWUpKTtcblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG4vLyBNYWtlIHRoZSBleHBvcnQgaW1tdXRhYmxlXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCAnZXhwb3J0cycsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0Z2V0OiBhc3NlbWJsZVN0eWxlc1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///16\n")},function(module,exports,__webpack_require__){eval("/* MIT license */\n/* eslint-disable no-mixed-operators */\nconst cssKeywords = __webpack_require__(29);\n\n// NOTE: conversions should only return primitive values (i.e. arrays, or\n//       values that give correct `typeof` results).\n//       do not use box values types (i.e. Number(), String(), etc.)\n\nconst reverseKeywords = {};\nfor (const key of Object.keys(cssKeywords)) {\n\treverseKeywords[cssKeywords[key]] = key;\n}\n\nconst convert = {\n\trgb: {channels: 3, labels: 'rgb'},\n\thsl: {channels: 3, labels: 'hsl'},\n\thsv: {channels: 3, labels: 'hsv'},\n\thwb: {channels: 3, labels: 'hwb'},\n\tcmyk: {channels: 4, labels: 'cmyk'},\n\txyz: {channels: 3, labels: 'xyz'},\n\tlab: {channels: 3, labels: 'lab'},\n\tlch: {channels: 3, labels: 'lch'},\n\thex: {channels: 1, labels: ['hex']},\n\tkeyword: {channels: 1, labels: ['keyword']},\n\tansi16: {channels: 1, labels: ['ansi16']},\n\tansi256: {channels: 1, labels: ['ansi256']},\n\thcg: {channels: 3, labels: ['h', 'c', 'g']},\n\tapple: {channels: 3, labels: ['r16', 'g16', 'b16']},\n\tgray: {channels: 1, labels: ['gray']}\n};\n\nmodule.exports = convert;\n\n// Hide .channels and .labels properties\nfor (const model of Object.keys(convert)) {\n\tif (!('channels' in convert[model])) {\n\t\tthrow new Error('missing channels property: ' + model);\n\t}\n\n\tif (!('labels' in convert[model])) {\n\t\tthrow new Error('missing channel labels property: ' + model);\n\t}\n\n\tif (convert[model].labels.length !== convert[model].channels) {\n\t\tthrow new Error('channel and label counts mismatch: ' + model);\n\t}\n\n\tconst {channels, labels} = convert[model];\n\tdelete convert[model].channels;\n\tdelete convert[model].labels;\n\tObject.defineProperty(convert[model], 'channels', {value: channels});\n\tObject.defineProperty(convert[model], 'labels', {value: labels});\n}\n\nconvert.rgb.hsl = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst min = Math.min(r, g, b);\n\tconst max = Math.max(r, g, b);\n\tconst delta = max - min;\n\tlet h;\n\tlet s;\n\n\tif (max === min) {\n\t\th = 0;\n\t} else if (r === max) {\n\t\th = (g - b) / delta;\n\t} else if (g === max) {\n\t\th = 2 + (b - r) / delta;\n\t} else if (b === max) {\n\t\th = 4 + (r - g) / delta;\n\t}\n\n\th = Math.min(h * 60, 360);\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst l = (min + max) / 2;\n\n\tif (max === min) {\n\t\ts = 0;\n\t} else if (l <= 0.5) {\n\t\ts = delta / (max + min);\n\t} else {\n\t\ts = delta / (2 - max - min);\n\t}\n\n\treturn [h, s * 100, l * 100];\n};\n\nconvert.rgb.hsv = function (rgb) {\n\tlet rdif;\n\tlet gdif;\n\tlet bdif;\n\tlet h;\n\tlet s;\n\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst v = Math.max(r, g, b);\n\tconst diff = v - Math.min(r, g, b);\n\tconst diffc = function (c) {\n\t\treturn (v - c) / 6 / diff + 1 / 2;\n\t};\n\n\tif (diff === 0) {\n\t\th = 0;\n\t\ts = 0;\n\t} else {\n\t\ts = diff / v;\n\t\trdif = diffc(r);\n\t\tgdif = diffc(g);\n\t\tbdif = diffc(b);\n\n\t\tif (r === v) {\n\t\t\th = bdif - gdif;\n\t\t} else if (g === v) {\n\t\t\th = (1 / 3) + rdif - bdif;\n\t\t} else if (b === v) {\n\t\t\th = (2 / 3) + gdif - rdif;\n\t\t}\n\n\t\tif (h < 0) {\n\t\t\th += 1;\n\t\t} else if (h > 1) {\n\t\t\th -= 1;\n\t\t}\n\t}\n\n\treturn [\n\t\th * 360,\n\t\ts * 100,\n\t\tv * 100\n\t];\n};\n\nconvert.rgb.hwb = function (rgb) {\n\tconst r = rgb[0];\n\tconst g = rgb[1];\n\tlet b = rgb[2];\n\tconst h = convert.rgb.hsl(rgb)[0];\n\tconst w = 1 / 255 * Math.min(r, Math.min(g, b));\n\n\tb = 1 - 1 / 255 * Math.max(r, Math.max(g, b));\n\n\treturn [h, w * 100, b * 100];\n};\n\nconvert.rgb.cmyk = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\n\tconst k = Math.min(1 - r, 1 - g, 1 - b);\n\tconst c = (1 - r - k) / (1 - k) || 0;\n\tconst m = (1 - g - k) / (1 - k) || 0;\n\tconst y = (1 - b - k) / (1 - k) || 0;\n\n\treturn [c * 100, m * 100, y * 100, k * 100];\n};\n\nfunction comparativeDistance(x, y) {\n\t/*\n\t\tSee https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance\n\t*/\n\treturn (\n\t\t((x[0] - y[0]) ** 2) +\n\t\t((x[1] - y[1]) ** 2) +\n\t\t((x[2] - y[2]) ** 2)\n\t);\n}\n\nconvert.rgb.keyword = function (rgb) {\n\tconst reversed = reverseKeywords[rgb];\n\tif (reversed) {\n\t\treturn reversed;\n\t}\n\n\tlet currentClosestDistance = Infinity;\n\tlet currentClosestKeyword;\n\n\tfor (const keyword of Object.keys(cssKeywords)) {\n\t\tconst value = cssKeywords[keyword];\n\n\t\t// Compute comparative distance\n\t\tconst distance = comparativeDistance(rgb, value);\n\n\t\t// Check if its less, if so set as closest\n\t\tif (distance < currentClosestDistance) {\n\t\t\tcurrentClosestDistance = distance;\n\t\t\tcurrentClosestKeyword = keyword;\n\t\t}\n\t}\n\n\treturn currentClosestKeyword;\n};\n\nconvert.keyword.rgb = function (keyword) {\n\treturn cssKeywords[keyword];\n};\n\nconvert.rgb.xyz = function (rgb) {\n\tlet r = rgb[0] / 255;\n\tlet g = rgb[1] / 255;\n\tlet b = rgb[2] / 255;\n\n\t// Assume sRGB\n\tr = r > 0.04045 ? (((r + 0.055) / 1.055) ** 2.4) : (r / 12.92);\n\tg = g > 0.04045 ? (((g + 0.055) / 1.055) ** 2.4) : (g / 12.92);\n\tb = b > 0.04045 ? (((b + 0.055) / 1.055) ** 2.4) : (b / 12.92);\n\n\tconst x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);\n\tconst y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);\n\tconst z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);\n\n\treturn [x * 100, y * 100, z * 100];\n};\n\nconvert.rgb.lab = function (rgb) {\n\tconst xyz = convert.rgb.xyz(rgb);\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.hsl.rgb = function (hsl) {\n\tconst h = hsl[0] / 360;\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\tlet t2;\n\tlet t3;\n\tlet val;\n\n\tif (s === 0) {\n\t\tval = l * 255;\n\t\treturn [val, val, val];\n\t}\n\n\tif (l < 0.5) {\n\t\tt2 = l * (1 + s);\n\t} else {\n\t\tt2 = l + s - l * s;\n\t}\n\n\tconst t1 = 2 * l - t2;\n\n\tconst rgb = [0, 0, 0];\n\tfor (let i = 0; i < 3; i++) {\n\t\tt3 = h + 1 / 3 * -(i - 1);\n\t\tif (t3 < 0) {\n\t\t\tt3++;\n\t\t}\n\n\t\tif (t3 > 1) {\n\t\t\tt3--;\n\t\t}\n\n\t\tif (6 * t3 < 1) {\n\t\t\tval = t1 + (t2 - t1) * 6 * t3;\n\t\t} else if (2 * t3 < 1) {\n\t\t\tval = t2;\n\t\t} else if (3 * t3 < 2) {\n\t\t\tval = t1 + (t2 - t1) * (2 / 3 - t3) * 6;\n\t\t} else {\n\t\t\tval = t1;\n\t\t}\n\n\t\trgb[i] = val * 255;\n\t}\n\n\treturn rgb;\n};\n\nconvert.hsl.hsv = function (hsl) {\n\tconst h = hsl[0];\n\tlet s = hsl[1] / 100;\n\tlet l = hsl[2] / 100;\n\tlet smin = s;\n\tconst lmin = Math.max(l, 0.01);\n\n\tl *= 2;\n\ts *= (l <= 1) ? l : 2 - l;\n\tsmin *= lmin <= 1 ? lmin : 2 - lmin;\n\tconst v = (l + s) / 2;\n\tconst sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);\n\n\treturn [h, sv * 100, v * 100];\n};\n\nconvert.hsv.rgb = function (hsv) {\n\tconst h = hsv[0] / 60;\n\tconst s = hsv[1] / 100;\n\tlet v = hsv[2] / 100;\n\tconst hi = Math.floor(h) % 6;\n\n\tconst f = h - Math.floor(h);\n\tconst p = 255 * v * (1 - s);\n\tconst q = 255 * v * (1 - (s * f));\n\tconst t = 255 * v * (1 - (s * (1 - f)));\n\tv *= 255;\n\n\tswitch (hi) {\n\t\tcase 0:\n\t\t\treturn [v, t, p];\n\t\tcase 1:\n\t\t\treturn [q, v, p];\n\t\tcase 2:\n\t\t\treturn [p, v, t];\n\t\tcase 3:\n\t\t\treturn [p, q, v];\n\t\tcase 4:\n\t\t\treturn [t, p, v];\n\t\tcase 5:\n\t\t\treturn [v, p, q];\n\t}\n};\n\nconvert.hsv.hsl = function (hsv) {\n\tconst h = hsv[0];\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\tconst vmin = Math.max(v, 0.01);\n\tlet sl;\n\tlet l;\n\n\tl = (2 - s) * v;\n\tconst lmin = (2 - s) * vmin;\n\tsl = s * vmin;\n\tsl /= (lmin <= 1) ? lmin : 2 - lmin;\n\tsl = sl || 0;\n\tl /= 2;\n\n\treturn [h, sl * 100, l * 100];\n};\n\n// http://dev.w3.org/csswg/css-color/#hwb-to-rgb\nconvert.hwb.rgb = function (hwb) {\n\tconst h = hwb[0] / 360;\n\tlet wh = hwb[1] / 100;\n\tlet bl = hwb[2] / 100;\n\tconst ratio = wh + bl;\n\tlet f;\n\n\t// Wh + bl cant be > 1\n\tif (ratio > 1) {\n\t\twh /= ratio;\n\t\tbl /= ratio;\n\t}\n\n\tconst i = Math.floor(6 * h);\n\tconst v = 1 - bl;\n\tf = 6 * h - i;\n\n\tif ((i & 0x01) !== 0) {\n\t\tf = 1 - f;\n\t}\n\n\tconst n = wh + f * (v - wh); // Linear interpolation\n\n\tlet r;\n\tlet g;\n\tlet b;\n\t/* eslint-disable max-statements-per-line,no-multi-spaces */\n\tswitch (i) {\n\t\tdefault:\n\t\tcase 6:\n\t\tcase 0: r = v;  g = n;  b = wh; break;\n\t\tcase 1: r = n;  g = v;  b = wh; break;\n\t\tcase 2: r = wh; g = v;  b = n; break;\n\t\tcase 3: r = wh; g = n;  b = v; break;\n\t\tcase 4: r = n;  g = wh; b = v; break;\n\t\tcase 5: r = v;  g = wh; b = n; break;\n\t}\n\t/* eslint-enable max-statements-per-line,no-multi-spaces */\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.cmyk.rgb = function (cmyk) {\n\tconst c = cmyk[0] / 100;\n\tconst m = cmyk[1] / 100;\n\tconst y = cmyk[2] / 100;\n\tconst k = cmyk[3] / 100;\n\n\tconst r = 1 - Math.min(1, c * (1 - k) + k);\n\tconst g = 1 - Math.min(1, m * (1 - k) + k);\n\tconst b = 1 - Math.min(1, y * (1 - k) + k);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.rgb = function (xyz) {\n\tconst x = xyz[0] / 100;\n\tconst y = xyz[1] / 100;\n\tconst z = xyz[2] / 100;\n\tlet r;\n\tlet g;\n\tlet b;\n\n\tr = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n\tg = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n\tb = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n\t// Assume sRGB\n\tr = r > 0.0031308\n\t\t? ((1.055 * (r ** (1.0 / 2.4))) - 0.055)\n\t\t: r * 12.92;\n\n\tg = g > 0.0031308\n\t\t? ((1.055 * (g ** (1.0 / 2.4))) - 0.055)\n\t\t: g * 12.92;\n\n\tb = b > 0.0031308\n\t\t? ((1.055 * (b ** (1.0 / 2.4))) - 0.055)\n\t\t: b * 12.92;\n\n\tr = Math.min(Math.max(0, r), 1);\n\tg = Math.min(Math.max(0, g), 1);\n\tb = Math.min(Math.max(0, b), 1);\n\n\treturn [r * 255, g * 255, b * 255];\n};\n\nconvert.xyz.lab = function (xyz) {\n\tlet x = xyz[0];\n\tlet y = xyz[1];\n\tlet z = xyz[2];\n\n\tx /= 95.047;\n\ty /= 100;\n\tz /= 108.883;\n\n\tx = x > 0.008856 ? (x ** (1 / 3)) : (7.787 * x) + (16 / 116);\n\ty = y > 0.008856 ? (y ** (1 / 3)) : (7.787 * y) + (16 / 116);\n\tz = z > 0.008856 ? (z ** (1 / 3)) : (7.787 * z) + (16 / 116);\n\n\tconst l = (116 * y) - 16;\n\tconst a = 500 * (x - y);\n\tconst b = 200 * (y - z);\n\n\treturn [l, a, b];\n};\n\nconvert.lab.xyz = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet x;\n\tlet y;\n\tlet z;\n\n\ty = (l + 16) / 116;\n\tx = a / 500 + y;\n\tz = y - b / 200;\n\n\tconst y2 = y ** 3;\n\tconst x2 = x ** 3;\n\tconst z2 = z ** 3;\n\ty = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;\n\tx = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;\n\tz = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;\n\n\tx *= 95.047;\n\ty *= 100;\n\tz *= 108.883;\n\n\treturn [x, y, z];\n};\n\nconvert.lab.lch = function (lab) {\n\tconst l = lab[0];\n\tconst a = lab[1];\n\tconst b = lab[2];\n\tlet h;\n\n\tconst hr = Math.atan2(b, a);\n\th = hr * 360 / 2 / Math.PI;\n\n\tif (h < 0) {\n\t\th += 360;\n\t}\n\n\tconst c = Math.sqrt(a * a + b * b);\n\n\treturn [l, c, h];\n};\n\nconvert.lch.lab = function (lch) {\n\tconst l = lch[0];\n\tconst c = lch[1];\n\tconst h = lch[2];\n\n\tconst hr = h / 360 * 2 * Math.PI;\n\tconst a = c * Math.cos(hr);\n\tconst b = c * Math.sin(hr);\n\n\treturn [l, a, b];\n};\n\nconvert.rgb.ansi16 = function (args, saturation = null) {\n\tconst [r, g, b] = args;\n\tlet value = saturation === null ? convert.rgb.hsv(args)[2] : saturation; // Hsv -> ansi16 optimization\n\n\tvalue = Math.round(value / 50);\n\n\tif (value === 0) {\n\t\treturn 30;\n\t}\n\n\tlet ansi = 30\n\t\t+ ((Math.round(b / 255) << 2)\n\t\t| (Math.round(g / 255) << 1)\n\t\t| Math.round(r / 255));\n\n\tif (value === 2) {\n\t\tansi += 60;\n\t}\n\n\treturn ansi;\n};\n\nconvert.hsv.ansi16 = function (args) {\n\t// Optimization here; we already know the value and don't need to get\n\t// it converted for us.\n\treturn convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);\n};\n\nconvert.rgb.ansi256 = function (args) {\n\tconst r = args[0];\n\tconst g = args[1];\n\tconst b = args[2];\n\n\t// We use the extended greyscale palette here, with the exception of\n\t// black and white. normal palette only has 4 greyscale shades.\n\tif (r === g && g === b) {\n\t\tif (r < 8) {\n\t\t\treturn 16;\n\t\t}\n\n\t\tif (r > 248) {\n\t\t\treturn 231;\n\t\t}\n\n\t\treturn Math.round(((r - 8) / 247) * 24) + 232;\n\t}\n\n\tconst ansi = 16\n\t\t+ (36 * Math.round(r / 255 * 5))\n\t\t+ (6 * Math.round(g / 255 * 5))\n\t\t+ Math.round(b / 255 * 5);\n\n\treturn ansi;\n};\n\nconvert.ansi16.rgb = function (args) {\n\tlet color = args % 10;\n\n\t// Handle greyscale\n\tif (color === 0 || color === 7) {\n\t\tif (args > 50) {\n\t\t\tcolor += 3.5;\n\t\t}\n\n\t\tcolor = color / 10.5 * 255;\n\n\t\treturn [color, color, color];\n\t}\n\n\tconst mult = (~~(args > 50) + 1) * 0.5;\n\tconst r = ((color & 1) * mult) * 255;\n\tconst g = (((color >> 1) & 1) * mult) * 255;\n\tconst b = (((color >> 2) & 1) * mult) * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.ansi256.rgb = function (args) {\n\t// Handle greyscale\n\tif (args >= 232) {\n\t\tconst c = (args - 232) * 10 + 8;\n\t\treturn [c, c, c];\n\t}\n\n\targs -= 16;\n\n\tlet rem;\n\tconst r = Math.floor(args / 36) / 5 * 255;\n\tconst g = Math.floor((rem = args % 36) / 6) / 5 * 255;\n\tconst b = (rem % 6) / 5 * 255;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hex = function (args) {\n\tconst integer = ((Math.round(args[0]) & 0xFF) << 16)\n\t\t+ ((Math.round(args[1]) & 0xFF) << 8)\n\t\t+ (Math.round(args[2]) & 0xFF);\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.hex.rgb = function (args) {\n\tconst match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);\n\tif (!match) {\n\t\treturn [0, 0, 0];\n\t}\n\n\tlet colorString = match[0];\n\n\tif (match[0].length === 3) {\n\t\tcolorString = colorString.split('').map(char => {\n\t\t\treturn char + char;\n\t\t}).join('');\n\t}\n\n\tconst integer = parseInt(colorString, 16);\n\tconst r = (integer >> 16) & 0xFF;\n\tconst g = (integer >> 8) & 0xFF;\n\tconst b = integer & 0xFF;\n\n\treturn [r, g, b];\n};\n\nconvert.rgb.hcg = function (rgb) {\n\tconst r = rgb[0] / 255;\n\tconst g = rgb[1] / 255;\n\tconst b = rgb[2] / 255;\n\tconst max = Math.max(Math.max(r, g), b);\n\tconst min = Math.min(Math.min(r, g), b);\n\tconst chroma = (max - min);\n\tlet grayscale;\n\tlet hue;\n\n\tif (chroma < 1) {\n\t\tgrayscale = min / (1 - chroma);\n\t} else {\n\t\tgrayscale = 0;\n\t}\n\n\tif (chroma <= 0) {\n\t\thue = 0;\n\t} else\n\tif (max === r) {\n\t\thue = ((g - b) / chroma) % 6;\n\t} else\n\tif (max === g) {\n\t\thue = 2 + (b - r) / chroma;\n\t} else {\n\t\thue = 4 + (r - g) / chroma;\n\t}\n\n\thue /= 6;\n\thue %= 1;\n\n\treturn [hue * 360, chroma * 100, grayscale * 100];\n};\n\nconvert.hsl.hcg = function (hsl) {\n\tconst s = hsl[1] / 100;\n\tconst l = hsl[2] / 100;\n\n\tconst c = l < 0.5 ? (2.0 * s * l) : (2.0 * s * (1.0 - l));\n\n\tlet f = 0;\n\tif (c < 1.0) {\n\t\tf = (l - 0.5 * c) / (1.0 - c);\n\t}\n\n\treturn [hsl[0], c * 100, f * 100];\n};\n\nconvert.hsv.hcg = function (hsv) {\n\tconst s = hsv[1] / 100;\n\tconst v = hsv[2] / 100;\n\n\tconst c = s * v;\n\tlet f = 0;\n\n\tif (c < 1.0) {\n\t\tf = (v - c) / (1 - c);\n\t}\n\n\treturn [hsv[0], c * 100, f * 100];\n};\n\nconvert.hcg.rgb = function (hcg) {\n\tconst h = hcg[0] / 360;\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tif (c === 0.0) {\n\t\treturn [g * 255, g * 255, g * 255];\n\t}\n\n\tconst pure = [0, 0, 0];\n\tconst hi = (h % 1) * 6;\n\tconst v = hi % 1;\n\tconst w = 1 - v;\n\tlet mg = 0;\n\n\t/* eslint-disable max-statements-per-line */\n\tswitch (Math.floor(hi)) {\n\t\tcase 0:\n\t\t\tpure[0] = 1; pure[1] = v; pure[2] = 0; break;\n\t\tcase 1:\n\t\t\tpure[0] = w; pure[1] = 1; pure[2] = 0; break;\n\t\tcase 2:\n\t\t\tpure[0] = 0; pure[1] = 1; pure[2] = v; break;\n\t\tcase 3:\n\t\t\tpure[0] = 0; pure[1] = w; pure[2] = 1; break;\n\t\tcase 4:\n\t\t\tpure[0] = v; pure[1] = 0; pure[2] = 1; break;\n\t\tdefault:\n\t\t\tpure[0] = 1; pure[1] = 0; pure[2] = w;\n\t}\n\t/* eslint-enable max-statements-per-line */\n\n\tmg = (1.0 - c) * g;\n\n\treturn [\n\t\t(c * pure[0] + mg) * 255,\n\t\t(c * pure[1] + mg) * 255,\n\t\t(c * pure[2] + mg) * 255\n\t];\n};\n\nconvert.hcg.hsv = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst v = c + g * (1.0 - c);\n\tlet f = 0;\n\n\tif (v > 0.0) {\n\t\tf = c / v;\n\t}\n\n\treturn [hcg[0], f * 100, v * 100];\n};\n\nconvert.hcg.hsl = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\n\tconst l = g * (1.0 - c) + 0.5 * c;\n\tlet s = 0;\n\n\tif (l > 0.0 && l < 0.5) {\n\t\ts = c / (2 * l);\n\t} else\n\tif (l >= 0.5 && l < 1.0) {\n\t\ts = c / (2 * (1 - l));\n\t}\n\n\treturn [hcg[0], s * 100, l * 100];\n};\n\nconvert.hcg.hwb = function (hcg) {\n\tconst c = hcg[1] / 100;\n\tconst g = hcg[2] / 100;\n\tconst v = c + g * (1.0 - c);\n\treturn [hcg[0], (v - c) * 100, (1 - v) * 100];\n};\n\nconvert.hwb.hcg = function (hwb) {\n\tconst w = hwb[1] / 100;\n\tconst b = hwb[2] / 100;\n\tconst v = 1 - b;\n\tconst c = v - w;\n\tlet g = 0;\n\n\tif (c < 1) {\n\t\tg = (v - c) / (1 - c);\n\t}\n\n\treturn [hwb[0], c * 100, g * 100];\n};\n\nconvert.apple.rgb = function (apple) {\n\treturn [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];\n};\n\nconvert.rgb.apple = function (rgb) {\n\treturn [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];\n};\n\nconvert.gray.rgb = function (args) {\n\treturn [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];\n};\n\nconvert.gray.hsl = function (args) {\n\treturn [0, 0, args[0]];\n};\n\nconvert.gray.hsv = convert.gray.hsl;\n\nconvert.gray.hwb = function (gray) {\n\treturn [0, 100, gray[0]];\n};\n\nconvert.gray.cmyk = function (gray) {\n\treturn [0, 0, 0, gray[0]];\n};\n\nconvert.gray.lab = function (gray) {\n\treturn [gray[0], 0, 0];\n};\n\nconvert.gray.hex = function (gray) {\n\tconst val = Math.round(gray[0] / 100 * 255) & 0xFF;\n\tconst integer = (val << 16) + (val << 8) + val;\n\n\tconst string = integer.toString(16).toUpperCase();\n\treturn '000000'.substring(string.length) + string;\n};\n\nconvert.rgb.gray = function (rgb) {\n\tconst val = (rgb[0] + rgb[1] + rgb[2]) / 3;\n\treturn [val / 255 * 100];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29sb3ItY29udmVydC9jb252ZXJzaW9ucy5qcz9iNzUzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQU8sQ0FBQyxFQUFZOztBQUV4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLDJCQUEyQjtBQUNsQyxPQUFPLDJCQUEyQjtBQUNsQyxPQUFPLDJCQUEyQjtBQUNsQyxPQUFPLDJCQUEyQjtBQUNsQyxRQUFRLDRCQUE0QjtBQUNwQyxPQUFPLDJCQUEyQjtBQUNsQyxPQUFPLDJCQUEyQjtBQUNsQyxPQUFPLDJCQUEyQjtBQUNsQyxPQUFPLDZCQUE2QjtBQUNwQyxXQUFXLGlDQUFpQztBQUM1QyxVQUFVLGdDQUFnQztBQUMxQyxXQUFXLGlDQUFpQztBQUM1QyxPQUFPLHFDQUFxQztBQUM1QyxTQUFTLDJDQUEyQztBQUNwRCxRQUFRO0FBQ1I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFFBQVEsaUJBQWlCO0FBQ3pCO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFLGtEQUFrRCxjQUFjO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRLFNBQVM7QUFDakMsZ0JBQWdCLFFBQVEsU0FBUztBQUNqQyxpQkFBaUIsT0FBTyxRQUFRO0FBQ2hDLGlCQUFpQixPQUFPLFFBQVE7QUFDaEMsZ0JBQWdCLFNBQVMsT0FBTztBQUNoQyxnQkFBZ0IsU0FBUyxPQUFPO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlFQUF5RTs7QUFFekU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxFQUFFLFVBQVUsRUFBRTtBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGFBQWEsYUFBYTtBQUN6QztBQUNBLGVBQWUsYUFBYSxhQUFhO0FBQ3pDO0FBQ0EsZUFBZSxhQUFhLGFBQWE7QUFDekM7QUFDQSxlQUFlLGFBQWEsYUFBYTtBQUN6QztBQUNBLGVBQWUsYUFBYSxhQUFhO0FBQ3pDO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIE1JVCBsaWNlbnNlICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1taXhlZC1vcGVyYXRvcnMgKi9cbmNvbnN0IGNzc0tleXdvcmRzID0gcmVxdWlyZSgnY29sb3ItbmFtZScpO1xuXG4vLyBOT1RFOiBjb252ZXJzaW9ucyBzaG91bGQgb25seSByZXR1cm4gcHJpbWl0aXZlIHZhbHVlcyAoaS5lLiBhcnJheXMsIG9yXG4vLyAgICAgICB2YWx1ZXMgdGhhdCBnaXZlIGNvcnJlY3QgYHR5cGVvZmAgcmVzdWx0cykuXG4vLyAgICAgICBkbyBub3QgdXNlIGJveCB2YWx1ZXMgdHlwZXMgKGkuZS4gTnVtYmVyKCksIFN0cmluZygpLCBldGMuKVxuXG5jb25zdCByZXZlcnNlS2V5d29yZHMgPSB7fTtcbmZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNzc0tleXdvcmRzKSkge1xuXHRyZXZlcnNlS2V5d29yZHNbY3NzS2V5d29yZHNba2V5XV0gPSBrZXk7XG59XG5cbmNvbnN0IGNvbnZlcnQgPSB7XG5cdHJnYjoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdyZ2InfSxcblx0aHNsOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2hzbCd9LFxuXHRoc3Y6IHtjaGFubmVsczogMywgbGFiZWxzOiAnaHN2J30sXG5cdGh3Yjoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICdod2InfSxcblx0Y215azoge2NoYW5uZWxzOiA0LCBsYWJlbHM6ICdjbXlrJ30sXG5cdHh5ejoge2NoYW5uZWxzOiAzLCBsYWJlbHM6ICd4eXonfSxcblx0bGFiOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogJ2xhYid9LFxuXHRsY2g6IHtjaGFubmVsczogMywgbGFiZWxzOiAnbGNoJ30sXG5cdGhleDoge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsnaGV4J119LFxuXHRrZXl3b3JkOiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydrZXl3b3JkJ119LFxuXHRhbnNpMTY6IHtjaGFubmVsczogMSwgbGFiZWxzOiBbJ2Fuc2kxNiddfSxcblx0YW5zaTI1Njoge2NoYW5uZWxzOiAxLCBsYWJlbHM6IFsnYW5zaTI1NiddfSxcblx0aGNnOiB7Y2hhbm5lbHM6IDMsIGxhYmVsczogWydoJywgJ2MnLCAnZyddfSxcblx0YXBwbGU6IHtjaGFubmVsczogMywgbGFiZWxzOiBbJ3IxNicsICdnMTYnLCAnYjE2J119LFxuXHRncmF5OiB7Y2hhbm5lbHM6IDEsIGxhYmVsczogWydncmF5J119XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZlcnQ7XG5cbi8vIEhpZGUgLmNoYW5uZWxzIGFuZCAubGFiZWxzIHByb3BlcnRpZXNcbmZvciAoY29uc3QgbW9kZWwgb2YgT2JqZWN0LmtleXMoY29udmVydCkpIHtcblx0aWYgKCEoJ2NoYW5uZWxzJyBpbiBjb252ZXJ0W21vZGVsXSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgY2hhbm5lbHMgcHJvcGVydHk6ICcgKyBtb2RlbCk7XG5cdH1cblxuXHRpZiAoISgnbGFiZWxzJyBpbiBjb252ZXJ0W21vZGVsXSkpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ21pc3NpbmcgY2hhbm5lbCBsYWJlbHMgcHJvcGVydHk6ICcgKyBtb2RlbCk7XG5cdH1cblxuXHRpZiAoY29udmVydFttb2RlbF0ubGFiZWxzLmxlbmd0aCAhPT0gY29udmVydFttb2RlbF0uY2hhbm5lbHMpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ2NoYW5uZWwgYW5kIGxhYmVsIGNvdW50cyBtaXNtYXRjaDogJyArIG1vZGVsKTtcblx0fVxuXG5cdGNvbnN0IHtjaGFubmVscywgbGFiZWxzfSA9IGNvbnZlcnRbbW9kZWxdO1xuXHRkZWxldGUgY29udmVydFttb2RlbF0uY2hhbm5lbHM7XG5cdGRlbGV0ZSBjb252ZXJ0W21vZGVsXS5sYWJlbHM7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb252ZXJ0W21vZGVsXSwgJ2NoYW5uZWxzJywge3ZhbHVlOiBjaGFubmVsc30pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFttb2RlbF0sICdsYWJlbHMnLCB7dmFsdWU6IGxhYmVsc30pO1xufVxuXG5jb252ZXJ0LnJnYi5oc2wgPSBmdW5jdGlvbiAocmdiKSB7XG5cdGNvbnN0IHIgPSByZ2JbMF0gLyAyNTU7XG5cdGNvbnN0IGcgPSByZ2JbMV0gLyAyNTU7XG5cdGNvbnN0IGIgPSByZ2JbMl0gLyAyNTU7XG5cdGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuXHRjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcblx0Y29uc3QgZGVsdGEgPSBtYXggLSBtaW47XG5cdGxldCBoO1xuXHRsZXQgcztcblxuXHRpZiAobWF4ID09PSBtaW4pIHtcblx0XHRoID0gMDtcblx0fSBlbHNlIGlmIChyID09PSBtYXgpIHtcblx0XHRoID0gKGcgLSBiKSAvIGRlbHRhO1xuXHR9IGVsc2UgaWYgKGcgPT09IG1heCkge1xuXHRcdGggPSAyICsgKGIgLSByKSAvIGRlbHRhO1xuXHR9IGVsc2UgaWYgKGIgPT09IG1heCkge1xuXHRcdGggPSA0ICsgKHIgLSBnKSAvIGRlbHRhO1xuXHR9XG5cblx0aCA9IE1hdGgubWluKGggKiA2MCwgMzYwKTtcblxuXHRpZiAoaCA8IDApIHtcblx0XHRoICs9IDM2MDtcblx0fVxuXG5cdGNvbnN0IGwgPSAobWluICsgbWF4KSAvIDI7XG5cblx0aWYgKG1heCA9PT0gbWluKSB7XG5cdFx0cyA9IDA7XG5cdH0gZWxzZSBpZiAobCA8PSAwLjUpIHtcblx0XHRzID0gZGVsdGEgLyAobWF4ICsgbWluKTtcblx0fSBlbHNlIHtcblx0XHRzID0gZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG5cdH1cblxuXHRyZXR1cm4gW2gsIHMgKiAxMDAsIGwgKiAxMDBdO1xufTtcblxuY29udmVydC5yZ2IuaHN2ID0gZnVuY3Rpb24gKHJnYikge1xuXHRsZXQgcmRpZjtcblx0bGV0IGdkaWY7XG5cdGxldCBiZGlmO1xuXHRsZXQgaDtcblx0bGV0IHM7XG5cblx0Y29uc3QgciA9IHJnYlswXSAvIDI1NTtcblx0Y29uc3QgZyA9IHJnYlsxXSAvIDI1NTtcblx0Y29uc3QgYiA9IHJnYlsyXSAvIDI1NTtcblx0Y29uc3QgdiA9IE1hdGgubWF4KHIsIGcsIGIpO1xuXHRjb25zdCBkaWZmID0gdiAtIE1hdGgubWluKHIsIGcsIGIpO1xuXHRjb25zdCBkaWZmYyA9IGZ1bmN0aW9uIChjKSB7XG5cdFx0cmV0dXJuICh2IC0gYykgLyA2IC8gZGlmZiArIDEgLyAyO1xuXHR9O1xuXG5cdGlmIChkaWZmID09PSAwKSB7XG5cdFx0aCA9IDA7XG5cdFx0cyA9IDA7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IGRpZmYgLyB2O1xuXHRcdHJkaWYgPSBkaWZmYyhyKTtcblx0XHRnZGlmID0gZGlmZmMoZyk7XG5cdFx0YmRpZiA9IGRpZmZjKGIpO1xuXG5cdFx0aWYgKHIgPT09IHYpIHtcblx0XHRcdGggPSBiZGlmIC0gZ2RpZjtcblx0XHR9IGVsc2UgaWYgKGcgPT09IHYpIHtcblx0XHRcdGggPSAoMSAvIDMpICsgcmRpZiAtIGJkaWY7XG5cdFx0fSBlbHNlIGlmIChiID09PSB2KSB7XG5cdFx0XHRoID0gKDIgLyAzKSArIGdkaWYgLSByZGlmO1xuXHRcdH1cblxuXHRcdGlmIChoIDwgMCkge1xuXHRcdFx0aCArPSAxO1xuXHRcdH0gZWxzZSBpZiAoaCA+IDEpIHtcblx0XHRcdGggLT0gMTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gW1xuXHRcdGggKiAzNjAsXG5cdFx0cyAqIDEwMCxcblx0XHR2ICogMTAwXG5cdF07XG59O1xuXG5jb252ZXJ0LnJnYi5od2IgPSBmdW5jdGlvbiAocmdiKSB7XG5cdGNvbnN0IHIgPSByZ2JbMF07XG5cdGNvbnN0IGcgPSByZ2JbMV07XG5cdGxldCBiID0gcmdiWzJdO1xuXHRjb25zdCBoID0gY29udmVydC5yZ2IuaHNsKHJnYilbMF07XG5cdGNvbnN0IHcgPSAxIC8gMjU1ICogTWF0aC5taW4ociwgTWF0aC5taW4oZywgYikpO1xuXG5cdGIgPSAxIC0gMSAvIDI1NSAqIE1hdGgubWF4KHIsIE1hdGgubWF4KGcsIGIpKTtcblxuXHRyZXR1cm4gW2gsIHcgKiAxMDAsIGIgKiAxMDBdO1xufTtcblxuY29udmVydC5yZ2IuY215ayA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0Y29uc3QgciA9IHJnYlswXSAvIDI1NTtcblx0Y29uc3QgZyA9IHJnYlsxXSAvIDI1NTtcblx0Y29uc3QgYiA9IHJnYlsyXSAvIDI1NTtcblxuXHRjb25zdCBrID0gTWF0aC5taW4oMSAtIHIsIDEgLSBnLCAxIC0gYik7XG5cdGNvbnN0IGMgPSAoMSAtIHIgLSBrKSAvICgxIC0gaykgfHwgMDtcblx0Y29uc3QgbSA9ICgxIC0gZyAtIGspIC8gKDEgLSBrKSB8fCAwO1xuXHRjb25zdCB5ID0gKDEgLSBiIC0gaykgLyAoMSAtIGspIHx8IDA7XG5cblx0cmV0dXJuIFtjICogMTAwLCBtICogMTAwLCB5ICogMTAwLCBrICogMTAwXTtcbn07XG5cbmZ1bmN0aW9uIGNvbXBhcmF0aXZlRGlzdGFuY2UoeCwgeSkge1xuXHQvKlxuXHRcdFNlZSBodHRwczovL2VuLm0ud2lraXBlZGlhLm9yZy93aWtpL0V1Y2xpZGVhbl9kaXN0YW5jZSNTcXVhcmVkX0V1Y2xpZGVhbl9kaXN0YW5jZVxuXHQqL1xuXHRyZXR1cm4gKFxuXHRcdCgoeFswXSAtIHlbMF0pICoqIDIpICtcblx0XHQoKHhbMV0gLSB5WzFdKSAqKiAyKSArXG5cdFx0KCh4WzJdIC0geVsyXSkgKiogMilcblx0KTtcbn1cblxuY29udmVydC5yZ2Iua2V5d29yZCA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0Y29uc3QgcmV2ZXJzZWQgPSByZXZlcnNlS2V5d29yZHNbcmdiXTtcblx0aWYgKHJldmVyc2VkKSB7XG5cdFx0cmV0dXJuIHJldmVyc2VkO1xuXHR9XG5cblx0bGV0IGN1cnJlbnRDbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcblx0bGV0IGN1cnJlbnRDbG9zZXN0S2V5d29yZDtcblxuXHRmb3IgKGNvbnN0IGtleXdvcmQgb2YgT2JqZWN0LmtleXMoY3NzS2V5d29yZHMpKSB7XG5cdFx0Y29uc3QgdmFsdWUgPSBjc3NLZXl3b3Jkc1trZXl3b3JkXTtcblxuXHRcdC8vIENvbXB1dGUgY29tcGFyYXRpdmUgZGlzdGFuY2Vcblx0XHRjb25zdCBkaXN0YW5jZSA9IGNvbXBhcmF0aXZlRGlzdGFuY2UocmdiLCB2YWx1ZSk7XG5cblx0XHQvLyBDaGVjayBpZiBpdHMgbGVzcywgaWYgc28gc2V0IGFzIGNsb3Nlc3Rcblx0XHRpZiAoZGlzdGFuY2UgPCBjdXJyZW50Q2xvc2VzdERpc3RhbmNlKSB7XG5cdFx0XHRjdXJyZW50Q2xvc2VzdERpc3RhbmNlID0gZGlzdGFuY2U7XG5cdFx0XHRjdXJyZW50Q2xvc2VzdEtleXdvcmQgPSBrZXl3b3JkO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjdXJyZW50Q2xvc2VzdEtleXdvcmQ7XG59O1xuXG5jb252ZXJ0LmtleXdvcmQucmdiID0gZnVuY3Rpb24gKGtleXdvcmQpIHtcblx0cmV0dXJuIGNzc0tleXdvcmRzW2tleXdvcmRdO1xufTtcblxuY29udmVydC5yZ2IueHl6ID0gZnVuY3Rpb24gKHJnYikge1xuXHRsZXQgciA9IHJnYlswXSAvIDI1NTtcblx0bGV0IGcgPSByZ2JbMV0gLyAyNTU7XG5cdGxldCBiID0gcmdiWzJdIC8gMjU1O1xuXG5cdC8vIEFzc3VtZSBzUkdCXG5cdHIgPSByID4gMC4wNDA0NSA/ICgoKHIgKyAwLjA1NSkgLyAxLjA1NSkgKiogMi40KSA6IChyIC8gMTIuOTIpO1xuXHRnID0gZyA+IDAuMDQwNDUgPyAoKChnICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNCkgOiAoZyAvIDEyLjkyKTtcblx0YiA9IGIgPiAwLjA0MDQ1ID8gKCgoYiArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQpIDogKGIgLyAxMi45Mik7XG5cblx0Y29uc3QgeCA9IChyICogMC40MTI0KSArIChnICogMC4zNTc2KSArIChiICogMC4xODA1KTtcblx0Y29uc3QgeSA9IChyICogMC4yMTI2KSArIChnICogMC43MTUyKSArIChiICogMC4wNzIyKTtcblx0Y29uc3QgeiA9IChyICogMC4wMTkzKSArIChnICogMC4xMTkyKSArIChiICogMC45NTA1KTtcblxuXHRyZXR1cm4gW3ggKiAxMDAsIHkgKiAxMDAsIHogKiAxMDBdO1xufTtcblxuY29udmVydC5yZ2IubGFiID0gZnVuY3Rpb24gKHJnYikge1xuXHRjb25zdCB4eXogPSBjb252ZXJ0LnJnYi54eXoocmdiKTtcblx0bGV0IHggPSB4eXpbMF07XG5cdGxldCB5ID0geHl6WzFdO1xuXHRsZXQgeiA9IHh5elsyXTtcblxuXHR4IC89IDk1LjA0Nztcblx0eSAvPSAxMDA7XG5cdHogLz0gMTA4Ljg4MztcblxuXHR4ID0geCA+IDAuMDA4ODU2ID8gKHggKiogKDEgLyAzKSkgOiAoNy43ODcgKiB4KSArICgxNiAvIDExNik7XG5cdHkgPSB5ID4gMC4wMDg4NTYgPyAoeSAqKiAoMSAvIDMpKSA6ICg3Ljc4NyAqIHkpICsgKDE2IC8gMTE2KTtcblx0eiA9IHogPiAwLjAwODg1NiA/ICh6ICoqICgxIC8gMykpIDogKDcuNzg3ICogeikgKyAoMTYgLyAxMTYpO1xuXG5cdGNvbnN0IGwgPSAoMTE2ICogeSkgLSAxNjtcblx0Y29uc3QgYSA9IDUwMCAqICh4IC0geSk7XG5cdGNvbnN0IGIgPSAyMDAgKiAoeSAtIHopO1xuXG5cdHJldHVybiBbbCwgYSwgYl07XG59O1xuXG5jb252ZXJ0LmhzbC5yZ2IgPSBmdW5jdGlvbiAoaHNsKSB7XG5cdGNvbnN0IGggPSBoc2xbMF0gLyAzNjA7XG5cdGNvbnN0IHMgPSBoc2xbMV0gLyAxMDA7XG5cdGNvbnN0IGwgPSBoc2xbMl0gLyAxMDA7XG5cdGxldCB0Mjtcblx0bGV0IHQzO1xuXHRsZXQgdmFsO1xuXG5cdGlmIChzID09PSAwKSB7XG5cdFx0dmFsID0gbCAqIDI1NTtcblx0XHRyZXR1cm4gW3ZhbCwgdmFsLCB2YWxdO1xuXHR9XG5cblx0aWYgKGwgPCAwLjUpIHtcblx0XHR0MiA9IGwgKiAoMSArIHMpO1xuXHR9IGVsc2Uge1xuXHRcdHQyID0gbCArIHMgLSBsICogcztcblx0fVxuXG5cdGNvbnN0IHQxID0gMiAqIGwgLSB0MjtcblxuXHRjb25zdCByZ2IgPSBbMCwgMCwgMF07XG5cdGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0dDMgPSBoICsgMSAvIDMgKiAtKGkgLSAxKTtcblx0XHRpZiAodDMgPCAwKSB7XG5cdFx0XHR0MysrO1xuXHRcdH1cblxuXHRcdGlmICh0MyA+IDEpIHtcblx0XHRcdHQzLS07XG5cdFx0fVxuXG5cdFx0aWYgKDYgKiB0MyA8IDEpIHtcblx0XHRcdHZhbCA9IHQxICsgKHQyIC0gdDEpICogNiAqIHQzO1xuXHRcdH0gZWxzZSBpZiAoMiAqIHQzIDwgMSkge1xuXHRcdFx0dmFsID0gdDI7XG5cdFx0fSBlbHNlIGlmICgzICogdDMgPCAyKSB7XG5cdFx0XHR2YWwgPSB0MSArICh0MiAtIHQxKSAqICgyIC8gMyAtIHQzKSAqIDY7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbCA9IHQxO1xuXHRcdH1cblxuXHRcdHJnYltpXSA9IHZhbCAqIDI1NTtcblx0fVxuXG5cdHJldHVybiByZ2I7XG59O1xuXG5jb252ZXJ0LmhzbC5oc3YgPSBmdW5jdGlvbiAoaHNsKSB7XG5cdGNvbnN0IGggPSBoc2xbMF07XG5cdGxldCBzID0gaHNsWzFdIC8gMTAwO1xuXHRsZXQgbCA9IGhzbFsyXSAvIDEwMDtcblx0bGV0IHNtaW4gPSBzO1xuXHRjb25zdCBsbWluID0gTWF0aC5tYXgobCwgMC4wMSk7XG5cblx0bCAqPSAyO1xuXHRzICo9IChsIDw9IDEpID8gbCA6IDIgLSBsO1xuXHRzbWluICo9IGxtaW4gPD0gMSA/IGxtaW4gOiAyIC0gbG1pbjtcblx0Y29uc3QgdiA9IChsICsgcykgLyAyO1xuXHRjb25zdCBzdiA9IGwgPT09IDAgPyAoMiAqIHNtaW4pIC8gKGxtaW4gKyBzbWluKSA6ICgyICogcykgLyAobCArIHMpO1xuXG5cdHJldHVybiBbaCwgc3YgKiAxMDAsIHYgKiAxMDBdO1xufTtcblxuY29udmVydC5oc3YucmdiID0gZnVuY3Rpb24gKGhzdikge1xuXHRjb25zdCBoID0gaHN2WzBdIC8gNjA7XG5cdGNvbnN0IHMgPSBoc3ZbMV0gLyAxMDA7XG5cdGxldCB2ID0gaHN2WzJdIC8gMTAwO1xuXHRjb25zdCBoaSA9IE1hdGguZmxvb3IoaCkgJSA2O1xuXG5cdGNvbnN0IGYgPSBoIC0gTWF0aC5mbG9vcihoKTtcblx0Y29uc3QgcCA9IDI1NSAqIHYgKiAoMSAtIHMpO1xuXHRjb25zdCBxID0gMjU1ICogdiAqICgxIC0gKHMgKiBmKSk7XG5cdGNvbnN0IHQgPSAyNTUgKiB2ICogKDEgLSAocyAqICgxIC0gZikpKTtcblx0diAqPSAyNTU7XG5cblx0c3dpdGNoIChoaSkge1xuXHRcdGNhc2UgMDpcblx0XHRcdHJldHVybiBbdiwgdCwgcF07XG5cdFx0Y2FzZSAxOlxuXHRcdFx0cmV0dXJuIFtxLCB2LCBwXTtcblx0XHRjYXNlIDI6XG5cdFx0XHRyZXR1cm4gW3AsIHYsIHRdO1xuXHRcdGNhc2UgMzpcblx0XHRcdHJldHVybiBbcCwgcSwgdl07XG5cdFx0Y2FzZSA0OlxuXHRcdFx0cmV0dXJuIFt0LCBwLCB2XTtcblx0XHRjYXNlIDU6XG5cdFx0XHRyZXR1cm4gW3YsIHAsIHFdO1xuXHR9XG59O1xuXG5jb252ZXJ0Lmhzdi5oc2wgPSBmdW5jdGlvbiAoaHN2KSB7XG5cdGNvbnN0IGggPSBoc3ZbMF07XG5cdGNvbnN0IHMgPSBoc3ZbMV0gLyAxMDA7XG5cdGNvbnN0IHYgPSBoc3ZbMl0gLyAxMDA7XG5cdGNvbnN0IHZtaW4gPSBNYXRoLm1heCh2LCAwLjAxKTtcblx0bGV0IHNsO1xuXHRsZXQgbDtcblxuXHRsID0gKDIgLSBzKSAqIHY7XG5cdGNvbnN0IGxtaW4gPSAoMiAtIHMpICogdm1pbjtcblx0c2wgPSBzICogdm1pbjtcblx0c2wgLz0gKGxtaW4gPD0gMSkgPyBsbWluIDogMiAtIGxtaW47XG5cdHNsID0gc2wgfHwgMDtcblx0bCAvPSAyO1xuXG5cdHJldHVybiBbaCwgc2wgKiAxMDAsIGwgKiAxMDBdO1xufTtcblxuLy8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3NzLWNvbG9yLyNod2ItdG8tcmdiXG5jb252ZXJ0Lmh3Yi5yZ2IgPSBmdW5jdGlvbiAoaHdiKSB7XG5cdGNvbnN0IGggPSBod2JbMF0gLyAzNjA7XG5cdGxldCB3aCA9IGh3YlsxXSAvIDEwMDtcblx0bGV0IGJsID0gaHdiWzJdIC8gMTAwO1xuXHRjb25zdCByYXRpbyA9IHdoICsgYmw7XG5cdGxldCBmO1xuXG5cdC8vIFdoICsgYmwgY2FudCBiZSA+IDFcblx0aWYgKHJhdGlvID4gMSkge1xuXHRcdHdoIC89IHJhdGlvO1xuXHRcdGJsIC89IHJhdGlvO1xuXHR9XG5cblx0Y29uc3QgaSA9IE1hdGguZmxvb3IoNiAqIGgpO1xuXHRjb25zdCB2ID0gMSAtIGJsO1xuXHRmID0gNiAqIGggLSBpO1xuXG5cdGlmICgoaSAmIDB4MDEpICE9PSAwKSB7XG5cdFx0ZiA9IDEgLSBmO1xuXHR9XG5cblx0Y29uc3QgbiA9IHdoICsgZiAqICh2IC0gd2gpOyAvLyBMaW5lYXIgaW50ZXJwb2xhdGlvblxuXG5cdGxldCByO1xuXHRsZXQgZztcblx0bGV0IGI7XG5cdC8qIGVzbGludC1kaXNhYmxlIG1heC1zdGF0ZW1lbnRzLXBlci1saW5lLG5vLW11bHRpLXNwYWNlcyAqL1xuXHRzd2l0Y2ggKGkpIHtcblx0XHRkZWZhdWx0OlxuXHRcdGNhc2UgNjpcblx0XHRjYXNlIDA6IHIgPSB2OyAgZyA9IG47ICBiID0gd2g7IGJyZWFrO1xuXHRcdGNhc2UgMTogciA9IG47ICBnID0gdjsgIGIgPSB3aDsgYnJlYWs7XG5cdFx0Y2FzZSAyOiByID0gd2g7IGcgPSB2OyAgYiA9IG47IGJyZWFrO1xuXHRcdGNhc2UgMzogciA9IHdoOyBnID0gbjsgIGIgPSB2OyBicmVhaztcblx0XHRjYXNlIDQ6IHIgPSBuOyAgZyA9IHdoOyBiID0gdjsgYnJlYWs7XG5cdFx0Y2FzZSA1OiByID0gdjsgIGcgPSB3aDsgYiA9IG47IGJyZWFrO1xuXHR9XG5cdC8qIGVzbGludC1lbmFibGUgbWF4LXN0YXRlbWVudHMtcGVyLWxpbmUsbm8tbXVsdGktc3BhY2VzICovXG5cblx0cmV0dXJuIFtyICogMjU1LCBnICogMjU1LCBiICogMjU1XTtcbn07XG5cbmNvbnZlcnQuY215ay5yZ2IgPSBmdW5jdGlvbiAoY215aykge1xuXHRjb25zdCBjID0gY215a1swXSAvIDEwMDtcblx0Y29uc3QgbSA9IGNteWtbMV0gLyAxMDA7XG5cdGNvbnN0IHkgPSBjbXlrWzJdIC8gMTAwO1xuXHRjb25zdCBrID0gY215a1szXSAvIDEwMDtcblxuXHRjb25zdCByID0gMSAtIE1hdGgubWluKDEsIGMgKiAoMSAtIGspICsgayk7XG5cdGNvbnN0IGcgPSAxIC0gTWF0aC5taW4oMSwgbSAqICgxIC0gaykgKyBrKTtcblx0Y29uc3QgYiA9IDEgLSBNYXRoLm1pbigxLCB5ICogKDEgLSBrKSArIGspO1xuXG5cdHJldHVybiBbciAqIDI1NSwgZyAqIDI1NSwgYiAqIDI1NV07XG59O1xuXG5jb252ZXJ0Lnh5ei5yZ2IgPSBmdW5jdGlvbiAoeHl6KSB7XG5cdGNvbnN0IHggPSB4eXpbMF0gLyAxMDA7XG5cdGNvbnN0IHkgPSB4eXpbMV0gLyAxMDA7XG5cdGNvbnN0IHogPSB4eXpbMl0gLyAxMDA7XG5cdGxldCByO1xuXHRsZXQgZztcblx0bGV0IGI7XG5cblx0ciA9ICh4ICogMy4yNDA2KSArICh5ICogLTEuNTM3MikgKyAoeiAqIC0wLjQ5ODYpO1xuXHRnID0gKHggKiAtMC45Njg5KSArICh5ICogMS44NzU4KSArICh6ICogMC4wNDE1KTtcblx0YiA9ICh4ICogMC4wNTU3KSArICh5ICogLTAuMjA0MCkgKyAoeiAqIDEuMDU3MCk7XG5cblx0Ly8gQXNzdW1lIHNSR0Jcblx0ciA9IHIgPiAwLjAwMzEzMDhcblx0XHQ/ICgoMS4wNTUgKiAociAqKiAoMS4wIC8gMi40KSkpIC0gMC4wNTUpXG5cdFx0OiByICogMTIuOTI7XG5cblx0ZyA9IGcgPiAwLjAwMzEzMDhcblx0XHQ/ICgoMS4wNTUgKiAoZyAqKiAoMS4wIC8gMi40KSkpIC0gMC4wNTUpXG5cdFx0OiBnICogMTIuOTI7XG5cblx0YiA9IGIgPiAwLjAwMzEzMDhcblx0XHQ/ICgoMS4wNTUgKiAoYiAqKiAoMS4wIC8gMi40KSkpIC0gMC4wNTUpXG5cdFx0OiBiICogMTIuOTI7XG5cblx0ciA9IE1hdGgubWluKE1hdGgubWF4KDAsIHIpLCAxKTtcblx0ZyA9IE1hdGgubWluKE1hdGgubWF4KDAsIGcpLCAxKTtcblx0YiA9IE1hdGgubWluKE1hdGgubWF4KDAsIGIpLCAxKTtcblxuXHRyZXR1cm4gW3IgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTVdO1xufTtcblxuY29udmVydC54eXoubGFiID0gZnVuY3Rpb24gKHh5eikge1xuXHRsZXQgeCA9IHh5elswXTtcblx0bGV0IHkgPSB4eXpbMV07XG5cdGxldCB6ID0geHl6WzJdO1xuXG5cdHggLz0gOTUuMDQ3O1xuXHR5IC89IDEwMDtcblx0eiAvPSAxMDguODgzO1xuXG5cdHggPSB4ID4gMC4wMDg4NTYgPyAoeCAqKiAoMSAvIDMpKSA6ICg3Ljc4NyAqIHgpICsgKDE2IC8gMTE2KTtcblx0eSA9IHkgPiAwLjAwODg1NiA/ICh5ICoqICgxIC8gMykpIDogKDcuNzg3ICogeSkgKyAoMTYgLyAxMTYpO1xuXHR6ID0geiA+IDAuMDA4ODU2ID8gKHogKiogKDEgLyAzKSkgOiAoNy43ODcgKiB6KSArICgxNiAvIDExNik7XG5cblx0Y29uc3QgbCA9ICgxMTYgKiB5KSAtIDE2O1xuXHRjb25zdCBhID0gNTAwICogKHggLSB5KTtcblx0Y29uc3QgYiA9IDIwMCAqICh5IC0geik7XG5cblx0cmV0dXJuIFtsLCBhLCBiXTtcbn07XG5cbmNvbnZlcnQubGFiLnh5eiA9IGZ1bmN0aW9uIChsYWIpIHtcblx0Y29uc3QgbCA9IGxhYlswXTtcblx0Y29uc3QgYSA9IGxhYlsxXTtcblx0Y29uc3QgYiA9IGxhYlsyXTtcblx0bGV0IHg7XG5cdGxldCB5O1xuXHRsZXQgejtcblxuXHR5ID0gKGwgKyAxNikgLyAxMTY7XG5cdHggPSBhIC8gNTAwICsgeTtcblx0eiA9IHkgLSBiIC8gMjAwO1xuXG5cdGNvbnN0IHkyID0geSAqKiAzO1xuXHRjb25zdCB4MiA9IHggKiogMztcblx0Y29uc3QgejIgPSB6ICoqIDM7XG5cdHkgPSB5MiA+IDAuMDA4ODU2ID8geTIgOiAoeSAtIDE2IC8gMTE2KSAvIDcuNzg3O1xuXHR4ID0geDIgPiAwLjAwODg1NiA/IHgyIDogKHggLSAxNiAvIDExNikgLyA3Ljc4Nztcblx0eiA9IHoyID4gMC4wMDg4NTYgPyB6MiA6ICh6IC0gMTYgLyAxMTYpIC8gNy43ODc7XG5cblx0eCAqPSA5NS4wNDc7XG5cdHkgKj0gMTAwO1xuXHR6ICo9IDEwOC44ODM7XG5cblx0cmV0dXJuIFt4LCB5LCB6XTtcbn07XG5cbmNvbnZlcnQubGFiLmxjaCA9IGZ1bmN0aW9uIChsYWIpIHtcblx0Y29uc3QgbCA9IGxhYlswXTtcblx0Y29uc3QgYSA9IGxhYlsxXTtcblx0Y29uc3QgYiA9IGxhYlsyXTtcblx0bGV0IGg7XG5cblx0Y29uc3QgaHIgPSBNYXRoLmF0YW4yKGIsIGEpO1xuXHRoID0gaHIgKiAzNjAgLyAyIC8gTWF0aC5QSTtcblxuXHRpZiAoaCA8IDApIHtcblx0XHRoICs9IDM2MDtcblx0fVxuXG5cdGNvbnN0IGMgPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG5cblx0cmV0dXJuIFtsLCBjLCBoXTtcbn07XG5cbmNvbnZlcnQubGNoLmxhYiA9IGZ1bmN0aW9uIChsY2gpIHtcblx0Y29uc3QgbCA9IGxjaFswXTtcblx0Y29uc3QgYyA9IGxjaFsxXTtcblx0Y29uc3QgaCA9IGxjaFsyXTtcblxuXHRjb25zdCBociA9IGggLyAzNjAgKiAyICogTWF0aC5QSTtcblx0Y29uc3QgYSA9IGMgKiBNYXRoLmNvcyhocik7XG5cdGNvbnN0IGIgPSBjICogTWF0aC5zaW4oaHIpO1xuXG5cdHJldHVybiBbbCwgYSwgYl07XG59O1xuXG5jb252ZXJ0LnJnYi5hbnNpMTYgPSBmdW5jdGlvbiAoYXJncywgc2F0dXJhdGlvbiA9IG51bGwpIHtcblx0Y29uc3QgW3IsIGcsIGJdID0gYXJncztcblx0bGV0IHZhbHVlID0gc2F0dXJhdGlvbiA9PT0gbnVsbCA/IGNvbnZlcnQucmdiLmhzdihhcmdzKVsyXSA6IHNhdHVyYXRpb247IC8vIEhzdiAtPiBhbnNpMTYgb3B0aW1pemF0aW9uXG5cblx0dmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlIC8gNTApO1xuXG5cdGlmICh2YWx1ZSA9PT0gMCkge1xuXHRcdHJldHVybiAzMDtcblx0fVxuXG5cdGxldCBhbnNpID0gMzBcblx0XHQrICgoTWF0aC5yb3VuZChiIC8gMjU1KSA8PCAyKVxuXHRcdHwgKE1hdGgucm91bmQoZyAvIDI1NSkgPDwgMSlcblx0XHR8IE1hdGgucm91bmQociAvIDI1NSkpO1xuXG5cdGlmICh2YWx1ZSA9PT0gMikge1xuXHRcdGFuc2kgKz0gNjA7XG5cdH1cblxuXHRyZXR1cm4gYW5zaTtcbn07XG5cbmNvbnZlcnQuaHN2LmFuc2kxNiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdC8vIE9wdGltaXphdGlvbiBoZXJlOyB3ZSBhbHJlYWR5IGtub3cgdGhlIHZhbHVlIGFuZCBkb24ndCBuZWVkIHRvIGdldFxuXHQvLyBpdCBjb252ZXJ0ZWQgZm9yIHVzLlxuXHRyZXR1cm4gY29udmVydC5yZ2IuYW5zaTE2KGNvbnZlcnQuaHN2LnJnYihhcmdzKSwgYXJnc1syXSk7XG59O1xuXG5jb252ZXJ0LnJnYi5hbnNpMjU2ID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0Y29uc3QgciA9IGFyZ3NbMF07XG5cdGNvbnN0IGcgPSBhcmdzWzFdO1xuXHRjb25zdCBiID0gYXJnc1syXTtcblxuXHQvLyBXZSB1c2UgdGhlIGV4dGVuZGVkIGdyZXlzY2FsZSBwYWxldHRlIGhlcmUsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZlxuXHQvLyBibGFjayBhbmQgd2hpdGUuIG5vcm1hbCBwYWxldHRlIG9ubHkgaGFzIDQgZ3JleXNjYWxlIHNoYWRlcy5cblx0aWYgKHIgPT09IGcgJiYgZyA9PT0gYikge1xuXHRcdGlmIChyIDwgOCkge1xuXHRcdFx0cmV0dXJuIDE2O1xuXHRcdH1cblxuXHRcdGlmIChyID4gMjQ4KSB7XG5cdFx0XHRyZXR1cm4gMjMxO1xuXHRcdH1cblxuXHRcdHJldHVybiBNYXRoLnJvdW5kKCgociAtIDgpIC8gMjQ3KSAqIDI0KSArIDIzMjtcblx0fVxuXG5cdGNvbnN0IGFuc2kgPSAxNlxuXHRcdCsgKDM2ICogTWF0aC5yb3VuZChyIC8gMjU1ICogNSkpXG5cdFx0KyAoNiAqIE1hdGgucm91bmQoZyAvIDI1NSAqIDUpKVxuXHRcdCsgTWF0aC5yb3VuZChiIC8gMjU1ICogNSk7XG5cblx0cmV0dXJuIGFuc2k7XG59O1xuXG5jb252ZXJ0LmFuc2kxNi5yZ2IgPSBmdW5jdGlvbiAoYXJncykge1xuXHRsZXQgY29sb3IgPSBhcmdzICUgMTA7XG5cblx0Ly8gSGFuZGxlIGdyZXlzY2FsZVxuXHRpZiAoY29sb3IgPT09IDAgfHwgY29sb3IgPT09IDcpIHtcblx0XHRpZiAoYXJncyA+IDUwKSB7XG5cdFx0XHRjb2xvciArPSAzLjU7XG5cdFx0fVxuXG5cdFx0Y29sb3IgPSBjb2xvciAvIDEwLjUgKiAyNTU7XG5cblx0XHRyZXR1cm4gW2NvbG9yLCBjb2xvciwgY29sb3JdO1xuXHR9XG5cblx0Y29uc3QgbXVsdCA9ICh+fihhcmdzID4gNTApICsgMSkgKiAwLjU7XG5cdGNvbnN0IHIgPSAoKGNvbG9yICYgMSkgKiBtdWx0KSAqIDI1NTtcblx0Y29uc3QgZyA9ICgoKGNvbG9yID4+IDEpICYgMSkgKiBtdWx0KSAqIDI1NTtcblx0Y29uc3QgYiA9ICgoKGNvbG9yID4+IDIpICYgMSkgKiBtdWx0KSAqIDI1NTtcblxuXHRyZXR1cm4gW3IsIGcsIGJdO1xufTtcblxuY29udmVydC5hbnNpMjU2LnJnYiA9IGZ1bmN0aW9uIChhcmdzKSB7XG5cdC8vIEhhbmRsZSBncmV5c2NhbGVcblx0aWYgKGFyZ3MgPj0gMjMyKSB7XG5cdFx0Y29uc3QgYyA9IChhcmdzIC0gMjMyKSAqIDEwICsgODtcblx0XHRyZXR1cm4gW2MsIGMsIGNdO1xuXHR9XG5cblx0YXJncyAtPSAxNjtcblxuXHRsZXQgcmVtO1xuXHRjb25zdCByID0gTWF0aC5mbG9vcihhcmdzIC8gMzYpIC8gNSAqIDI1NTtcblx0Y29uc3QgZyA9IE1hdGguZmxvb3IoKHJlbSA9IGFyZ3MgJSAzNikgLyA2KSAvIDUgKiAyNTU7XG5cdGNvbnN0IGIgPSAocmVtICUgNikgLyA1ICogMjU1O1xuXG5cdHJldHVybiBbciwgZywgYl07XG59O1xuXG5jb252ZXJ0LnJnYi5oZXggPSBmdW5jdGlvbiAoYXJncykge1xuXHRjb25zdCBpbnRlZ2VyID0gKChNYXRoLnJvdW5kKGFyZ3NbMF0pICYgMHhGRikgPDwgMTYpXG5cdFx0KyAoKE1hdGgucm91bmQoYXJnc1sxXSkgJiAweEZGKSA8PCA4KVxuXHRcdCsgKE1hdGgucm91bmQoYXJnc1syXSkgJiAweEZGKTtcblxuXHRjb25zdCBzdHJpbmcgPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRyZXR1cm4gJzAwMDAwMCcuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufTtcblxuY29udmVydC5oZXgucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0Y29uc3QgbWF0Y2ggPSBhcmdzLnRvU3RyaW5nKDE2KS5tYXRjaCgvW2EtZjAtOV17Nn18W2EtZjAtOV17M30vaSk7XG5cdGlmICghbWF0Y2gpIHtcblx0XHRyZXR1cm4gWzAsIDAsIDBdO1xuXHR9XG5cblx0bGV0IGNvbG9yU3RyaW5nID0gbWF0Y2hbMF07XG5cblx0aWYgKG1hdGNoWzBdLmxlbmd0aCA9PT0gMykge1xuXHRcdGNvbG9yU3RyaW5nID0gY29sb3JTdHJpbmcuc3BsaXQoJycpLm1hcChjaGFyID0+IHtcblx0XHRcdHJldHVybiBjaGFyICsgY2hhcjtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdGNvbnN0IGludGVnZXIgPSBwYXJzZUludChjb2xvclN0cmluZywgMTYpO1xuXHRjb25zdCByID0gKGludGVnZXIgPj4gMTYpICYgMHhGRjtcblx0Y29uc3QgZyA9IChpbnRlZ2VyID4+IDgpICYgMHhGRjtcblx0Y29uc3QgYiA9IGludGVnZXIgJiAweEZGO1xuXG5cdHJldHVybiBbciwgZywgYl07XG59O1xuXG5jb252ZXJ0LnJnYi5oY2cgPSBmdW5jdGlvbiAocmdiKSB7XG5cdGNvbnN0IHIgPSByZ2JbMF0gLyAyNTU7XG5cdGNvbnN0IGcgPSByZ2JbMV0gLyAyNTU7XG5cdGNvbnN0IGIgPSByZ2JbMl0gLyAyNTU7XG5cdGNvbnN0IG1heCA9IE1hdGgubWF4KE1hdGgubWF4KHIsIGcpLCBiKTtcblx0Y29uc3QgbWluID0gTWF0aC5taW4oTWF0aC5taW4ociwgZyksIGIpO1xuXHRjb25zdCBjaHJvbWEgPSAobWF4IC0gbWluKTtcblx0bGV0IGdyYXlzY2FsZTtcblx0bGV0IGh1ZTtcblxuXHRpZiAoY2hyb21hIDwgMSkge1xuXHRcdGdyYXlzY2FsZSA9IG1pbiAvICgxIC0gY2hyb21hKTtcblx0fSBlbHNlIHtcblx0XHRncmF5c2NhbGUgPSAwO1xuXHR9XG5cblx0aWYgKGNocm9tYSA8PSAwKSB7XG5cdFx0aHVlID0gMDtcblx0fSBlbHNlXG5cdGlmIChtYXggPT09IHIpIHtcblx0XHRodWUgPSAoKGcgLSBiKSAvIGNocm9tYSkgJSA2O1xuXHR9IGVsc2Vcblx0aWYgKG1heCA9PT0gZykge1xuXHRcdGh1ZSA9IDIgKyAoYiAtIHIpIC8gY2hyb21hO1xuXHR9IGVsc2Uge1xuXHRcdGh1ZSA9IDQgKyAociAtIGcpIC8gY2hyb21hO1xuXHR9XG5cblx0aHVlIC89IDY7XG5cdGh1ZSAlPSAxO1xuXG5cdHJldHVybiBbaHVlICogMzYwLCBjaHJvbWEgKiAxMDAsIGdyYXlzY2FsZSAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmhzbC5oY2cgPSBmdW5jdGlvbiAoaHNsKSB7XG5cdGNvbnN0IHMgPSBoc2xbMV0gLyAxMDA7XG5cdGNvbnN0IGwgPSBoc2xbMl0gLyAxMDA7XG5cblx0Y29uc3QgYyA9IGwgPCAwLjUgPyAoMi4wICogcyAqIGwpIDogKDIuMCAqIHMgKiAoMS4wIC0gbCkpO1xuXG5cdGxldCBmID0gMDtcblx0aWYgKGMgPCAxLjApIHtcblx0XHRmID0gKGwgLSAwLjUgKiBjKSAvICgxLjAgLSBjKTtcblx0fVxuXG5cdHJldHVybiBbaHNsWzBdLCBjICogMTAwLCBmICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHN2LmhjZyA9IGZ1bmN0aW9uIChoc3YpIHtcblx0Y29uc3QgcyA9IGhzdlsxXSAvIDEwMDtcblx0Y29uc3QgdiA9IGhzdlsyXSAvIDEwMDtcblxuXHRjb25zdCBjID0gcyAqIHY7XG5cdGxldCBmID0gMDtcblxuXHRpZiAoYyA8IDEuMCkge1xuXHRcdGYgPSAodiAtIGMpIC8gKDEgLSBjKTtcblx0fVxuXG5cdHJldHVybiBbaHN2WzBdLCBjICogMTAwLCBmICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaGNnLnJnYiA9IGZ1bmN0aW9uIChoY2cpIHtcblx0Y29uc3QgaCA9IGhjZ1swXSAvIDM2MDtcblx0Y29uc3QgYyA9IGhjZ1sxXSAvIDEwMDtcblx0Y29uc3QgZyA9IGhjZ1syXSAvIDEwMDtcblxuXHRpZiAoYyA9PT0gMC4wKSB7XG5cdFx0cmV0dXJuIFtnICogMjU1LCBnICogMjU1LCBnICogMjU1XTtcblx0fVxuXG5cdGNvbnN0IHB1cmUgPSBbMCwgMCwgMF07XG5cdGNvbnN0IGhpID0gKGggJSAxKSAqIDY7XG5cdGNvbnN0IHYgPSBoaSAlIDE7XG5cdGNvbnN0IHcgPSAxIC0gdjtcblx0bGV0IG1nID0gMDtcblxuXHQvKiBlc2xpbnQtZGlzYWJsZSBtYXgtc3RhdGVtZW50cy1wZXItbGluZSAqL1xuXHRzd2l0Y2ggKE1hdGguZmxvb3IoaGkpKSB7XG5cdFx0Y2FzZSAwOlxuXHRcdFx0cHVyZVswXSA9IDE7IHB1cmVbMV0gPSB2OyBwdXJlWzJdID0gMDsgYnJlYWs7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0cHVyZVswXSA9IHc7IHB1cmVbMV0gPSAxOyBwdXJlWzJdID0gMDsgYnJlYWs7XG5cdFx0Y2FzZSAyOlxuXHRcdFx0cHVyZVswXSA9IDA7IHB1cmVbMV0gPSAxOyBwdXJlWzJdID0gdjsgYnJlYWs7XG5cdFx0Y2FzZSAzOlxuXHRcdFx0cHVyZVswXSA9IDA7IHB1cmVbMV0gPSB3OyBwdXJlWzJdID0gMTsgYnJlYWs7XG5cdFx0Y2FzZSA0OlxuXHRcdFx0cHVyZVswXSA9IHY7IHB1cmVbMV0gPSAwOyBwdXJlWzJdID0gMTsgYnJlYWs7XG5cdFx0ZGVmYXVsdDpcblx0XHRcdHB1cmVbMF0gPSAxOyBwdXJlWzFdID0gMDsgcHVyZVsyXSA9IHc7XG5cdH1cblx0LyogZXNsaW50LWVuYWJsZSBtYXgtc3RhdGVtZW50cy1wZXItbGluZSAqL1xuXG5cdG1nID0gKDEuMCAtIGMpICogZztcblxuXHRyZXR1cm4gW1xuXHRcdChjICogcHVyZVswXSArIG1nKSAqIDI1NSxcblx0XHQoYyAqIHB1cmVbMV0gKyBtZykgKiAyNTUsXG5cdFx0KGMgKiBwdXJlWzJdICsgbWcpICogMjU1XG5cdF07XG59O1xuXG5jb252ZXJ0LmhjZy5oc3YgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdGNvbnN0IGMgPSBoY2dbMV0gLyAxMDA7XG5cdGNvbnN0IGcgPSBoY2dbMl0gLyAxMDA7XG5cblx0Y29uc3QgdiA9IGMgKyBnICogKDEuMCAtIGMpO1xuXHRsZXQgZiA9IDA7XG5cblx0aWYgKHYgPiAwLjApIHtcblx0XHRmID0gYyAvIHY7XG5cdH1cblxuXHRyZXR1cm4gW2hjZ1swXSwgZiAqIDEwMCwgdiAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmhjZy5oc2wgPSBmdW5jdGlvbiAoaGNnKSB7XG5cdGNvbnN0IGMgPSBoY2dbMV0gLyAxMDA7XG5cdGNvbnN0IGcgPSBoY2dbMl0gLyAxMDA7XG5cblx0Y29uc3QgbCA9IGcgKiAoMS4wIC0gYykgKyAwLjUgKiBjO1xuXHRsZXQgcyA9IDA7XG5cblx0aWYgKGwgPiAwLjAgJiYgbCA8IDAuNSkge1xuXHRcdHMgPSBjIC8gKDIgKiBsKTtcblx0fSBlbHNlXG5cdGlmIChsID49IDAuNSAmJiBsIDwgMS4wKSB7XG5cdFx0cyA9IGMgLyAoMiAqICgxIC0gbCkpO1xuXHR9XG5cblx0cmV0dXJuIFtoY2dbMF0sIHMgKiAxMDAsIGwgKiAxMDBdO1xufTtcblxuY29udmVydC5oY2cuaHdiID0gZnVuY3Rpb24gKGhjZykge1xuXHRjb25zdCBjID0gaGNnWzFdIC8gMTAwO1xuXHRjb25zdCBnID0gaGNnWzJdIC8gMTAwO1xuXHRjb25zdCB2ID0gYyArIGcgKiAoMS4wIC0gYyk7XG5cdHJldHVybiBbaGNnWzBdLCAodiAtIGMpICogMTAwLCAoMSAtIHYpICogMTAwXTtcbn07XG5cbmNvbnZlcnQuaHdiLmhjZyA9IGZ1bmN0aW9uIChod2IpIHtcblx0Y29uc3QgdyA9IGh3YlsxXSAvIDEwMDtcblx0Y29uc3QgYiA9IGh3YlsyXSAvIDEwMDtcblx0Y29uc3QgdiA9IDEgLSBiO1xuXHRjb25zdCBjID0gdiAtIHc7XG5cdGxldCBnID0gMDtcblxuXHRpZiAoYyA8IDEpIHtcblx0XHRnID0gKHYgLSBjKSAvICgxIC0gYyk7XG5cdH1cblxuXHRyZXR1cm4gW2h3YlswXSwgYyAqIDEwMCwgZyAqIDEwMF07XG59O1xuXG5jb252ZXJ0LmFwcGxlLnJnYiA9IGZ1bmN0aW9uIChhcHBsZSkge1xuXHRyZXR1cm4gWyhhcHBsZVswXSAvIDY1NTM1KSAqIDI1NSwgKGFwcGxlWzFdIC8gNjU1MzUpICogMjU1LCAoYXBwbGVbMl0gLyA2NTUzNSkgKiAyNTVdO1xufTtcblxuY29udmVydC5yZ2IuYXBwbGUgPSBmdW5jdGlvbiAocmdiKSB7XG5cdHJldHVybiBbKHJnYlswXSAvIDI1NSkgKiA2NTUzNSwgKHJnYlsxXSAvIDI1NSkgKiA2NTUzNSwgKHJnYlsyXSAvIDI1NSkgKiA2NTUzNV07XG59O1xuXG5jb252ZXJ0LmdyYXkucmdiID0gZnVuY3Rpb24gKGFyZ3MpIHtcblx0cmV0dXJuIFthcmdzWzBdIC8gMTAwICogMjU1LCBhcmdzWzBdIC8gMTAwICogMjU1LCBhcmdzWzBdIC8gMTAwICogMjU1XTtcbn07XG5cbmNvbnZlcnQuZ3JheS5oc2wgPSBmdW5jdGlvbiAoYXJncykge1xuXHRyZXR1cm4gWzAsIDAsIGFyZ3NbMF1dO1xufTtcblxuY29udmVydC5ncmF5LmhzdiA9IGNvbnZlcnQuZ3JheS5oc2w7XG5cbmNvbnZlcnQuZ3JheS5od2IgPSBmdW5jdGlvbiAoZ3JheSkge1xuXHRyZXR1cm4gWzAsIDEwMCwgZ3JheVswXV07XG59O1xuXG5jb252ZXJ0LmdyYXkuY215ayA9IGZ1bmN0aW9uIChncmF5KSB7XG5cdHJldHVybiBbMCwgMCwgMCwgZ3JheVswXV07XG59O1xuXG5jb252ZXJ0LmdyYXkubGFiID0gZnVuY3Rpb24gKGdyYXkpIHtcblx0cmV0dXJuIFtncmF5WzBdLCAwLCAwXTtcbn07XG5cbmNvbnZlcnQuZ3JheS5oZXggPSBmdW5jdGlvbiAoZ3JheSkge1xuXHRjb25zdCB2YWwgPSBNYXRoLnJvdW5kKGdyYXlbMF0gLyAxMDAgKiAyNTUpICYgMHhGRjtcblx0Y29uc3QgaW50ZWdlciA9ICh2YWwgPDwgMTYpICsgKHZhbCA8PCA4KSArIHZhbDtcblxuXHRjb25zdCBzdHJpbmcgPSBpbnRlZ2VyLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRyZXR1cm4gJzAwMDAwMCcuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpICsgc3RyaW5nO1xufTtcblxuY29udmVydC5yZ2IuZ3JheSA9IGZ1bmN0aW9uIChyZ2IpIHtcblx0Y29uc3QgdmFsID0gKHJnYlswXSArIHJnYlsxXSArIHJnYlsyXSkgLyAzO1xuXHRyZXR1cm4gW3ZhbCAvIDI1NSAqIDEwMF07XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///17\n")},function(module,exports){eval('module.exports = require("assert");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJhc3NlcnRcIj84MTcyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYXNzZXJ0XCIpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18\n')},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(__dirname) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isYargsInstance = exports.rebase = exports.Yargs = void 0;\nconst command_1 = __webpack_require__(20);\nconst common_types_1 = __webpack_require__(1);\nconst yerror_1 = __webpack_require__(6);\nconst usage_1 = __webpack_require__(56);\nconst argsert_1 = __webpack_require__(10);\nconst fs = __webpack_require__(2);\nconst completion_1 = __webpack_require__(61);\nconst path = __webpack_require__(0);\nconst validation_1 = __webpack_require__(63);\nconst obj_filter_1 = __webpack_require__(13);\nconst apply_extends_1 = __webpack_require__(65);\nconst middleware_1 = __webpack_require__(21);\nconst processArgv = __webpack_require__(24);\nconst is_promise_1 = __webpack_require__(5);\nconst Parser = __webpack_require__(12);\nconst y18nFactory = __webpack_require__(66);\nconst setBlocking = __webpack_require__(23);\nconst findUp = __webpack_require__(67);\nconst requireMainFilename = __webpack_require__(73);\nfunction Yargs(processArgs = [], cwd = process.cwd(), parentRequire = __webpack_require__(7)) {\n    const self = {};\n    let command;\n    let completion = null;\n    let groups = {};\n    const globalMiddleware = [];\n    let output = '';\n    const preservedGroups = {};\n    let usage;\n    let validation;\n    let handlerFinishCommand = null;\n    const y18n = y18nFactory({\n        directory: path.resolve(__dirname, '../../locales'),\n        updateFiles: false\n    });\n    self.middleware = middleware_1.globalMiddlewareFactory(globalMiddleware, self);\n    self.scriptName = function (scriptName) {\n        self.customScriptName = true;\n        self.$0 = scriptName;\n        return self;\n    };\n    // ignore the node bin, specify this in your\n    // bin file with #!/usr/bin/env node\n    let default$0;\n    if (/\\b(node|iojs|electron)(\\.exe)?$/.test(process.argv[0])) {\n        default$0 = process.argv.slice(1, 2);\n    }\n    else {\n        default$0 = process.argv.slice(0, 1);\n    }\n    self.$0 = default$0\n        .map(x => {\n        const b = rebase(cwd, x);\n        return x.match(/^(\\/|([a-zA-Z]:)?\\\\)/) && b.length < x.length ? b : x;\n    })\n        .join(' ').trim();\n    if (process.env._ !== undefined && processArgv.getProcessArgvBin() === process.env._) {\n        self.$0 = process.env._.replace(`${path.dirname(process.execPath)}/`, '');\n    }\n    // use context object to keep track of resets, subcommand execution, etc\n    // submodules should modify and check the state of context as necessary\n    const context = { resets: -1, commands: [], fullCommands: [], files: [] };\n    self.getContext = () => context;\n    // puts yargs back into an initial state. any keys\n    // that have been set to \"global\" will not be reset\n    // by this action.\n    let options;\n    self.resetOptions = self.reset = function resetOptions(aliases = {}) {\n        context.resets++;\n        options = options || {};\n        // put yargs back into an initial state, this\n        // logic is used to build a nested command\n        // hierarchy.\n        const tmpOptions = {};\n        tmpOptions.local = options.local ? options.local : [];\n        tmpOptions.configObjects = options.configObjects ? options.configObjects : [];\n        // if a key has been explicitly set as local,\n        // we should reset it before passing options to command.\n        const localLookup = {};\n        tmpOptions.local.forEach((l) => {\n            localLookup[l] = true;\n            (aliases[l] || []).forEach((a) => {\n                localLookup[a] = true;\n            });\n        });\n        // add all groups not set to local to preserved groups\n        Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) => {\n            const keys = groups[groupName].filter(key => !(key in localLookup));\n            if (keys.length > 0) {\n                acc[groupName] = keys;\n            }\n            return acc;\n        }, {}));\n        // groups can now be reset\n        groups = {};\n        const arrayOptions = [\n            'array', 'boolean', 'string', 'skipValidation',\n            'count', 'normalize', 'number',\n            'hiddenOptions'\n        ];\n        const objectOptions = [\n            'narg', 'key', 'alias', 'default', 'defaultDescription',\n            'config', 'choices', 'demandedOptions', 'demandedCommands', 'coerce',\n            'deprecatedOptions'\n        ];\n        arrayOptions.forEach(k => {\n            tmpOptions[k] = (options[k] || []).filter(k => !localLookup[k]);\n        });\n        objectOptions.forEach((k) => {\n            tmpOptions[k] = obj_filter_1.objFilter(options[k], k => !localLookup[k]);\n        });\n        tmpOptions.envPrefix = options.envPrefix;\n        options = tmpOptions;\n        // if this is the first time being executed, create\n        // instances of all our helpers -- otherwise just reset.\n        usage = usage ? usage.reset(localLookup) : usage_1.usage(self, y18n);\n        validation = validation ? validation.reset(localLookup) : validation_1.validation(self, usage, y18n);\n        command = command ? command.reset() : command_1.command(self, usage, validation, globalMiddleware);\n        if (!completion)\n            completion = completion_1.completion(self, usage, command);\n        completionCommand = null;\n        output = '';\n        exitError = null;\n        hasOutput = false;\n        self.parsed = false;\n        return self;\n    };\n    self.resetOptions();\n    // temporary hack: allow \"freezing\" of reset-able state for parse(msg, cb)\n    const frozens = [];\n    function freeze() {\n        frozens.push({\n            options,\n            configObjects: options.configObjects.slice(0),\n            exitProcess,\n            groups,\n            strict,\n            strictCommands,\n            completionCommand,\n            output,\n            exitError,\n            hasOutput,\n            parsed: self.parsed,\n            parseFn,\n            parseContext,\n            handlerFinishCommand\n        });\n        usage.freeze();\n        validation.freeze();\n        command.freeze();\n    }\n    function unfreeze() {\n        const frozen = frozens.pop();\n        common_types_1.assertNotStrictEqual(frozen, undefined);\n        let configObjects;\n        ({\n            options,\n            configObjects,\n            exitProcess,\n            groups,\n            output,\n            exitError,\n            hasOutput,\n            parsed: self.parsed,\n            strict,\n            strictCommands,\n            completionCommand,\n            parseFn,\n            parseContext,\n            handlerFinishCommand\n        } = frozen);\n        options.configObjects = configObjects;\n        usage.unfreeze();\n        validation.unfreeze();\n        command.unfreeze();\n    }\n    self.boolean = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('boolean', keys);\n        return self;\n    };\n    self.array = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('array', keys);\n        return self;\n    };\n    self.number = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('number', keys);\n        return self;\n    };\n    self.normalize = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('normalize', keys);\n        return self;\n    };\n    self.count = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('count', keys);\n        return self;\n    };\n    self.string = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('string', keys);\n        return self;\n    };\n    self.requiresArg = function (keys) {\n        // the 2nd paramter [number] in the argsert the assertion is mandatory\n        // as populateParserHintSingleValueDictionary recursively calls requiresArg\n        // with Nan as a 2nd parameter, although we ignore it\n        argsert_1.argsert('<array|string|object> [number]', [keys], arguments.length);\n        // If someone configures nargs at the same time as requiresArg,\n        // nargs should take precedent,\n        // see: https://github.com/yargs/yargs/pull/1572\n        // TODO: make this work with aliases, using a check similar to\n        // checkAllAliases() in yargs-parser.\n        if (typeof keys === 'string' && options.narg[keys]) {\n            return self;\n        }\n        else {\n            populateParserHintSingleValueDictionary(self.requiresArg, 'narg', keys, NaN);\n        }\n        return self;\n    };\n    self.skipValidation = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('skipValidation', keys);\n        return self;\n    };\n    function populateParserHintArray(type, keys) {\n        keys = [].concat(keys);\n        keys.forEach((key) => {\n            key = sanitizeKey(key);\n            options[type].push(key);\n        });\n    }\n    self.nargs = function (key, value) {\n        argsert_1.argsert('<string|object|array> [number]', [key, value], arguments.length);\n        populateParserHintSingleValueDictionary(self.nargs, 'narg', key, value);\n        return self;\n    };\n    self.choices = function (key, value) {\n        argsert_1.argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n        populateParserHintArrayDictionary(self.choices, 'choices', key, value);\n        return self;\n    };\n    self.alias = function (key, value) {\n        argsert_1.argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n        populateParserHintArrayDictionary(self.alias, 'alias', key, value);\n        return self;\n    };\n    // TODO: actually deprecate self.defaults.\n    self.default = self.defaults = function (key, value, defaultDescription) {\n        argsert_1.argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length);\n        if (defaultDescription) {\n            common_types_1.assertSingleKey(key);\n            options.defaultDescription[key] = defaultDescription;\n        }\n        if (typeof value === 'function') {\n            common_types_1.assertSingleKey(key);\n            if (!options.defaultDescription[key])\n                options.defaultDescription[key] = usage.functionDescription(value);\n            value = value.call();\n        }\n        populateParserHintSingleValueDictionary(self.default, 'default', key, value);\n        return self;\n    };\n    self.describe = function (key, desc) {\n        argsert_1.argsert('<object|string|array> [string]', [key, desc], arguments.length);\n        setKey(key, true);\n        usage.describe(key, desc);\n        return self;\n    };\n    function setKey(key, set) {\n        populateParserHintSingleValueDictionary(setKey, 'key', key, set);\n        return self;\n    }\n    function demandOption(keys, msg) {\n        argsert_1.argsert('<object|string|array> [string]', [keys, msg], arguments.length);\n        populateParserHintSingleValueDictionary(self.demandOption, 'demandedOptions', keys, msg);\n        return self;\n    }\n    self.demandOption = demandOption;\n    self.coerce = function (keys, value) {\n        argsert_1.argsert('<object|string|array> [function]', [keys, value], arguments.length);\n        populateParserHintSingleValueDictionary(self.coerce, 'coerce', keys, value);\n        return self;\n    };\n    function populateParserHintSingleValueDictionary(builder, type, key, value) {\n        populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\n            options[type][key] = value;\n        });\n    }\n    function populateParserHintArrayDictionary(builder, type, key, value) {\n        populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\n            options[type][key] = (options[type][key] || []).concat(value);\n        });\n    }\n    function populateParserHintDictionary(builder, type, key, value, singleKeyHandler) {\n        if (Array.isArray(key)) {\n            // an array of keys with one value ['x', 'y', 'z'], function parse () {}\n            key.forEach((k) => {\n                builder(k, value);\n            });\n        }\n        else if (((key) => typeof key === 'object')(key)) {\n            // an object of key value pairs: {'x': parse () {}, 'y': parse() {}}\n            for (const k of common_types_1.objectKeys(key)) {\n                builder(k, key[k]);\n            }\n        }\n        else {\n            singleKeyHandler(type, sanitizeKey(key), value);\n        }\n    }\n    function sanitizeKey(key) {\n        if (key === '__proto__')\n            return '___proto___';\n        return key;\n    }\n    function deleteFromParserHintObject(optionKey) {\n        // delete from all parsing hints:\n        // boolean, array, key, alias, etc.\n        common_types_1.objectKeys(options).forEach((hintKey) => {\n            // configObjects is not a parsing hint array\n            if (((key) => key === 'configObjects')(hintKey))\n                return;\n            const hint = options[hintKey];\n            if (Array.isArray(hint)) {\n                if (~hint.indexOf(optionKey))\n                    hint.splice(hint.indexOf(optionKey), 1);\n            }\n            else if (typeof hint === 'object') {\n                delete hint[optionKey];\n            }\n        });\n        // now delete the description from usage.js.\n        delete usage.getDescriptions()[optionKey];\n    }\n    self.config = function config(key = 'config', msg, parseFn) {\n        argsert_1.argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length);\n        // allow a config object to be provided directly.\n        if ((typeof key === 'object') && !Array.isArray(key)) {\n            key = apply_extends_1.applyExtends(key, cwd, self.getParserConfiguration()['deep-merge-config']);\n            options.configObjects = (options.configObjects || []).concat(key);\n            return self;\n        }\n        // allow for a custom parsing function.\n        if (typeof msg === 'function') {\n            parseFn = msg;\n            msg = undefined;\n        }\n        self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'));\n        (Array.isArray(key) ? key : [key]).forEach((k) => {\n            options.config[k] = parseFn || true;\n        });\n        return self;\n    };\n    self.example = function (cmd, description) {\n        argsert_1.argsert('<string|array> [string]', [cmd, description], arguments.length);\n        if (Array.isArray(cmd)) {\n            cmd.forEach((exampleParams) => self.example(...exampleParams));\n        }\n        else {\n            usage.example(cmd, description);\n        }\n        return self;\n    };\n    self.command = function (cmd, description, builder, handler, middlewares, deprecated) {\n        argsert_1.argsert('<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]', [cmd, description, builder, handler, middlewares, deprecated], arguments.length);\n        command.addHandler(cmd, description, builder, handler, middlewares, deprecated);\n        return self;\n    };\n    self.commandDir = function (dir, opts) {\n        argsert_1.argsert('<string> [object]', [dir, opts], arguments.length);\n        const req = parentRequire || __webpack_require__(7);\n        command.addDirectory(dir, self.getContext(), req, __webpack_require__(75)(), opts);\n        return self;\n    };\n    // TODO: deprecate self.demand in favor of\n    // .demandCommand() .demandOption().\n    self.demand = self.required = self.require = function demand(keys, max, msg) {\n        // you can optionally provide a 'max' key,\n        // which will raise an exception if too many '_'\n        // options are provided.\n        if (Array.isArray(max)) {\n            max.forEach((key) => {\n                common_types_1.assertNotStrictEqual(msg, true);\n                demandOption(key, msg);\n            });\n            max = Infinity;\n        }\n        else if (typeof max !== 'number') {\n            msg = max;\n            max = Infinity;\n        }\n        if (typeof keys === 'number') {\n            common_types_1.assertNotStrictEqual(msg, true);\n            self.demandCommand(keys, max, msg, msg);\n        }\n        else if (Array.isArray(keys)) {\n            keys.forEach((key) => {\n                common_types_1.assertNotStrictEqual(msg, true);\n                demandOption(key, msg);\n            });\n        }\n        else {\n            if (typeof msg === 'string') {\n                demandOption(keys, msg);\n            }\n            else if (msg === true || typeof msg === 'undefined') {\n                demandOption(keys);\n            }\n        }\n        return self;\n    };\n    self.demandCommand = function demandCommand(min = 1, max, minMsg, maxMsg) {\n        argsert_1.argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [min, max, minMsg, maxMsg], arguments.length);\n        if (typeof max !== 'number') {\n            minMsg = max;\n            max = Infinity;\n        }\n        self.global('_', false);\n        options.demandedCommands._ = {\n            min,\n            max,\n            minMsg,\n            maxMsg\n        };\n        return self;\n    };\n    self.getDemandedOptions = () => {\n        argsert_1.argsert([], 0);\n        return options.demandedOptions;\n    };\n    self.getDemandedCommands = () => {\n        argsert_1.argsert([], 0);\n        return options.demandedCommands;\n    };\n    self.deprecateOption = function deprecateOption(option, message) {\n        argsert_1.argsert('<string> [string|boolean]', [option, message], arguments.length);\n        options.deprecatedOptions[option] = message;\n        return self;\n    };\n    self.getDeprecatedOptions = () => {\n        argsert_1.argsert([], 0);\n        return options.deprecatedOptions;\n    };\n    self.implies = function (key, value) {\n        argsert_1.argsert('<string|object> [number|string|array]', [key, value], arguments.length);\n        validation.implies(key, value);\n        return self;\n    };\n    self.conflicts = function (key1, key2) {\n        argsert_1.argsert('<string|object> [string|array]', [key1, key2], arguments.length);\n        validation.conflicts(key1, key2);\n        return self;\n    };\n    self.usage = function (msg, description, builder, handler) {\n        argsert_1.argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [msg, description, builder, handler], arguments.length);\n        if (description !== undefined) {\n            common_types_1.assertNotStrictEqual(msg, null);\n            // .usage() can be used as an alias for defining\n            // a default command.\n            if ((msg || '').match(/^\\$0( |$)/)) {\n                return self.command(msg, description, builder, handler);\n            }\n            else {\n                throw new yerror_1.YError('.usage() description must start with $0 if being used as alias for .command()');\n            }\n        }\n        else {\n            usage.usage(msg);\n            return self;\n        }\n    };\n    self.epilogue = self.epilog = function (msg) {\n        argsert_1.argsert('<string>', [msg], arguments.length);\n        usage.epilog(msg);\n        return self;\n    };\n    self.fail = function (f) {\n        argsert_1.argsert('<function>', [f], arguments.length);\n        usage.failFn(f);\n        return self;\n    };\n    self.onFinishCommand = function (f) {\n        argsert_1.argsert('<function>', [f], arguments.length);\n        handlerFinishCommand = f;\n        return self;\n    };\n    self.getHandlerFinishCommand = () => handlerFinishCommand;\n    self.check = function (f, _global) {\n        argsert_1.argsert('<function> [boolean]', [f, _global], arguments.length);\n        validation.check(f, _global !== false);\n        return self;\n    };\n    self.global = function global(globals, global) {\n        argsert_1.argsert('<string|array> [boolean]', [globals, global], arguments.length);\n        globals = [].concat(globals);\n        if (global !== false) {\n            options.local = options.local.filter(l => globals.indexOf(l) === -1);\n        }\n        else {\n            globals.forEach((g) => {\n                if (options.local.indexOf(g) === -1)\n                    options.local.push(g);\n            });\n        }\n        return self;\n    };\n    self.pkgConf = function pkgConf(key, rootPath) {\n        argsert_1.argsert('<string> [string]', [key, rootPath], arguments.length);\n        let conf = null;\n        // prefer cwd to require-main-filename in this method\n        // since we're looking for e.g. \"nyc\" config in nyc consumer\n        // rather than \"yargs\" config in nyc (where nyc is the main filename)\n        const obj = pkgUp(rootPath || cwd);\n        // If an object exists in the key, add it to options.configObjects\n        if (obj[key] && typeof obj[key] === 'object') {\n            conf = apply_extends_1.applyExtends(obj[key], rootPath || cwd, self.getParserConfiguration()['deep-merge-config']);\n            options.configObjects = (options.configObjects || []).concat(conf);\n        }\n        return self;\n    };\n    const pkgs = {};\n    function pkgUp(rootPath) {\n        const npath = rootPath || '*';\n        if (pkgs[npath])\n            return pkgs[npath];\n        let obj = {};\n        try {\n            let startDir = rootPath || requireMainFilename(parentRequire);\n            // When called in an environment that lacks require.main.filename, such as a jest test runner,\n            // startDir is already process.cwd(), and should not be shortened.\n            // Whether or not it is _actually_ a directory (e.g., extensionless bin) is irrelevant, find-up handles it.\n            if (!rootPath && path.extname(startDir)) {\n                startDir = path.dirname(startDir);\n            }\n            const pkgJsonPath = findUp.sync('package.json', {\n                cwd: startDir\n            });\n            common_types_1.assertNotStrictEqual(pkgJsonPath, undefined);\n            obj = JSON.parse(fs.readFileSync(pkgJsonPath).toString());\n        }\n        catch (noop) { }\n        pkgs[npath] = obj || {};\n        return pkgs[npath];\n    }\n    let parseFn = null;\n    let parseContext = null;\n    self.parse = function parse(args, shortCircuit, _parseFn) {\n        argsert_1.argsert('[string|array] [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length);\n        freeze();\n        if (typeof args === 'undefined') {\n            const argv = self._parseArgs(processArgs);\n            const tmpParsed = self.parsed;\n            unfreeze();\n            // TODO: remove this compatibility hack when we release yargs@15.x:\n            self.parsed = tmpParsed;\n            return argv;\n        }\n        // a context object can optionally be provided, this allows\n        // additional information to be passed to a command handler.\n        if (typeof shortCircuit === 'object') {\n            parseContext = shortCircuit;\n            shortCircuit = _parseFn;\n        }\n        // by providing a function as a second argument to\n        // parse you can capture output that would otherwise\n        // default to printing to stdout/stderr.\n        if (typeof shortCircuit === 'function') {\n            parseFn = shortCircuit;\n            shortCircuit = false;\n        }\n        // completion short-circuits the parsing process,\n        // skipping validation, etc.\n        if (!shortCircuit)\n            processArgs = args;\n        if (parseFn)\n            exitProcess = false;\n        const parsed = self._parseArgs(args, !!shortCircuit);\n        completion.setParsed(self.parsed);\n        if (parseFn)\n            parseFn(exitError, parsed, output);\n        unfreeze();\n        return parsed;\n    };\n    self._getParseContext = () => parseContext || {};\n    self._hasParseCallback = () => !!parseFn;\n    self.option = self.options = function option(key, opt) {\n        argsert_1.argsert('<string|object> [object]', [key, opt], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach((k) => {\n                self.options(k, key[k]);\n            });\n        }\n        else {\n            if (typeof opt !== 'object') {\n                opt = {};\n            }\n            options.key[key] = true; // track manually set keys.\n            if (opt.alias)\n                self.alias(key, opt.alias);\n            const deprecate = opt.deprecate || opt.deprecated;\n            if (deprecate) {\n                self.deprecateOption(key, deprecate);\n            }\n            const demand = opt.demand || opt.required || opt.require;\n            // A required option can be specified via \"demand: true\".\n            if (demand) {\n                self.demand(key, demand);\n            }\n            if (opt.demandOption) {\n                self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);\n            }\n            if (opt.conflicts) {\n                self.conflicts(key, opt.conflicts);\n            }\n            if ('default' in opt) {\n                self.default(key, opt.default);\n            }\n            if (opt.implies !== undefined) {\n                self.implies(key, opt.implies);\n            }\n            if (opt.nargs !== undefined) {\n                self.nargs(key, opt.nargs);\n            }\n            if (opt.config) {\n                self.config(key, opt.configParser);\n            }\n            if (opt.normalize) {\n                self.normalize(key);\n            }\n            if (opt.choices) {\n                self.choices(key, opt.choices);\n            }\n            if (opt.coerce) {\n                self.coerce(key, opt.coerce);\n            }\n            if (opt.group) {\n                self.group(key, opt.group);\n            }\n            if (opt.boolean || opt.type === 'boolean') {\n                self.boolean(key);\n                if (opt.alias)\n                    self.boolean(opt.alias);\n            }\n            if (opt.array || opt.type === 'array') {\n                self.array(key);\n                if (opt.alias)\n                    self.array(opt.alias);\n            }\n            if (opt.number || opt.type === 'number') {\n                self.number(key);\n                if (opt.alias)\n                    self.number(opt.alias);\n            }\n            if (opt.string || opt.type === 'string') {\n                self.string(key);\n                if (opt.alias)\n                    self.string(opt.alias);\n            }\n            if (opt.count || opt.type === 'count') {\n                self.count(key);\n            }\n            if (typeof opt.global === 'boolean') {\n                self.global(key, opt.global);\n            }\n            if (opt.defaultDescription) {\n                options.defaultDescription[key] = opt.defaultDescription;\n            }\n            if (opt.skipValidation) {\n                self.skipValidation(key);\n            }\n            const desc = opt.describe || opt.description || opt.desc;\n            self.describe(key, desc);\n            if (opt.hidden) {\n                self.hide(key);\n            }\n            if (opt.requiresArg) {\n                self.requiresArg(key);\n            }\n        }\n        return self;\n    };\n    self.getOptions = () => options;\n    self.positional = function (key, opts) {\n        argsert_1.argsert('<string> <object>', [key, opts], arguments.length);\n        if (context.resets === 0) {\n            throw new yerror_1.YError(\".positional() can only be called in a command's builder function\");\n        }\n        // .positional() only supports a subset of the configuration\n        // options available to .option().\n        const supportedOpts = ['default', 'defaultDescription', 'implies', 'normalize',\n            'choices', 'conflicts', 'coerce', 'type', 'describe',\n            'desc', 'description', 'alias'];\n        opts = obj_filter_1.objFilter(opts, (k, v) => {\n            let accept = supportedOpts.indexOf(k) !== -1;\n            // type can be one of string|number|boolean.\n            if (k === 'type' && ['string', 'number', 'boolean'].indexOf(v) === -1)\n                accept = false;\n            return accept;\n        });\n        // copy over any settings that can be inferred from the command string.\n        const fullCommand = context.fullCommands[context.fullCommands.length - 1];\n        const parseOptions = fullCommand ? command.cmdToParseOptions(fullCommand) : {\n            array: [],\n            alias: {},\n            default: {},\n            demand: {}\n        };\n        common_types_1.objectKeys(parseOptions).forEach((pk) => {\n            const parseOption = parseOptions[pk];\n            if (Array.isArray(parseOption)) {\n                if (parseOption.indexOf(key) !== -1)\n                    opts[pk] = true;\n            }\n            else {\n                if (parseOption[key] && !(pk in opts))\n                    opts[pk] = parseOption[key];\n            }\n        });\n        self.group(key, usage.getPositionalGroupName());\n        return self.option(key, opts);\n    };\n    self.group = function group(opts, groupName) {\n        argsert_1.argsert('<string|array> <string>', [opts, groupName], arguments.length);\n        const existing = preservedGroups[groupName] || groups[groupName];\n        if (preservedGroups[groupName]) {\n            // we now only need to track this group name in groups.\n            delete preservedGroups[groupName];\n        }\n        const seen = {};\n        groups[groupName] = (existing || []).concat(opts).filter((key) => {\n            if (seen[key])\n                return false;\n            return (seen[key] = true);\n        });\n        return self;\n    };\n    // combine explicit and preserved groups. explicit groups should be first\n    self.getGroups = () => Object.assign({}, groups, preservedGroups);\n    // as long as options.envPrefix is not undefined,\n    // parser will apply env vars matching prefix to argv\n    self.env = function (prefix) {\n        argsert_1.argsert('[string|boolean]', [prefix], arguments.length);\n        if (prefix === false)\n            delete options.envPrefix;\n        else\n            options.envPrefix = prefix || '';\n        return self;\n    };\n    self.wrap = function (cols) {\n        argsert_1.argsert('<number|null|undefined>', [cols], arguments.length);\n        usage.wrap(cols);\n        return self;\n    };\n    let strict = false;\n    self.strict = function (enabled) {\n        argsert_1.argsert('[boolean]', [enabled], arguments.length);\n        strict = enabled !== false;\n        return self;\n    };\n    self.getStrict = () => strict;\n    let strictCommands = false;\n    self.strictCommands = function (enabled) {\n        argsert_1.argsert('[boolean]', [enabled], arguments.length);\n        strictCommands = enabled !== false;\n        return self;\n    };\n    self.getStrictCommands = () => strictCommands;\n    let parserConfig = {};\n    self.parserConfiguration = function parserConfiguration(config) {\n        argsert_1.argsert('<object>', [config], arguments.length);\n        parserConfig = config;\n        return self;\n    };\n    self.getParserConfiguration = () => parserConfig;\n    self.showHelp = function (level) {\n        argsert_1.argsert('[string|function]', [level], arguments.length);\n        if (!self.parsed)\n            self._parseArgs(processArgs); // run parser, if it has not already been executed.\n        if (command.hasDefaultCommand()) {\n            context.resets++; // override the restriction on top-level positoinals.\n            command.runDefaultBuilderOn(self);\n        }\n        usage.showHelp(level);\n        return self;\n    };\n    let versionOpt = null;\n    self.version = function version(opt, msg, ver) {\n        const defaultVersionOpt = 'version';\n        argsert_1.argsert('[boolean|string] [string] [string]', [opt, msg, ver], arguments.length);\n        // nuke the key previously configured\n        // to return version #.\n        if (versionOpt) {\n            deleteFromParserHintObject(versionOpt);\n            usage.version(undefined);\n            versionOpt = null;\n        }\n        if (arguments.length === 0) {\n            ver = guessVersion();\n            opt = defaultVersionOpt;\n        }\n        else if (arguments.length === 1) {\n            if (opt === false) { // disable default 'version' key.\n                return self;\n            }\n            ver = opt;\n            opt = defaultVersionOpt;\n        }\n        else if (arguments.length === 2) {\n            ver = msg;\n            msg = undefined;\n        }\n        versionOpt = typeof opt === 'string' ? opt : defaultVersionOpt;\n        msg = msg || usage.deferY18nLookup('Show version number');\n        usage.version(ver || undefined);\n        self.boolean(versionOpt);\n        self.describe(versionOpt, msg);\n        return self;\n    };\n    function guessVersion() {\n        const obj = pkgUp();\n        return obj.version || 'unknown';\n    }\n    let helpOpt = null;\n    self.addHelpOpt = self.help = function addHelpOpt(opt, msg) {\n        const defaultHelpOpt = 'help';\n        argsert_1.argsert('[string|boolean] [string]', [opt, msg], arguments.length);\n        // nuke the key previously configured\n        // to return help.\n        if (helpOpt) {\n            deleteFromParserHintObject(helpOpt);\n            helpOpt = null;\n        }\n        if (arguments.length === 1) {\n            if (opt === false)\n                return self;\n        }\n        // use arguments, fallback to defaults for opt and msg\n        helpOpt = typeof opt === 'string' ? opt : defaultHelpOpt;\n        self.boolean(helpOpt);\n        self.describe(helpOpt, msg || usage.deferY18nLookup('Show help'));\n        return self;\n    };\n    const defaultShowHiddenOpt = 'show-hidden';\n    options.showHiddenOpt = defaultShowHiddenOpt;\n    self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt(opt, msg) {\n        argsert_1.argsert('[string|boolean] [string]', [opt, msg], arguments.length);\n        if (arguments.length === 1) {\n            if (opt === false)\n                return self;\n        }\n        const showHiddenOpt = typeof opt === 'string' ? opt : defaultShowHiddenOpt;\n        self.boolean(showHiddenOpt);\n        self.describe(showHiddenOpt, msg || usage.deferY18nLookup('Show hidden options'));\n        options.showHiddenOpt = showHiddenOpt;\n        return self;\n    };\n    self.hide = function hide(key) {\n        argsert_1.argsert('<string>', [key], arguments.length);\n        options.hiddenOptions.push(key);\n        return self;\n    };\n    self.showHelpOnFail = function showHelpOnFail(enabled, message) {\n        argsert_1.argsert('[boolean|string] [string]', [enabled, message], arguments.length);\n        usage.showHelpOnFail(enabled, message);\n        return self;\n    };\n    var exitProcess = true;\n    self.exitProcess = function (enabled = true) {\n        argsert_1.argsert('[boolean]', [enabled], arguments.length);\n        exitProcess = enabled;\n        return self;\n    };\n    self.getExitProcess = () => exitProcess;\n    var completionCommand = null;\n    self.completion = function (cmd, desc, fn) {\n        argsert_1.argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length);\n        // a function to execute when generating\n        // completions can be provided as the second\n        // or third argument to completion.\n        if (typeof desc === 'function') {\n            fn = desc;\n            desc = undefined;\n        }\n        // register the completion command.\n        completionCommand = cmd || completionCommand || 'completion';\n        if (!desc && desc !== false) {\n            desc = 'generate completion script';\n        }\n        self.command(completionCommand, desc);\n        // a function can be provided\n        if (fn)\n            completion.registerFunction(fn);\n        return self;\n    };\n    self.showCompletionScript = function ($0, cmd) {\n        argsert_1.argsert('[string] [string]', [$0, cmd], arguments.length);\n        $0 = $0 || self.$0;\n        _logger.log(completion.generateCompletionScript($0, cmd || completionCommand || 'completion'));\n        return self;\n    };\n    self.getCompletion = function (args, done) {\n        argsert_1.argsert('<array> <function>', [args, done], arguments.length);\n        completion.getCompletion(args, done);\n    };\n    self.locale = function (locale) {\n        argsert_1.argsert('[string]', [locale], arguments.length);\n        if (!locale) {\n            guessLocale();\n            return y18n.getLocale();\n        }\n        detectLocale = false;\n        y18n.setLocale(locale);\n        return self;\n    };\n    self.updateStrings = self.updateLocale = function (obj) {\n        argsert_1.argsert('<object>', [obj], arguments.length);\n        detectLocale = false;\n        y18n.updateLocale(obj);\n        return self;\n    };\n    let detectLocale = true;\n    self.detectLocale = function (detect) {\n        argsert_1.argsert('<boolean>', [detect], arguments.length);\n        detectLocale = detect;\n        return self;\n    };\n    self.getDetectLocale = () => detectLocale;\n    var hasOutput = false;\n    var exitError = null;\n    // maybe exit, always capture\n    // context about why we wanted to exit.\n    self.exit = (code, err) => {\n        hasOutput = true;\n        exitError = err;\n        if (exitProcess)\n            process.exit(code);\n    };\n    // we use a custom logger that buffers output,\n    // so that we can print to non-CLIs, e.g., chat-bots.\n    const _logger = {\n        log(...args) {\n            if (!self._hasParseCallback())\n                console.log(...args);\n            hasOutput = true;\n            if (output.length)\n                output += '\\n';\n            output += args.join(' ');\n        },\n        error(...args) {\n            if (!self._hasParseCallback())\n                console.error(...args);\n            hasOutput = true;\n            if (output.length)\n                output += '\\n';\n            output += args.join(' ');\n        }\n    };\n    self._getLoggerInstance = () => _logger;\n    // has yargs output an error our help\n    // message in the current execution context.\n    self._hasOutput = () => hasOutput;\n    self._setHasOutput = () => {\n        hasOutput = true;\n    };\n    let recommendCommands;\n    self.recommendCommands = function (recommend = true) {\n        argsert_1.argsert('[boolean]', [recommend], arguments.length);\n        recommendCommands = recommend;\n        return self;\n    };\n    self.getUsageInstance = () => usage;\n    self.getValidationInstance = () => validation;\n    self.getCommandInstance = () => command;\n    self.terminalWidth = () => {\n        argsert_1.argsert([], 0);\n        return typeof process.stdout.columns !== 'undefined' ? process.stdout.columns : null;\n    };\n    Object.defineProperty(self, 'argv', {\n        get: () => self._parseArgs(processArgs),\n        enumerable: true\n    });\n    self._parseArgs = function parseArgs(args, shortCircuit, _calledFromCommand, commandIndex) {\n        let skipValidation = !!_calledFromCommand;\n        args = args || processArgs;\n        options.__ = y18n.__;\n        options.configuration = self.getParserConfiguration();\n        const populateDoubleDash = !!options.configuration['populate--'];\n        const config = Object.assign({}, options.configuration, {\n            'populate--': true\n        });\n        const parsed = Parser.detailed(args, Object.assign({}, options, {\n            configuration: config\n        }));\n        let argv = parsed.argv;\n        if (parseContext)\n            argv = Object.assign({}, argv, parseContext);\n        const aliases = parsed.aliases;\n        argv.$0 = self.$0;\n        self.parsed = parsed;\n        try {\n            guessLocale(); // guess locale lazily, so that it can be turned off in chain.\n            // while building up the argv object, there\n            // are two passes through the parser. If completion\n            // is being performed short-circuit on the first pass.\n            if (shortCircuit) {\n                return (populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);\n            }\n            // if there's a handler associated with a\n            // command defer processing to it.\n            if (helpOpt) {\n                // consider any multi-char helpOpt alias as a valid help command\n                // unless all helpOpt aliases are single-char\n                // note that parsed.aliases is a normalized bidirectional map :)\n                const helpCmds = [helpOpt]\n                    .concat(aliases[helpOpt] || [])\n                    .filter(k => k.length > 1);\n                // check if help should trigger and strip it from _.\n                if (~helpCmds.indexOf(argv._[argv._.length - 1])) {\n                    argv._.pop();\n                    argv[helpOpt] = true;\n                }\n            }\n            const handlerKeys = command.getCommands();\n            const requestCompletions = completion.completionKey in argv;\n            const skipRecommendation = argv[helpOpt] || requestCompletions;\n            const skipDefaultCommand = skipRecommendation && (handlerKeys.length > 1 || handlerKeys[0] !== '$0');\n            if (argv._.length) {\n                if (handlerKeys.length) {\n                    let firstUnknownCommand;\n                    for (let i = (commandIndex || 0), cmd; argv._[i] !== undefined; i++) {\n                        cmd = String(argv._[i]);\n                        if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {\n                            // commands are executed using a recursive algorithm that executes\n                            // the deepest command first; we keep track of the position in the\n                            // argv._ array that is currently being executed.\n                            const innerArgv = command.runCommand(cmd, self, parsed, i + 1);\n                            return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);\n                        }\n                        else if (!firstUnknownCommand && cmd !== completionCommand) {\n                            firstUnknownCommand = cmd;\n                            break;\n                        }\n                    }\n                    // run the default command, if defined\n                    if (command.hasDefaultCommand() && !skipDefaultCommand) {\n                        const innerArgv = command.runCommand(null, self, parsed);\n                        return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);\n                    }\n                    // recommend a command if recommendCommands() has\n                    // been enabled, and no commands were found to execute\n                    if (recommendCommands && firstUnknownCommand && !skipRecommendation) {\n                        validation.recommendCommands(firstUnknownCommand, handlerKeys);\n                    }\n                }\n                // generate a completion script for adding to ~/.bashrc.\n                if (completionCommand && ~argv._.indexOf(completionCommand) && !requestCompletions) {\n                    if (exitProcess)\n                        setBlocking(true);\n                    self.showCompletionScript();\n                    self.exit(0);\n                }\n            }\n            else if (command.hasDefaultCommand() && !skipDefaultCommand) {\n                const innerArgv = command.runCommand(null, self, parsed);\n                return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);\n            }\n            // we must run completions first, a user might\n            // want to complete the --help or --version option.\n            if (requestCompletions) {\n                if (exitProcess)\n                    setBlocking(true);\n                // we allow for asynchronous completions,\n                // e.g., loading in a list of commands from an API.\n                args = [].concat(args);\n                const completionArgs = args.slice(args.indexOf(`--${completion.completionKey}`) + 1);\n                completion.getCompletion(completionArgs, (completions) => {\n                    ;\n                    (completions || []).forEach((completion) => {\n                        _logger.log(completion);\n                    });\n                    self.exit(0);\n                });\n                return (populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);\n            }\n            // Handle 'help' and 'version' options\n            // if we haven't already output help!\n            if (!hasOutput) {\n                Object.keys(argv).forEach((key) => {\n                    if (key === helpOpt && argv[key]) {\n                        if (exitProcess)\n                            setBlocking(true);\n                        skipValidation = true;\n                        self.showHelp('log');\n                        self.exit(0);\n                    }\n                    else if (key === versionOpt && argv[key]) {\n                        if (exitProcess)\n                            setBlocking(true);\n                        skipValidation = true;\n                        usage.showVersion();\n                        self.exit(0);\n                    }\n                });\n            }\n            // Check if any of the options to skip validation were provided\n            if (!skipValidation && options.skipValidation.length > 0) {\n                skipValidation = Object.keys(argv).some(key => options.skipValidation.indexOf(key) >= 0 && argv[key] === true);\n            }\n            // If the help or version options where used and exitProcess is false,\n            // or if explicitly skipped, we won't run validations.\n            if (!skipValidation) {\n                if (parsed.error)\n                    throw new yerror_1.YError(parsed.error.message);\n                // if we're executed via bash completion, don't\n                // bother with validation.\n                if (!requestCompletions) {\n                    self._runValidation(argv, aliases, {}, parsed.error);\n                }\n            }\n        }\n        catch (err) {\n            if (err instanceof yerror_1.YError)\n                usage.fail(err.message, err);\n            else\n                throw err;\n        }\n        return (populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);\n    };\n    // to simplify the parsing of positionals in commands,\n    // we temporarily populate '--' rather than _, with arguments\n    // after the '--' directive. After the parse, we copy these back.\n    self._copyDoubleDash = function (argv) {\n        if (is_promise_1.isPromise(argv) || !argv._ || !argv['--'])\n            return argv;\n        argv._.push.apply(argv._, argv['--']);\n        // TODO(bcoe): refactor command parsing such that this delete is not\n        // necessary: https://github.com/yargs/yargs/issues/1482\n        try {\n            delete argv['--'];\n        }\n        catch (_err) { }\n        return argv;\n    };\n    self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors, isDefaultCommand = false) {\n        if (parseErrors)\n            throw new yerror_1.YError(parseErrors.message);\n        validation.nonOptionCount(argv);\n        validation.requiredArguments(argv);\n        let failedStrictCommands = false;\n        if (strictCommands) {\n            failedStrictCommands = validation.unknownCommands(argv);\n        }\n        if (strict && !failedStrictCommands) {\n            validation.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);\n        }\n        validation.customChecks(argv, aliases);\n        validation.limitedChoices(argv);\n        validation.implications(argv);\n        validation.conflicting(argv);\n    };\n    function guessLocale() {\n        if (!detectLocale)\n            return;\n        const locale = process.env.LC_ALL || process.env.LC_MESSAGES || process.env.LANG || process.env.LANGUAGE || 'en_US';\n        self.locale(locale.replace(/[.:].*/, ''));\n    }\n    // an app should almost always have --version and --help,\n    // if you *really* want to disable this use .help(false)/.version(false).\n    self.help();\n    self.version();\n    return self;\n}\nexports.Yargs = Yargs;\n// rebase an absolute path to a relative one with respect to a base directory\n// exported for tests\nfunction rebase(base, dir) {\n    return path.relative(base, dir);\n}\nexports.rebase = rebase;\nfunction isYargsInstance(y) {\n    return !!y && (typeof y._parseArgs === 'function');\n}\nexports.isYargsInstance = isYargsInstance;\n\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliL3lhcmdzLmpzP2RkNTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaURBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLEVBQVc7QUFDckMsdUJBQXVCLG1CQUFPLENBQUMsQ0FBZ0I7QUFDL0MsaUJBQWlCLG1CQUFPLENBQUMsQ0FBVTtBQUNuQyxnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFTO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLEVBQVc7QUFDckMsV0FBVyxtQkFBTyxDQUFDLENBQUk7QUFDdkIscUJBQXFCLG1CQUFPLENBQUMsRUFBYztBQUMzQyxhQUFhLG1CQUFPLENBQUMsQ0FBTTtBQUMzQixxQkFBcUIsbUJBQU8sQ0FBQyxFQUFjO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLEVBQWM7QUFDM0Msd0JBQXdCLG1CQUFPLENBQUMsRUFBaUI7QUFDakQscUJBQXFCLG1CQUFPLENBQUMsRUFBYztBQUMzQyxvQkFBb0IsbUJBQU8sQ0FBQyxFQUFnQjtBQUM1QyxxQkFBcUIsbUJBQU8sQ0FBQyxDQUFjO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxFQUFjO0FBQ3JDLG9CQUFvQixtQkFBTyxDQUFDLEVBQU07QUFDbEMsb0JBQW9CLG1CQUFPLENBQUMsRUFBYztBQUMxQyxlQUFlLG1CQUFPLENBQUMsRUFBUztBQUNoQyw0QkFBNEIsbUJBQU8sQ0FBQyxFQUF1QjtBQUMzRCxzRUFBc0Usc0JBQU87QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJDQUEyQywrQkFBK0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNCQUFPO0FBQzVDLDBEQUEwRCxtQkFBTyxDQUFDLEVBQWlCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLFNBQVM7QUFDVCw2REFBNkQ7QUFDN0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx5QkFBeUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLHlCQUF5QjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzWWFyZ3NJbnN0YW5jZSA9IGV4cG9ydHMucmViYXNlID0gZXhwb3J0cy5ZYXJncyA9IHZvaWQgMDtcbmNvbnN0IGNvbW1hbmRfMSA9IHJlcXVpcmUoXCIuL2NvbW1hbmRcIik7XG5jb25zdCBjb21tb25fdHlwZXNfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi10eXBlc1wiKTtcbmNvbnN0IHllcnJvcl8xID0gcmVxdWlyZShcIi4veWVycm9yXCIpO1xuY29uc3QgdXNhZ2VfMSA9IHJlcXVpcmUoXCIuL3VzYWdlXCIpO1xuY29uc3QgYXJnc2VydF8xID0gcmVxdWlyZShcIi4vYXJnc2VydFwiKTtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgY29tcGxldGlvbl8xID0gcmVxdWlyZShcIi4vY29tcGxldGlvblwiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IHZhbGlkYXRpb25fMSA9IHJlcXVpcmUoXCIuL3ZhbGlkYXRpb25cIik7XG5jb25zdCBvYmpfZmlsdGVyXzEgPSByZXF1aXJlKFwiLi9vYmotZmlsdGVyXCIpO1xuY29uc3QgYXBwbHlfZXh0ZW5kc18xID0gcmVxdWlyZShcIi4vYXBwbHktZXh0ZW5kc1wiKTtcbmNvbnN0IG1pZGRsZXdhcmVfMSA9IHJlcXVpcmUoXCIuL21pZGRsZXdhcmVcIik7XG5jb25zdCBwcm9jZXNzQXJndiA9IHJlcXVpcmUoXCIuL3Byb2Nlc3MtYXJndlwiKTtcbmNvbnN0IGlzX3Byb21pc2VfMSA9IHJlcXVpcmUoXCIuL2lzLXByb21pc2VcIik7XG5jb25zdCBQYXJzZXIgPSByZXF1aXJlKFwieWFyZ3MtcGFyc2VyXCIpO1xuY29uc3QgeTE4bkZhY3RvcnkgPSByZXF1aXJlKFwieTE4blwiKTtcbmNvbnN0IHNldEJsb2NraW5nID0gcmVxdWlyZShcInNldC1ibG9ja2luZ1wiKTtcbmNvbnN0IGZpbmRVcCA9IHJlcXVpcmUoXCJmaW5kLXVwXCIpO1xuY29uc3QgcmVxdWlyZU1haW5GaWxlbmFtZSA9IHJlcXVpcmUoXCJyZXF1aXJlLW1haW4tZmlsZW5hbWVcIik7XG5mdW5jdGlvbiBZYXJncyhwcm9jZXNzQXJncyA9IFtdLCBjd2QgPSBwcm9jZXNzLmN3ZCgpLCBwYXJlbnRSZXF1aXJlID0gcmVxdWlyZSkge1xuICAgIGNvbnN0IHNlbGYgPSB7fTtcbiAgICBsZXQgY29tbWFuZDtcbiAgICBsZXQgY29tcGxldGlvbiA9IG51bGw7XG4gICAgbGV0IGdyb3VwcyA9IHt9O1xuICAgIGNvbnN0IGdsb2JhbE1pZGRsZXdhcmUgPSBbXTtcbiAgICBsZXQgb3V0cHV0ID0gJyc7XG4gICAgY29uc3QgcHJlc2VydmVkR3JvdXBzID0ge307XG4gICAgbGV0IHVzYWdlO1xuICAgIGxldCB2YWxpZGF0aW9uO1xuICAgIGxldCBoYW5kbGVyRmluaXNoQ29tbWFuZCA9IG51bGw7XG4gICAgY29uc3QgeTE4biA9IHkxOG5GYWN0b3J5KHtcbiAgICAgICAgZGlyZWN0b3J5OiBwYXRoLnJlc29sdmUoX19kaXJuYW1lLCAnLi4vLi4vbG9jYWxlcycpLFxuICAgICAgICB1cGRhdGVGaWxlczogZmFsc2VcbiAgICB9KTtcbiAgICBzZWxmLm1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlXzEuZ2xvYmFsTWlkZGxld2FyZUZhY3RvcnkoZ2xvYmFsTWlkZGxld2FyZSwgc2VsZik7XG4gICAgc2VsZi5zY3JpcHROYW1lID0gZnVuY3Rpb24gKHNjcmlwdE5hbWUpIHtcbiAgICAgICAgc2VsZi5jdXN0b21TY3JpcHROYW1lID0gdHJ1ZTtcbiAgICAgICAgc2VsZi4kMCA9IHNjcmlwdE5hbWU7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgLy8gaWdub3JlIHRoZSBub2RlIGJpbiwgc3BlY2lmeSB0aGlzIGluIHlvdXJcbiAgICAvLyBiaW4gZmlsZSB3aXRoICMhL3Vzci9iaW4vZW52IG5vZGVcbiAgICBsZXQgZGVmYXVsdCQwO1xuICAgIGlmICgvXFxiKG5vZGV8aW9qc3xlbGVjdHJvbikoXFwuZXhlKT8kLy50ZXN0KHByb2Nlc3MuYXJndlswXSkpIHtcbiAgICAgICAgZGVmYXVsdCQwID0gcHJvY2Vzcy5hcmd2LnNsaWNlKDEsIDIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVmYXVsdCQwID0gcHJvY2Vzcy5hcmd2LnNsaWNlKDAsIDEpO1xuICAgIH1cbiAgICBzZWxmLiQwID0gZGVmYXVsdCQwXG4gICAgICAgIC5tYXAoeCA9PiB7XG4gICAgICAgIGNvbnN0IGIgPSByZWJhc2UoY3dkLCB4KTtcbiAgICAgICAgcmV0dXJuIHgubWF0Y2goL14oXFwvfChbYS16QS1aXTopP1xcXFwpLykgJiYgYi5sZW5ndGggPCB4Lmxlbmd0aCA/IGIgOiB4O1xuICAgIH0pXG4gICAgICAgIC5qb2luKCcgJykudHJpbSgpO1xuICAgIGlmIChwcm9jZXNzLmVudi5fICE9PSB1bmRlZmluZWQgJiYgcHJvY2Vzc0FyZ3YuZ2V0UHJvY2Vzc0FyZ3ZCaW4oKSA9PT0gcHJvY2Vzcy5lbnYuXykge1xuICAgICAgICBzZWxmLiQwID0gcHJvY2Vzcy5lbnYuXy5yZXBsYWNlKGAke3BhdGguZGlybmFtZShwcm9jZXNzLmV4ZWNQYXRoKX0vYCwgJycpO1xuICAgIH1cbiAgICAvLyB1c2UgY29udGV4dCBvYmplY3QgdG8ga2VlcCB0cmFjayBvZiByZXNldHMsIHN1YmNvbW1hbmQgZXhlY3V0aW9uLCBldGNcbiAgICAvLyBzdWJtb2R1bGVzIHNob3VsZCBtb2RpZnkgYW5kIGNoZWNrIHRoZSBzdGF0ZSBvZiBjb250ZXh0IGFzIG5lY2Vzc2FyeVxuICAgIGNvbnN0IGNvbnRleHQgPSB7IHJlc2V0czogLTEsIGNvbW1hbmRzOiBbXSwgZnVsbENvbW1hbmRzOiBbXSwgZmlsZXM6IFtdIH07XG4gICAgc2VsZi5nZXRDb250ZXh0ID0gKCkgPT4gY29udGV4dDtcbiAgICAvLyBwdXRzIHlhcmdzIGJhY2sgaW50byBhbiBpbml0aWFsIHN0YXRlLiBhbnkga2V5c1xuICAgIC8vIHRoYXQgaGF2ZSBiZWVuIHNldCB0byBcImdsb2JhbFwiIHdpbGwgbm90IGJlIHJlc2V0XG4gICAgLy8gYnkgdGhpcyBhY3Rpb24uXG4gICAgbGV0IG9wdGlvbnM7XG4gICAgc2VsZi5yZXNldE9wdGlvbnMgPSBzZWxmLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXRPcHRpb25zKGFsaWFzZXMgPSB7fSkge1xuICAgICAgICBjb250ZXh0LnJlc2V0cysrO1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgLy8gcHV0IHlhcmdzIGJhY2sgaW50byBhbiBpbml0aWFsIHN0YXRlLCB0aGlzXG4gICAgICAgIC8vIGxvZ2ljIGlzIHVzZWQgdG8gYnVpbGQgYSBuZXN0ZWQgY29tbWFuZFxuICAgICAgICAvLyBoaWVyYXJjaHkuXG4gICAgICAgIGNvbnN0IHRtcE9wdGlvbnMgPSB7fTtcbiAgICAgICAgdG1wT3B0aW9ucy5sb2NhbCA9IG9wdGlvbnMubG9jYWwgPyBvcHRpb25zLmxvY2FsIDogW107XG4gICAgICAgIHRtcE9wdGlvbnMuY29uZmlnT2JqZWN0cyA9IG9wdGlvbnMuY29uZmlnT2JqZWN0cyA/IG9wdGlvbnMuY29uZmlnT2JqZWN0cyA6IFtdO1xuICAgICAgICAvLyBpZiBhIGtleSBoYXMgYmVlbiBleHBsaWNpdGx5IHNldCBhcyBsb2NhbCxcbiAgICAgICAgLy8gd2Ugc2hvdWxkIHJlc2V0IGl0IGJlZm9yZSBwYXNzaW5nIG9wdGlvbnMgdG8gY29tbWFuZC5cbiAgICAgICAgY29uc3QgbG9jYWxMb29rdXAgPSB7fTtcbiAgICAgICAgdG1wT3B0aW9ucy5sb2NhbC5mb3JFYWNoKChsKSA9PiB7XG4gICAgICAgICAgICBsb2NhbExvb2t1cFtsXSA9IHRydWU7XG4gICAgICAgICAgICAoYWxpYXNlc1tsXSB8fCBbXSkuZm9yRWFjaCgoYSkgPT4ge1xuICAgICAgICAgICAgICAgIGxvY2FsTG9va3VwW2FdID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gYWRkIGFsbCBncm91cHMgbm90IHNldCB0byBsb2NhbCB0byBwcmVzZXJ2ZWQgZ3JvdXBzXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocHJlc2VydmVkR3JvdXBzLCBPYmplY3Qua2V5cyhncm91cHMpLnJlZHVjZSgoYWNjLCBncm91cE5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBncm91cHNbZ3JvdXBOYW1lXS5maWx0ZXIoa2V5ID0+ICEoa2V5IGluIGxvY2FsTG9va3VwKSk7XG4gICAgICAgICAgICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgYWNjW2dyb3VwTmFtZV0gPSBrZXlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSwge30pKTtcbiAgICAgICAgLy8gZ3JvdXBzIGNhbiBub3cgYmUgcmVzZXRcbiAgICAgICAgZ3JvdXBzID0ge307XG4gICAgICAgIGNvbnN0IGFycmF5T3B0aW9ucyA9IFtcbiAgICAgICAgICAgICdhcnJheScsICdib29sZWFuJywgJ3N0cmluZycsICdza2lwVmFsaWRhdGlvbicsXG4gICAgICAgICAgICAnY291bnQnLCAnbm9ybWFsaXplJywgJ251bWJlcicsXG4gICAgICAgICAgICAnaGlkZGVuT3B0aW9ucydcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3Qgb2JqZWN0T3B0aW9ucyA9IFtcbiAgICAgICAgICAgICduYXJnJywgJ2tleScsICdhbGlhcycsICdkZWZhdWx0JywgJ2RlZmF1bHREZXNjcmlwdGlvbicsXG4gICAgICAgICAgICAnY29uZmlnJywgJ2Nob2ljZXMnLCAnZGVtYW5kZWRPcHRpb25zJywgJ2RlbWFuZGVkQ29tbWFuZHMnLCAnY29lcmNlJyxcbiAgICAgICAgICAgICdkZXByZWNhdGVkT3B0aW9ucydcbiAgICAgICAgXTtcbiAgICAgICAgYXJyYXlPcHRpb25zLmZvckVhY2goayA9PiB7XG4gICAgICAgICAgICB0bXBPcHRpb25zW2tdID0gKG9wdGlvbnNba10gfHwgW10pLmZpbHRlcihrID0+ICFsb2NhbExvb2t1cFtrXSk7XG4gICAgICAgIH0pO1xuICAgICAgICBvYmplY3RPcHRpb25zLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgIHRtcE9wdGlvbnNba10gPSBvYmpfZmlsdGVyXzEub2JqRmlsdGVyKG9wdGlvbnNba10sIGsgPT4gIWxvY2FsTG9va3VwW2tdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRtcE9wdGlvbnMuZW52UHJlZml4ID0gb3B0aW9ucy5lbnZQcmVmaXg7XG4gICAgICAgIG9wdGlvbnMgPSB0bXBPcHRpb25zO1xuICAgICAgICAvLyBpZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIGJlaW5nIGV4ZWN1dGVkLCBjcmVhdGVcbiAgICAgICAgLy8gaW5zdGFuY2VzIG9mIGFsbCBvdXIgaGVscGVycyAtLSBvdGhlcndpc2UganVzdCByZXNldC5cbiAgICAgICAgdXNhZ2UgPSB1c2FnZSA/IHVzYWdlLnJlc2V0KGxvY2FsTG9va3VwKSA6IHVzYWdlXzEudXNhZ2Uoc2VsZiwgeTE4bik7XG4gICAgICAgIHZhbGlkYXRpb24gPSB2YWxpZGF0aW9uID8gdmFsaWRhdGlvbi5yZXNldChsb2NhbExvb2t1cCkgOiB2YWxpZGF0aW9uXzEudmFsaWRhdGlvbihzZWxmLCB1c2FnZSwgeTE4bik7XG4gICAgICAgIGNvbW1hbmQgPSBjb21tYW5kID8gY29tbWFuZC5yZXNldCgpIDogY29tbWFuZF8xLmNvbW1hbmQoc2VsZiwgdXNhZ2UsIHZhbGlkYXRpb24sIGdsb2JhbE1pZGRsZXdhcmUpO1xuICAgICAgICBpZiAoIWNvbXBsZXRpb24pXG4gICAgICAgICAgICBjb21wbGV0aW9uID0gY29tcGxldGlvbl8xLmNvbXBsZXRpb24oc2VsZiwgdXNhZ2UsIGNvbW1hbmQpO1xuICAgICAgICBjb21wbGV0aW9uQ29tbWFuZCA9IG51bGw7XG4gICAgICAgIG91dHB1dCA9ICcnO1xuICAgICAgICBleGl0RXJyb3IgPSBudWxsO1xuICAgICAgICBoYXNPdXRwdXQgPSBmYWxzZTtcbiAgICAgICAgc2VsZi5wYXJzZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLnJlc2V0T3B0aW9ucygpO1xuICAgIC8vIHRlbXBvcmFyeSBoYWNrOiBhbGxvdyBcImZyZWV6aW5nXCIgb2YgcmVzZXQtYWJsZSBzdGF0ZSBmb3IgcGFyc2UobXNnLCBjYilcbiAgICBjb25zdCBmcm96ZW5zID0gW107XG4gICAgZnVuY3Rpb24gZnJlZXplKCkge1xuICAgICAgICBmcm96ZW5zLnB1c2goe1xuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGNvbmZpZ09iamVjdHM6IG9wdGlvbnMuY29uZmlnT2JqZWN0cy5zbGljZSgwKSxcbiAgICAgICAgICAgIGV4aXRQcm9jZXNzLFxuICAgICAgICAgICAgZ3JvdXBzLFxuICAgICAgICAgICAgc3RyaWN0LFxuICAgICAgICAgICAgc3RyaWN0Q29tbWFuZHMsXG4gICAgICAgICAgICBjb21wbGV0aW9uQ29tbWFuZCxcbiAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgICAgIGV4aXRFcnJvcixcbiAgICAgICAgICAgIGhhc091dHB1dCxcbiAgICAgICAgICAgIHBhcnNlZDogc2VsZi5wYXJzZWQsXG4gICAgICAgICAgICBwYXJzZUZuLFxuICAgICAgICAgICAgcGFyc2VDb250ZXh0LFxuICAgICAgICAgICAgaGFuZGxlckZpbmlzaENvbW1hbmRcbiAgICAgICAgfSk7XG4gICAgICAgIHVzYWdlLmZyZWV6ZSgpO1xuICAgICAgICB2YWxpZGF0aW9uLmZyZWV6ZSgpO1xuICAgICAgICBjb21tYW5kLmZyZWV6ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1bmZyZWV6ZSgpIHtcbiAgICAgICAgY29uc3QgZnJvemVuID0gZnJvemVucy5wb3AoKTtcbiAgICAgICAgY29tbW9uX3R5cGVzXzEuYXNzZXJ0Tm90U3RyaWN0RXF1YWwoZnJvemVuLCB1bmRlZmluZWQpO1xuICAgICAgICBsZXQgY29uZmlnT2JqZWN0cztcbiAgICAgICAgKHtcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBjb25maWdPYmplY3RzLFxuICAgICAgICAgICAgZXhpdFByb2Nlc3MsXG4gICAgICAgICAgICBncm91cHMsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgICAgICBleGl0RXJyb3IsXG4gICAgICAgICAgICBoYXNPdXRwdXQsXG4gICAgICAgICAgICBwYXJzZWQ6IHNlbGYucGFyc2VkLFxuICAgICAgICAgICAgc3RyaWN0LFxuICAgICAgICAgICAgc3RyaWN0Q29tbWFuZHMsXG4gICAgICAgICAgICBjb21wbGV0aW9uQ29tbWFuZCxcbiAgICAgICAgICAgIHBhcnNlRm4sXG4gICAgICAgICAgICBwYXJzZUNvbnRleHQsXG4gICAgICAgICAgICBoYW5kbGVyRmluaXNoQ29tbWFuZFxuICAgICAgICB9ID0gZnJvemVuKTtcbiAgICAgICAgb3B0aW9ucy5jb25maWdPYmplY3RzID0gY29uZmlnT2JqZWN0cztcbiAgICAgICAgdXNhZ2UudW5mcmVlemUoKTtcbiAgICAgICAgdmFsaWRhdGlvbi51bmZyZWV6ZSgpO1xuICAgICAgICBjb21tYW5kLnVuZnJlZXplKCk7XG4gICAgfVxuICAgIHNlbGYuYm9vbGVhbiA9IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCc8YXJyYXl8c3RyaW5nPicsIFtrZXlzXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHBvcHVsYXRlUGFyc2VySGludEFycmF5KCdib29sZWFuJywga2V5cyk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5hcnJheSA9IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCc8YXJyYXl8c3RyaW5nPicsIFtrZXlzXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHBvcHVsYXRlUGFyc2VySGludEFycmF5KCdhcnJheScsIGtleXMpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYubnVtYmVyID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoJzxhcnJheXxzdHJpbmc+JywgW2tleXNdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcG9wdWxhdGVQYXJzZXJIaW50QXJyYXkoJ251bWJlcicsIGtleXMpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYubm9ybWFsaXplID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoJzxhcnJheXxzdHJpbmc+JywgW2tleXNdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcG9wdWxhdGVQYXJzZXJIaW50QXJyYXkoJ25vcm1hbGl6ZScsIGtleXMpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYuY291bnQgPSBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnPGFycmF5fHN0cmluZz4nLCBba2V5c10sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBwb3B1bGF0ZVBhcnNlckhpbnRBcnJheSgnY291bnQnLCBrZXlzKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLnN0cmluZyA9IGZ1bmN0aW9uIChrZXlzKSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCc8YXJyYXl8c3RyaW5nPicsIFtrZXlzXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHBvcHVsYXRlUGFyc2VySGludEFycmF5KCdzdHJpbmcnLCBrZXlzKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLnJlcXVpcmVzQXJnID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgLy8gdGhlIDJuZCBwYXJhbXRlciBbbnVtYmVyXSBpbiB0aGUgYXJnc2VydCB0aGUgYXNzZXJ0aW9uIGlzIG1hbmRhdG9yeVxuICAgICAgICAvLyBhcyBwb3B1bGF0ZVBhcnNlckhpbnRTaW5nbGVWYWx1ZURpY3Rpb25hcnkgcmVjdXJzaXZlbHkgY2FsbHMgcmVxdWlyZXNBcmdcbiAgICAgICAgLy8gd2l0aCBOYW4gYXMgYSAybmQgcGFyYW1ldGVyLCBhbHRob3VnaCB3ZSBpZ25vcmUgaXRcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoJzxhcnJheXxzdHJpbmd8b2JqZWN0PiBbbnVtYmVyXScsIFtrZXlzXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIC8vIElmIHNvbWVvbmUgY29uZmlndXJlcyBuYXJncyBhdCB0aGUgc2FtZSB0aW1lIGFzIHJlcXVpcmVzQXJnLFxuICAgICAgICAvLyBuYXJncyBzaG91bGQgdGFrZSBwcmVjZWRlbnQsXG4gICAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3lhcmdzL3lhcmdzL3B1bGwvMTU3MlxuICAgICAgICAvLyBUT0RPOiBtYWtlIHRoaXMgd29yayB3aXRoIGFsaWFzZXMsIHVzaW5nIGEgY2hlY2sgc2ltaWxhciB0b1xuICAgICAgICAvLyBjaGVja0FsbEFsaWFzZXMoKSBpbiB5YXJncy1wYXJzZXIuXG4gICAgICAgIGlmICh0eXBlb2Yga2V5cyA9PT0gJ3N0cmluZycgJiYgb3B0aW9ucy5uYXJnW2tleXNdKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvcHVsYXRlUGFyc2VySGludFNpbmdsZVZhbHVlRGljdGlvbmFyeShzZWxmLnJlcXVpcmVzQXJnLCAnbmFyZycsIGtleXMsIE5hTik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLnNraXBWYWxpZGF0aW9uID0gZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoJzxhcnJheXxzdHJpbmc+JywgW2tleXNdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcG9wdWxhdGVQYXJzZXJIaW50QXJyYXkoJ3NraXBWYWxpZGF0aW9uJywga2V5cyk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgZnVuY3Rpb24gcG9wdWxhdGVQYXJzZXJIaW50QXJyYXkodHlwZSwga2V5cykge1xuICAgICAgICBrZXlzID0gW10uY29uY2F0KGtleXMpO1xuICAgICAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAga2V5ID0gc2FuaXRpemVLZXkoa2V5KTtcbiAgICAgICAgICAgIG9wdGlvbnNbdHlwZV0ucHVzaChrZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VsZi5uYXJncyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCc8c3RyaW5nfG9iamVjdHxhcnJheT4gW251bWJlcl0nLCBba2V5LCB2YWx1ZV0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBwb3B1bGF0ZVBhcnNlckhpbnRTaW5nbGVWYWx1ZURpY3Rpb25hcnkoc2VsZi5uYXJncywgJ25hcmcnLCBrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmNob2ljZXMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnPG9iamVjdHxzdHJpbmd8YXJyYXk+IFtzdHJpbmd8YXJyYXldJywgW2tleSwgdmFsdWVdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcG9wdWxhdGVQYXJzZXJIaW50QXJyYXlEaWN0aW9uYXJ5KHNlbGYuY2hvaWNlcywgJ2Nob2ljZXMnLCBrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmFsaWFzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoJzxvYmplY3R8c3RyaW5nfGFycmF5PiBbc3RyaW5nfGFycmF5XScsIFtrZXksIHZhbHVlXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHBvcHVsYXRlUGFyc2VySGludEFycmF5RGljdGlvbmFyeShzZWxmLmFsaWFzLCAnYWxpYXMnLCBrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBhY3R1YWxseSBkZXByZWNhdGUgc2VsZi5kZWZhdWx0cy5cbiAgICBzZWxmLmRlZmF1bHQgPSBzZWxmLmRlZmF1bHRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGRlZmF1bHREZXNjcmlwdGlvbikge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnPG9iamVjdHxzdHJpbmd8YXJyYXk+IFsqXSBbc3RyaW5nXScsIFtrZXksIHZhbHVlLCBkZWZhdWx0RGVzY3JpcHRpb25dLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgaWYgKGRlZmF1bHREZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgY29tbW9uX3R5cGVzXzEuYXNzZXJ0U2luZ2xlS2V5KGtleSk7XG4gICAgICAgICAgICBvcHRpb25zLmRlZmF1bHREZXNjcmlwdGlvbltrZXldID0gZGVmYXVsdERlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbW1vbl90eXBlc18xLmFzc2VydFNpbmdsZUtleShrZXkpO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmRlZmF1bHREZXNjcmlwdGlvbltrZXldKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdERlc2NyaXB0aW9uW2tleV0gPSB1c2FnZS5mdW5jdGlvbkRlc2NyaXB0aW9uKHZhbHVlKTtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2FsbCgpO1xuICAgICAgICB9XG4gICAgICAgIHBvcHVsYXRlUGFyc2VySGludFNpbmdsZVZhbHVlRGljdGlvbmFyeShzZWxmLmRlZmF1bHQsICdkZWZhdWx0Jywga2V5LCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5kZXNjcmliZSA9IGZ1bmN0aW9uIChrZXksIGRlc2MpIHtcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoJzxvYmplY3R8c3RyaW5nfGFycmF5PiBbc3RyaW5nXScsIFtrZXksIGRlc2NdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgc2V0S2V5KGtleSwgdHJ1ZSk7XG4gICAgICAgIHVzYWdlLmRlc2NyaWJlKGtleSwgZGVzYyk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgZnVuY3Rpb24gc2V0S2V5KGtleSwgc2V0KSB7XG4gICAgICAgIHBvcHVsYXRlUGFyc2VySGludFNpbmdsZVZhbHVlRGljdGlvbmFyeShzZXRLZXksICdrZXknLCBrZXksIHNldCk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZW1hbmRPcHRpb24oa2V5cywgbXNnKSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCc8b2JqZWN0fHN0cmluZ3xhcnJheT4gW3N0cmluZ10nLCBba2V5cywgbXNnXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHBvcHVsYXRlUGFyc2VySGludFNpbmdsZVZhbHVlRGljdGlvbmFyeShzZWxmLmRlbWFuZE9wdGlvbiwgJ2RlbWFuZGVkT3B0aW9ucycsIGtleXMsIG1zZyk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cbiAgICBzZWxmLmRlbWFuZE9wdGlvbiA9IGRlbWFuZE9wdGlvbjtcbiAgICBzZWxmLmNvZXJjZSA9IGZ1bmN0aW9uIChrZXlzLCB2YWx1ZSkge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnPG9iamVjdHxzdHJpbmd8YXJyYXk+IFtmdW5jdGlvbl0nLCBba2V5cywgdmFsdWVdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcG9wdWxhdGVQYXJzZXJIaW50U2luZ2xlVmFsdWVEaWN0aW9uYXJ5KHNlbGYuY29lcmNlLCAnY29lcmNlJywga2V5cywgdmFsdWUpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBvcHVsYXRlUGFyc2VySGludFNpbmdsZVZhbHVlRGljdGlvbmFyeShidWlsZGVyLCB0eXBlLCBrZXksIHZhbHVlKSB7XG4gICAgICAgIHBvcHVsYXRlUGFyc2VySGludERpY3Rpb25hcnkoYnVpbGRlciwgdHlwZSwga2V5LCB2YWx1ZSwgKHR5cGUsIGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIG9wdGlvbnNbdHlwZV1ba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wdWxhdGVQYXJzZXJIaW50QXJyYXlEaWN0aW9uYXJ5KGJ1aWxkZXIsIHR5cGUsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgcG9wdWxhdGVQYXJzZXJIaW50RGljdGlvbmFyeShidWlsZGVyLCB0eXBlLCBrZXksIHZhbHVlLCAodHlwZSwga2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgb3B0aW9uc1t0eXBlXVtrZXldID0gKG9wdGlvbnNbdHlwZV1ba2V5XSB8fCBbXSkuY29uY2F0KHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcHVsYXRlUGFyc2VySGludERpY3Rpb25hcnkoYnVpbGRlciwgdHlwZSwga2V5LCB2YWx1ZSwgc2luZ2xlS2V5SGFuZGxlcikge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvLyBhbiBhcnJheSBvZiBrZXlzIHdpdGggb25lIHZhbHVlIFsneCcsICd5JywgJ3onXSwgZnVuY3Rpb24gcGFyc2UgKCkge31cbiAgICAgICAgICAgIGtleS5mb3JFYWNoKChrKSA9PiB7XG4gICAgICAgICAgICAgICAgYnVpbGRlcihrLCB2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoKGtleSkgPT4gdHlwZW9mIGtleSA9PT0gJ29iamVjdCcpKGtleSkpIHtcbiAgICAgICAgICAgIC8vIGFuIG9iamVjdCBvZiBrZXkgdmFsdWUgcGFpcnM6IHsneCc6IHBhcnNlICgpIHt9LCAneSc6IHBhcnNlKCkge319XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgY29tbW9uX3R5cGVzXzEub2JqZWN0S2V5cyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgYnVpbGRlcihrLCBrZXlba10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2luZ2xlS2V5SGFuZGxlcih0eXBlLCBzYW5pdGl6ZUtleShrZXkpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2FuaXRpemVLZXkoa2V5KSB7XG4gICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nKVxuICAgICAgICAgICAgcmV0dXJuICdfX19wcm90b19fXyc7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlbGV0ZUZyb21QYXJzZXJIaW50T2JqZWN0KG9wdGlvbktleSkge1xuICAgICAgICAvLyBkZWxldGUgZnJvbSBhbGwgcGFyc2luZyBoaW50czpcbiAgICAgICAgLy8gYm9vbGVhbiwgYXJyYXksIGtleSwgYWxpYXMsIGV0Yy5cbiAgICAgICAgY29tbW9uX3R5cGVzXzEub2JqZWN0S2V5cyhvcHRpb25zKS5mb3JFYWNoKChoaW50S2V5KSA9PiB7XG4gICAgICAgICAgICAvLyBjb25maWdPYmplY3RzIGlzIG5vdCBhIHBhcnNpbmcgaGludCBhcnJheVxuICAgICAgICAgICAgaWYgKCgoa2V5KSA9PiBrZXkgPT09ICdjb25maWdPYmplY3RzJykoaGludEtleSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgaGludCA9IG9wdGlvbnNbaGludEtleV07XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShoaW50KSkge1xuICAgICAgICAgICAgICAgIGlmICh+aGludC5pbmRleE9mKG9wdGlvbktleSkpXG4gICAgICAgICAgICAgICAgICAgIGhpbnQuc3BsaWNlKGhpbnQuaW5kZXhPZihvcHRpb25LZXkpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBoaW50ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoaW50W29wdGlvbktleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBub3cgZGVsZXRlIHRoZSBkZXNjcmlwdGlvbiBmcm9tIHVzYWdlLmpzLlxuICAgICAgICBkZWxldGUgdXNhZ2UuZ2V0RGVzY3JpcHRpb25zKClbb3B0aW9uS2V5XTtcbiAgICB9XG4gICAgc2VsZi5jb25maWcgPSBmdW5jdGlvbiBjb25maWcoa2V5ID0gJ2NvbmZpZycsIG1zZywgcGFyc2VGbikge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnW29iamVjdHxzdHJpbmddIFtzdHJpbmd8ZnVuY3Rpb25dIFtmdW5jdGlvbl0nLCBba2V5LCBtc2csIHBhcnNlRm5dLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgLy8gYWxsb3cgYSBjb25maWcgb2JqZWN0IHRvIGJlIHByb3ZpZGVkIGRpcmVjdGx5LlxuICAgICAgICBpZiAoKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSAmJiAhQXJyYXkuaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICBrZXkgPSBhcHBseV9leHRlbmRzXzEuYXBwbHlFeHRlbmRzKGtleSwgY3dkLCBzZWxmLmdldFBhcnNlckNvbmZpZ3VyYXRpb24oKVsnZGVlcC1tZXJnZS1jb25maWcnXSk7XG4gICAgICAgICAgICBvcHRpb25zLmNvbmZpZ09iamVjdHMgPSAob3B0aW9ucy5jb25maWdPYmplY3RzIHx8IFtdKS5jb25jYXQoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFsbG93IGZvciBhIGN1c3RvbSBwYXJzaW5nIGZ1bmN0aW9uLlxuICAgICAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcGFyc2VGbiA9IG1zZztcbiAgICAgICAgICAgIG1zZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmRlc2NyaWJlKGtleSwgbXNnIHx8IHVzYWdlLmRlZmVyWTE4bkxvb2t1cCgnUGF0aCB0byBKU09OIGNvbmZpZyBmaWxlJykpO1xuICAgICAgICAoQXJyYXkuaXNBcnJheShrZXkpID8ga2V5IDogW2tleV0pLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgIG9wdGlvbnMuY29uZmlnW2tdID0gcGFyc2VGbiB8fCB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmV4YW1wbGUgPSBmdW5jdGlvbiAoY21kLCBkZXNjcmlwdGlvbikge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnPHN0cmluZ3xhcnJheT4gW3N0cmluZ10nLCBbY21kLCBkZXNjcmlwdGlvbl0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjbWQpKSB7XG4gICAgICAgICAgICBjbWQuZm9yRWFjaCgoZXhhbXBsZVBhcmFtcykgPT4gc2VsZi5leGFtcGxlKC4uLmV4YW1wbGVQYXJhbXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVzYWdlLmV4YW1wbGUoY21kLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmNvbW1hbmQgPSBmdW5jdGlvbiAoY21kLCBkZXNjcmlwdGlvbiwgYnVpbGRlciwgaGFuZGxlciwgbWlkZGxld2FyZXMsIGRlcHJlY2F0ZWQpIHtcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoJzxzdHJpbmd8YXJyYXl8b2JqZWN0PiBbc3RyaW5nfGJvb2xlYW5dIFtmdW5jdGlvbnxvYmplY3RdIFtmdW5jdGlvbl0gW2FycmF5XSBbYm9vbGVhbnxzdHJpbmddJywgW2NtZCwgZGVzY3JpcHRpb24sIGJ1aWxkZXIsIGhhbmRsZXIsIG1pZGRsZXdhcmVzLCBkZXByZWNhdGVkXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGNvbW1hbmQuYWRkSGFuZGxlcihjbWQsIGRlc2NyaXB0aW9uLCBidWlsZGVyLCBoYW5kbGVyLCBtaWRkbGV3YXJlcywgZGVwcmVjYXRlZCk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5jb21tYW5kRGlyID0gZnVuY3Rpb24gKGRpciwgb3B0cykge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnPHN0cmluZz4gW29iamVjdF0nLCBbZGlyLCBvcHRzXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHJlcSA9IHBhcmVudFJlcXVpcmUgfHwgcmVxdWlyZTtcbiAgICAgICAgY29tbWFuZC5hZGREaXJlY3RvcnkoZGlyLCBzZWxmLmdldENvbnRleHQoKSwgcmVxLCByZXF1aXJlKCdnZXQtY2FsbGVyLWZpbGUnKSgpLCBvcHRzKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBkZXByZWNhdGUgc2VsZi5kZW1hbmQgaW4gZmF2b3Igb2ZcbiAgICAvLyAuZGVtYW5kQ29tbWFuZCgpIC5kZW1hbmRPcHRpb24oKS5cbiAgICBzZWxmLmRlbWFuZCA9IHNlbGYucmVxdWlyZWQgPSBzZWxmLnJlcXVpcmUgPSBmdW5jdGlvbiBkZW1hbmQoa2V5cywgbWF4LCBtc2cpIHtcbiAgICAgICAgLy8geW91IGNhbiBvcHRpb25hbGx5IHByb3ZpZGUgYSAnbWF4JyBrZXksXG4gICAgICAgIC8vIHdoaWNoIHdpbGwgcmFpc2UgYW4gZXhjZXB0aW9uIGlmIHRvbyBtYW55ICdfJ1xuICAgICAgICAvLyBvcHRpb25zIGFyZSBwcm92aWRlZC5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWF4KSkge1xuICAgICAgICAgICAgbWF4LmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbW1vbl90eXBlc18xLmFzc2VydE5vdFN0cmljdEVxdWFsKG1zZywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZGVtYW5kT3B0aW9uKGtleSwgbXNnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWF4ID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1heCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG1zZyA9IG1heDtcbiAgICAgICAgICAgIG1heCA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yga2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGNvbW1vbl90eXBlc18xLmFzc2VydE5vdFN0cmljdEVxdWFsKG1zZywgdHJ1ZSk7XG4gICAgICAgICAgICBzZWxmLmRlbWFuZENvbW1hbmQoa2V5cywgbWF4LCBtc2csIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShrZXlzKSkge1xuICAgICAgICAgICAga2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb21tb25fdHlwZXNfMS5hc3NlcnROb3RTdHJpY3RFcXVhbChtc2csIHRydWUpO1xuICAgICAgICAgICAgICAgIGRlbWFuZE9wdGlvbihrZXksIG1zZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRlbWFuZE9wdGlvbihrZXlzLCBtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobXNnID09PSB0cnVlIHx8IHR5cGVvZiBtc2cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZGVtYW5kT3B0aW9uKGtleXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5kZW1hbmRDb21tYW5kID0gZnVuY3Rpb24gZGVtYW5kQ29tbWFuZChtaW4gPSAxLCBtYXgsIG1pbk1zZywgbWF4TXNnKSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCdbbnVtYmVyXSBbbnVtYmVyfHN0cmluZ10gW3N0cmluZ3xudWxsfHVuZGVmaW5lZF0gW3N0cmluZ3xudWxsfHVuZGVmaW5lZF0nLCBbbWluLCBtYXgsIG1pbk1zZywgbWF4TXNnXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGlmICh0eXBlb2YgbWF4ICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgbWluTXNnID0gbWF4O1xuICAgICAgICAgICAgbWF4ID0gSW5maW5pdHk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5nbG9iYWwoJ18nLCBmYWxzZSk7XG4gICAgICAgIG9wdGlvbnMuZGVtYW5kZWRDb21tYW5kcy5fID0ge1xuICAgICAgICAgICAgbWluLFxuICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgbWluTXNnLFxuICAgICAgICAgICAgbWF4TXNnXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5nZXREZW1hbmRlZE9wdGlvbnMgPSAoKSA9PiB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KFtdLCAwKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGVtYW5kZWRPcHRpb25zO1xuICAgIH07XG4gICAgc2VsZi5nZXREZW1hbmRlZENvbW1hbmRzID0gKCkgPT4ge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydChbXSwgMCk7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmRlbWFuZGVkQ29tbWFuZHM7XG4gICAgfTtcbiAgICBzZWxmLmRlcHJlY2F0ZU9wdGlvbiA9IGZ1bmN0aW9uIGRlcHJlY2F0ZU9wdGlvbihvcHRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoJzxzdHJpbmc+IFtzdHJpbmd8Ym9vbGVhbl0nLCBbb3B0aW9uLCBtZXNzYWdlXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIG9wdGlvbnMuZGVwcmVjYXRlZE9wdGlvbnNbb3B0aW9uXSA9IG1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5nZXREZXByZWNhdGVkT3B0aW9ucyA9ICgpID0+IHtcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoW10sIDApO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5kZXByZWNhdGVkT3B0aW9ucztcbiAgICB9O1xuICAgIHNlbGYuaW1wbGllcyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCc8c3RyaW5nfG9iamVjdD4gW251bWJlcnxzdHJpbmd8YXJyYXldJywgW2tleSwgdmFsdWVdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdmFsaWRhdGlvbi5pbXBsaWVzKGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYuY29uZmxpY3RzID0gZnVuY3Rpb24gKGtleTEsIGtleTIpIHtcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoJzxzdHJpbmd8b2JqZWN0PiBbc3RyaW5nfGFycmF5XScsIFtrZXkxLCBrZXkyXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHZhbGlkYXRpb24uY29uZmxpY3RzKGtleTEsIGtleTIpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYudXNhZ2UgPSBmdW5jdGlvbiAobXNnLCBkZXNjcmlwdGlvbiwgYnVpbGRlciwgaGFuZGxlcikge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnPHN0cmluZ3xudWxsfHVuZGVmaW5lZD4gW3N0cmluZ3xib29sZWFuXSBbZnVuY3Rpb258b2JqZWN0XSBbZnVuY3Rpb25dJywgW21zZywgZGVzY3JpcHRpb24sIGJ1aWxkZXIsIGhhbmRsZXJdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbW1vbl90eXBlc18xLmFzc2VydE5vdFN0cmljdEVxdWFsKG1zZywgbnVsbCk7XG4gICAgICAgICAgICAvLyAudXNhZ2UoKSBjYW4gYmUgdXNlZCBhcyBhbiBhbGlhcyBmb3IgZGVmaW5pbmdcbiAgICAgICAgICAgIC8vIGEgZGVmYXVsdCBjb21tYW5kLlxuICAgICAgICAgICAgaWYgKChtc2cgfHwgJycpLm1hdGNoKC9eXFwkMCggfCQpLykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5jb21tYW5kKG1zZywgZGVzY3JpcHRpb24sIGJ1aWxkZXIsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHllcnJvcl8xLllFcnJvcignLnVzYWdlKCkgZGVzY3JpcHRpb24gbXVzdCBzdGFydCB3aXRoICQwIGlmIGJlaW5nIHVzZWQgYXMgYWxpYXMgZm9yIC5jb21tYW5kKCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVzYWdlLnVzYWdlKG1zZyk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc2VsZi5lcGlsb2d1ZSA9IHNlbGYuZXBpbG9nID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnPHN0cmluZz4nLCBbbXNnXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHVzYWdlLmVwaWxvZyhtc2cpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYuZmFpbCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCc8ZnVuY3Rpb24+JywgW2ZdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgdXNhZ2UuZmFpbEZuKGYpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYub25GaW5pc2hDb21tYW5kID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoJzxmdW5jdGlvbj4nLCBbZl0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBoYW5kbGVyRmluaXNoQ29tbWFuZCA9IGY7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5nZXRIYW5kbGVyRmluaXNoQ29tbWFuZCA9ICgpID0+IGhhbmRsZXJGaW5pc2hDb21tYW5kO1xuICAgIHNlbGYuY2hlY2sgPSBmdW5jdGlvbiAoZiwgX2dsb2JhbCkge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnPGZ1bmN0aW9uPiBbYm9vbGVhbl0nLCBbZiwgX2dsb2JhbF0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB2YWxpZGF0aW9uLmNoZWNrKGYsIF9nbG9iYWwgIT09IGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmdsb2JhbCA9IGZ1bmN0aW9uIGdsb2JhbChnbG9iYWxzLCBnbG9iYWwpIHtcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoJzxzdHJpbmd8YXJyYXk+IFtib29sZWFuXScsIFtnbG9iYWxzLCBnbG9iYWxdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZ2xvYmFscyA9IFtdLmNvbmNhdChnbG9iYWxzKTtcbiAgICAgICAgaWYgKGdsb2JhbCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIG9wdGlvbnMubG9jYWwgPSBvcHRpb25zLmxvY2FsLmZpbHRlcihsID0+IGdsb2JhbHMuaW5kZXhPZihsKSA9PT0gLTEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFscy5mb3JFYWNoKChnKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYWwuaW5kZXhPZihnKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMubG9jYWwucHVzaChnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5wa2dDb25mID0gZnVuY3Rpb24gcGtnQ29uZihrZXksIHJvb3RQYXRoKSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCc8c3RyaW5nPiBbc3RyaW5nXScsIFtrZXksIHJvb3RQYXRoXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGxldCBjb25mID0gbnVsbDtcbiAgICAgICAgLy8gcHJlZmVyIGN3ZCB0byByZXF1aXJlLW1haW4tZmlsZW5hbWUgaW4gdGhpcyBtZXRob2RcbiAgICAgICAgLy8gc2luY2Ugd2UncmUgbG9va2luZyBmb3IgZS5nLiBcIm55Y1wiIGNvbmZpZyBpbiBueWMgY29uc3VtZXJcbiAgICAgICAgLy8gcmF0aGVyIHRoYW4gXCJ5YXJnc1wiIGNvbmZpZyBpbiBueWMgKHdoZXJlIG55YyBpcyB0aGUgbWFpbiBmaWxlbmFtZSlcbiAgICAgICAgY29uc3Qgb2JqID0gcGtnVXAocm9vdFBhdGggfHwgY3dkKTtcbiAgICAgICAgLy8gSWYgYW4gb2JqZWN0IGV4aXN0cyBpbiB0aGUga2V5LCBhZGQgaXQgdG8gb3B0aW9ucy5jb25maWdPYmplY3RzXG4gICAgICAgIGlmIChvYmpba2V5XSAmJiB0eXBlb2Ygb2JqW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25mID0gYXBwbHlfZXh0ZW5kc18xLmFwcGx5RXh0ZW5kcyhvYmpba2V5XSwgcm9vdFBhdGggfHwgY3dkLCBzZWxmLmdldFBhcnNlckNvbmZpZ3VyYXRpb24oKVsnZGVlcC1tZXJnZS1jb25maWcnXSk7XG4gICAgICAgICAgICBvcHRpb25zLmNvbmZpZ09iamVjdHMgPSAob3B0aW9ucy5jb25maWdPYmplY3RzIHx8IFtdKS5jb25jYXQoY29uZik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBjb25zdCBwa2dzID0ge307XG4gICAgZnVuY3Rpb24gcGtnVXAocm9vdFBhdGgpIHtcbiAgICAgICAgY29uc3QgbnBhdGggPSByb290UGF0aCB8fCAnKic7XG4gICAgICAgIGlmIChwa2dzW25wYXRoXSlcbiAgICAgICAgICAgIHJldHVybiBwa2dzW25wYXRoXTtcbiAgICAgICAgbGV0IG9iaiA9IHt9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0RGlyID0gcm9vdFBhdGggfHwgcmVxdWlyZU1haW5GaWxlbmFtZShwYXJlbnRSZXF1aXJlKTtcbiAgICAgICAgICAgIC8vIFdoZW4gY2FsbGVkIGluIGFuIGVudmlyb25tZW50IHRoYXQgbGFja3MgcmVxdWlyZS5tYWluLmZpbGVuYW1lLCBzdWNoIGFzIGEgamVzdCB0ZXN0IHJ1bm5lcixcbiAgICAgICAgICAgIC8vIHN0YXJ0RGlyIGlzIGFscmVhZHkgcHJvY2Vzcy5jd2QoKSwgYW5kIHNob3VsZCBub3QgYmUgc2hvcnRlbmVkLlxuICAgICAgICAgICAgLy8gV2hldGhlciBvciBub3QgaXQgaXMgX2FjdHVhbGx5XyBhIGRpcmVjdG9yeSAoZS5nLiwgZXh0ZW5zaW9ubGVzcyBiaW4pIGlzIGlycmVsZXZhbnQsIGZpbmQtdXAgaGFuZGxlcyBpdC5cbiAgICAgICAgICAgIGlmICghcm9vdFBhdGggJiYgcGF0aC5leHRuYW1lKHN0YXJ0RGlyKSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RGlyID0gcGF0aC5kaXJuYW1lKHN0YXJ0RGlyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBrZ0pzb25QYXRoID0gZmluZFVwLnN5bmMoJ3BhY2thZ2UuanNvbicsIHtcbiAgICAgICAgICAgICAgICBjd2Q6IHN0YXJ0RGlyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbW1vbl90eXBlc18xLmFzc2VydE5vdFN0cmljdEVxdWFsKHBrZ0pzb25QYXRoLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgb2JqID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGtnSnNvblBhdGgpLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChub29wKSB7IH1cbiAgICAgICAgcGtnc1tucGF0aF0gPSBvYmogfHwge307XG4gICAgICAgIHJldHVybiBwa2dzW25wYXRoXTtcbiAgICB9XG4gICAgbGV0IHBhcnNlRm4gPSBudWxsO1xuICAgIGxldCBwYXJzZUNvbnRleHQgPSBudWxsO1xuICAgIHNlbGYucGFyc2UgPSBmdW5jdGlvbiBwYXJzZShhcmdzLCBzaG9ydENpcmN1aXQsIF9wYXJzZUZuKSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCdbc3RyaW5nfGFycmF5XSBbZnVuY3Rpb258Ym9vbGVhbnxvYmplY3RdIFtmdW5jdGlvbl0nLCBbYXJncywgc2hvcnRDaXJjdWl0LCBfcGFyc2VGbl0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBmcmVlemUoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3QgYXJndiA9IHNlbGYuX3BhcnNlQXJncyhwcm9jZXNzQXJncyk7XG4gICAgICAgICAgICBjb25zdCB0bXBQYXJzZWQgPSBzZWxmLnBhcnNlZDtcbiAgICAgICAgICAgIHVuZnJlZXplKCk7XG4gICAgICAgICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBjb21wYXRpYmlsaXR5IGhhY2sgd2hlbiB3ZSByZWxlYXNlIHlhcmdzQDE1Lng6XG4gICAgICAgICAgICBzZWxmLnBhcnNlZCA9IHRtcFBhcnNlZDtcbiAgICAgICAgICAgIHJldHVybiBhcmd2O1xuICAgICAgICB9XG4gICAgICAgIC8vIGEgY29udGV4dCBvYmplY3QgY2FuIG9wdGlvbmFsbHkgYmUgcHJvdmlkZWQsIHRoaXMgYWxsb3dzXG4gICAgICAgIC8vIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdG8gYmUgcGFzc2VkIHRvIGEgY29tbWFuZCBoYW5kbGVyLlxuICAgICAgICBpZiAodHlwZW9mIHNob3J0Q2lyY3VpdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHBhcnNlQ29udGV4dCA9IHNob3J0Q2lyY3VpdDtcbiAgICAgICAgICAgIHNob3J0Q2lyY3VpdCA9IF9wYXJzZUZuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJ5IHByb3ZpZGluZyBhIGZ1bmN0aW9uIGFzIGEgc2Vjb25kIGFyZ3VtZW50IHRvXG4gICAgICAgIC8vIHBhcnNlIHlvdSBjYW4gY2FwdHVyZSBvdXRwdXQgdGhhdCB3b3VsZCBvdGhlcndpc2VcbiAgICAgICAgLy8gZGVmYXVsdCB0byBwcmludGluZyB0byBzdGRvdXQvc3RkZXJyLlxuICAgICAgICBpZiAodHlwZW9mIHNob3J0Q2lyY3VpdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcGFyc2VGbiA9IHNob3J0Q2lyY3VpdDtcbiAgICAgICAgICAgIHNob3J0Q2lyY3VpdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXBsZXRpb24gc2hvcnQtY2lyY3VpdHMgdGhlIHBhcnNpbmcgcHJvY2VzcyxcbiAgICAgICAgLy8gc2tpcHBpbmcgdmFsaWRhdGlvbiwgZXRjLlxuICAgICAgICBpZiAoIXNob3J0Q2lyY3VpdClcbiAgICAgICAgICAgIHByb2Nlc3NBcmdzID0gYXJncztcbiAgICAgICAgaWYgKHBhcnNlRm4pXG4gICAgICAgICAgICBleGl0UHJvY2VzcyA9IGZhbHNlO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBzZWxmLl9wYXJzZUFyZ3MoYXJncywgISFzaG9ydENpcmN1aXQpO1xuICAgICAgICBjb21wbGV0aW9uLnNldFBhcnNlZChzZWxmLnBhcnNlZCk7XG4gICAgICAgIGlmIChwYXJzZUZuKVxuICAgICAgICAgICAgcGFyc2VGbihleGl0RXJyb3IsIHBhcnNlZCwgb3V0cHV0KTtcbiAgICAgICAgdW5mcmVlemUoKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9O1xuICAgIHNlbGYuX2dldFBhcnNlQ29udGV4dCA9ICgpID0+IHBhcnNlQ29udGV4dCB8fCB7fTtcbiAgICBzZWxmLl9oYXNQYXJzZUNhbGxiYWNrID0gKCkgPT4gISFwYXJzZUZuO1xuICAgIHNlbGYub3B0aW9uID0gc2VsZi5vcHRpb25zID0gZnVuY3Rpb24gb3B0aW9uKGtleSwgb3B0KSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCc8c3RyaW5nfG9iamVjdD4gW29iamVjdF0nLCBba2V5LCBvcHRdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhrZXkpLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLm9wdGlvbnMoaywga2V5W2tdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHQgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgb3B0ID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcHRpb25zLmtleVtrZXldID0gdHJ1ZTsgLy8gdHJhY2sgbWFudWFsbHkgc2V0IGtleXMuXG4gICAgICAgICAgICBpZiAob3B0LmFsaWFzKVxuICAgICAgICAgICAgICAgIHNlbGYuYWxpYXMoa2V5LCBvcHQuYWxpYXMpO1xuICAgICAgICAgICAgY29uc3QgZGVwcmVjYXRlID0gb3B0LmRlcHJlY2F0ZSB8fCBvcHQuZGVwcmVjYXRlZDtcbiAgICAgICAgICAgIGlmIChkZXByZWNhdGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRlcHJlY2F0ZU9wdGlvbihrZXksIGRlcHJlY2F0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZW1hbmQgPSBvcHQuZGVtYW5kIHx8IG9wdC5yZXF1aXJlZCB8fCBvcHQucmVxdWlyZTtcbiAgICAgICAgICAgIC8vIEEgcmVxdWlyZWQgb3B0aW9uIGNhbiBiZSBzcGVjaWZpZWQgdmlhIFwiZGVtYW5kOiB0cnVlXCIuXG4gICAgICAgICAgICBpZiAoZGVtYW5kKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kZW1hbmQoa2V5LCBkZW1hbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5kZW1hbmRPcHRpb24pIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRlbWFuZE9wdGlvbihrZXksIHR5cGVvZiBvcHQuZGVtYW5kT3B0aW9uID09PSAnc3RyaW5nJyA/IG9wdC5kZW1hbmRPcHRpb24gOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5jb25mbGljdHMpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZsaWN0cyhrZXksIG9wdC5jb25mbGljdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdkZWZhdWx0JyBpbiBvcHQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRlZmF1bHQoa2V5LCBvcHQuZGVmYXVsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0LmltcGxpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGYuaW1wbGllcyhrZXksIG9wdC5pbXBsaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHQubmFyZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHNlbGYubmFyZ3Moa2V5LCBvcHQubmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5jb25maWcpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvbmZpZyhrZXksIG9wdC5jb25maWdQYXJzZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm5vcm1hbGl6ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5jaG9pY2VzKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jaG9pY2VzKGtleSwgb3B0LmNob2ljZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5jb2VyY2UpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmNvZXJjZShrZXksIG9wdC5jb2VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5ncm91cCkge1xuICAgICAgICAgICAgICAgIHNlbGYuZ3JvdXAoa2V5LCBvcHQuZ3JvdXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5ib29sZWFuIHx8IG9wdC50eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmJvb2xlYW4oa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0LmFsaWFzKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmJvb2xlYW4ob3B0LmFsaWFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHQuYXJyYXkgfHwgb3B0LnR5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmFycmF5KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5hbGlhcylcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hcnJheShvcHQuYWxpYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5udW1iZXIgfHwgb3B0LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5udW1iZXIoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0LmFsaWFzKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLm51bWJlcihvcHQuYWxpYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5zdHJpbmcgfHwgb3B0LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zdHJpbmcoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAob3B0LmFsaWFzKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnN0cmluZyhvcHQuYWxpYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5jb3VudCB8fCBvcHQudHlwZSA9PT0gJ2NvdW50Jykge1xuICAgICAgICAgICAgICAgIHNlbGYuY291bnQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0Lmdsb2JhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5nbG9iYWwoa2V5LCBvcHQuZ2xvYmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcHQuZGVmYXVsdERlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kZWZhdWx0RGVzY3JpcHRpb25ba2V5XSA9IG9wdC5kZWZhdWx0RGVzY3JpcHRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0LnNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5za2lwVmFsaWRhdGlvbihrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVzYyA9IG9wdC5kZXNjcmliZSB8fCBvcHQuZGVzY3JpcHRpb24gfHwgb3B0LmRlc2M7XG4gICAgICAgICAgICBzZWxmLmRlc2NyaWJlKGtleSwgZGVzYyk7XG4gICAgICAgICAgICBpZiAob3B0LmhpZGRlbikge1xuICAgICAgICAgICAgICAgIHNlbGYuaGlkZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdC5yZXF1aXJlc0FyZykge1xuICAgICAgICAgICAgICAgIHNlbGYucmVxdWlyZXNBcmcoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYuZ2V0T3B0aW9ucyA9ICgpID0+IG9wdGlvbnM7XG4gICAgc2VsZi5wb3NpdGlvbmFsID0gZnVuY3Rpb24gKGtleSwgb3B0cykge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnPHN0cmluZz4gPG9iamVjdD4nLCBba2V5LCBvcHRzXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGlmIChjb250ZXh0LnJlc2V0cyA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IHllcnJvcl8xLllFcnJvcihcIi5wb3NpdGlvbmFsKCkgY2FuIG9ubHkgYmUgY2FsbGVkIGluIGEgY29tbWFuZCdzIGJ1aWxkZXIgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gLnBvc2l0aW9uYWwoKSBvbmx5IHN1cHBvcnRzIGEgc3Vic2V0IG9mIHRoZSBjb25maWd1cmF0aW9uXG4gICAgICAgIC8vIG9wdGlvbnMgYXZhaWxhYmxlIHRvIC5vcHRpb24oKS5cbiAgICAgICAgY29uc3Qgc3VwcG9ydGVkT3B0cyA9IFsnZGVmYXVsdCcsICdkZWZhdWx0RGVzY3JpcHRpb24nLCAnaW1wbGllcycsICdub3JtYWxpemUnLFxuICAgICAgICAgICAgJ2Nob2ljZXMnLCAnY29uZmxpY3RzJywgJ2NvZXJjZScsICd0eXBlJywgJ2Rlc2NyaWJlJyxcbiAgICAgICAgICAgICdkZXNjJywgJ2Rlc2NyaXB0aW9uJywgJ2FsaWFzJ107XG4gICAgICAgIG9wdHMgPSBvYmpfZmlsdGVyXzEub2JqRmlsdGVyKG9wdHMsIChrLCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgYWNjZXB0ID0gc3VwcG9ydGVkT3B0cy5pbmRleE9mKGspICE9PSAtMTtcbiAgICAgICAgICAgIC8vIHR5cGUgY2FuIGJlIG9uZSBvZiBzdHJpbmd8bnVtYmVyfGJvb2xlYW4uXG4gICAgICAgICAgICBpZiAoayA9PT0gJ3R5cGUnICYmIFsnc3RyaW5nJywgJ251bWJlcicsICdib29sZWFuJ10uaW5kZXhPZih2KSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgYWNjZXB0ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gYWNjZXB0O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gY29weSBvdmVyIGFueSBzZXR0aW5ncyB0aGF0IGNhbiBiZSBpbmZlcnJlZCBmcm9tIHRoZSBjb21tYW5kIHN0cmluZy5cbiAgICAgICAgY29uc3QgZnVsbENvbW1hbmQgPSBjb250ZXh0LmZ1bGxDb21tYW5kc1tjb250ZXh0LmZ1bGxDb21tYW5kcy5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgcGFyc2VPcHRpb25zID0gZnVsbENvbW1hbmQgPyBjb21tYW5kLmNtZFRvUGFyc2VPcHRpb25zKGZ1bGxDb21tYW5kKSA6IHtcbiAgICAgICAgICAgIGFycmF5OiBbXSxcbiAgICAgICAgICAgIGFsaWFzOiB7fSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IHt9LFxuICAgICAgICAgICAgZGVtYW5kOiB7fVxuICAgICAgICB9O1xuICAgICAgICBjb21tb25fdHlwZXNfMS5vYmplY3RLZXlzKHBhcnNlT3B0aW9ucykuZm9yRWFjaCgocGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlT3B0aW9uID0gcGFyc2VPcHRpb25zW3BrXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcnNlT3B0aW9uKSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZU9wdGlvbi5pbmRleE9mKGtleSkgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICBvcHRzW3BrXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VPcHRpb25ba2V5XSAmJiAhKHBrIGluIG9wdHMpKVxuICAgICAgICAgICAgICAgICAgICBvcHRzW3BrXSA9IHBhcnNlT3B0aW9uW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLmdyb3VwKGtleSwgdXNhZ2UuZ2V0UG9zaXRpb25hbEdyb3VwTmFtZSgpKTtcbiAgICAgICAgcmV0dXJuIHNlbGYub3B0aW9uKGtleSwgb3B0cyk7XG4gICAgfTtcbiAgICBzZWxmLmdyb3VwID0gZnVuY3Rpb24gZ3JvdXAob3B0cywgZ3JvdXBOYW1lKSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCc8c3RyaW5nfGFycmF5PiA8c3RyaW5nPicsIFtvcHRzLCBncm91cE5hbWVdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBwcmVzZXJ2ZWRHcm91cHNbZ3JvdXBOYW1lXSB8fCBncm91cHNbZ3JvdXBOYW1lXTtcbiAgICAgICAgaWYgKHByZXNlcnZlZEdyb3Vwc1tncm91cE5hbWVdKSB7XG4gICAgICAgICAgICAvLyB3ZSBub3cgb25seSBuZWVkIHRvIHRyYWNrIHRoaXMgZ3JvdXAgbmFtZSBpbiBncm91cHMuXG4gICAgICAgICAgICBkZWxldGUgcHJlc2VydmVkR3JvdXBzW2dyb3VwTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlbiA9IHt9O1xuICAgICAgICBncm91cHNbZ3JvdXBOYW1lXSA9IChleGlzdGluZyB8fCBbXSkuY29uY2F0KG9wdHMpLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoc2VlbltrZXldKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiAoc2VlbltrZXldID0gdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIC8vIGNvbWJpbmUgZXhwbGljaXQgYW5kIHByZXNlcnZlZCBncm91cHMuIGV4cGxpY2l0IGdyb3VwcyBzaG91bGQgYmUgZmlyc3RcbiAgICBzZWxmLmdldEdyb3VwcyA9ICgpID0+IE9iamVjdC5hc3NpZ24oe30sIGdyb3VwcywgcHJlc2VydmVkR3JvdXBzKTtcbiAgICAvLyBhcyBsb25nIGFzIG9wdGlvbnMuZW52UHJlZml4IGlzIG5vdCB1bmRlZmluZWQsXG4gICAgLy8gcGFyc2VyIHdpbGwgYXBwbHkgZW52IHZhcnMgbWF0Y2hpbmcgcHJlZml4IHRvIGFyZ3ZcbiAgICBzZWxmLmVudiA9IGZ1bmN0aW9uIChwcmVmaXgpIHtcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoJ1tzdHJpbmd8Ym9vbGVhbl0nLCBbcHJlZml4XSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGlmIChwcmVmaXggPT09IGZhbHNlKVxuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuZW52UHJlZml4O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBvcHRpb25zLmVudlByZWZpeCA9IHByZWZpeCB8fCAnJztcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLndyYXAgPSBmdW5jdGlvbiAoY29scykge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnPG51bWJlcnxudWxsfHVuZGVmaW5lZD4nLCBbY29sc10sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICB1c2FnZS53cmFwKGNvbHMpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIGxldCBzdHJpY3QgPSBmYWxzZTtcbiAgICBzZWxmLnN0cmljdCA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCdbYm9vbGVhbl0nLCBbZW5hYmxlZF0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBzdHJpY3QgPSBlbmFibGVkICE9PSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmdldFN0cmljdCA9ICgpID0+IHN0cmljdDtcbiAgICBsZXQgc3RyaWN0Q29tbWFuZHMgPSBmYWxzZTtcbiAgICBzZWxmLnN0cmljdENvbW1hbmRzID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoJ1tib29sZWFuXScsIFtlbmFibGVkXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHN0cmljdENvbW1hbmRzID0gZW5hYmxlZCAhPT0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5nZXRTdHJpY3RDb21tYW5kcyA9ICgpID0+IHN0cmljdENvbW1hbmRzO1xuICAgIGxldCBwYXJzZXJDb25maWcgPSB7fTtcbiAgICBzZWxmLnBhcnNlckNvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbiBwYXJzZXJDb25maWd1cmF0aW9uKGNvbmZpZykge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnPG9iamVjdD4nLCBbY29uZmlnXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHBhcnNlckNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmdldFBhcnNlckNvbmZpZ3VyYXRpb24gPSAoKSA9PiBwYXJzZXJDb25maWc7XG4gICAgc2VsZi5zaG93SGVscCA9IGZ1bmN0aW9uIChsZXZlbCkge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnW3N0cmluZ3xmdW5jdGlvbl0nLCBbbGV2ZWxdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgaWYgKCFzZWxmLnBhcnNlZClcbiAgICAgICAgICAgIHNlbGYuX3BhcnNlQXJncyhwcm9jZXNzQXJncyk7IC8vIHJ1biBwYXJzZXIsIGlmIGl0IGhhcyBub3QgYWxyZWFkeSBiZWVuIGV4ZWN1dGVkLlxuICAgICAgICBpZiAoY29tbWFuZC5oYXNEZWZhdWx0Q29tbWFuZCgpKSB7XG4gICAgICAgICAgICBjb250ZXh0LnJlc2V0cysrOyAvLyBvdmVycmlkZSB0aGUgcmVzdHJpY3Rpb24gb24gdG9wLWxldmVsIHBvc2l0b2luYWxzLlxuICAgICAgICAgICAgY29tbWFuZC5ydW5EZWZhdWx0QnVpbGRlck9uKHNlbGYpO1xuICAgICAgICB9XG4gICAgICAgIHVzYWdlLnNob3dIZWxwKGxldmVsKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBsZXQgdmVyc2lvbk9wdCA9IG51bGw7XG4gICAgc2VsZi52ZXJzaW9uID0gZnVuY3Rpb24gdmVyc2lvbihvcHQsIG1zZywgdmVyKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWZXJzaW9uT3B0ID0gJ3ZlcnNpb24nO1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnW2Jvb2xlYW58c3RyaW5nXSBbc3RyaW5nXSBbc3RyaW5nXScsIFtvcHQsIG1zZywgdmVyXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIC8vIG51a2UgdGhlIGtleSBwcmV2aW91c2x5IGNvbmZpZ3VyZWRcbiAgICAgICAgLy8gdG8gcmV0dXJuIHZlcnNpb24gIy5cbiAgICAgICAgaWYgKHZlcnNpb25PcHQpIHtcbiAgICAgICAgICAgIGRlbGV0ZUZyb21QYXJzZXJIaW50T2JqZWN0KHZlcnNpb25PcHQpO1xuICAgICAgICAgICAgdXNhZ2UudmVyc2lvbih1bmRlZmluZWQpO1xuICAgICAgICAgICAgdmVyc2lvbk9wdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZlciA9IGd1ZXNzVmVyc2lvbigpO1xuICAgICAgICAgICAgb3B0ID0gZGVmYXVsdFZlcnNpb25PcHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKG9wdCA9PT0gZmFsc2UpIHsgLy8gZGlzYWJsZSBkZWZhdWx0ICd2ZXJzaW9uJyBrZXkuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ZXIgPSBvcHQ7XG4gICAgICAgICAgICBvcHQgPSBkZWZhdWx0VmVyc2lvbk9wdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB2ZXIgPSBtc2c7XG4gICAgICAgICAgICBtc2cgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmVyc2lvbk9wdCA9IHR5cGVvZiBvcHQgPT09ICdzdHJpbmcnID8gb3B0IDogZGVmYXVsdFZlcnNpb25PcHQ7XG4gICAgICAgIG1zZyA9IG1zZyB8fCB1c2FnZS5kZWZlclkxOG5Mb29rdXAoJ1Nob3cgdmVyc2lvbiBudW1iZXInKTtcbiAgICAgICAgdXNhZ2UudmVyc2lvbih2ZXIgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgc2VsZi5ib29sZWFuKHZlcnNpb25PcHQpO1xuICAgICAgICBzZWxmLmRlc2NyaWJlKHZlcnNpb25PcHQsIG1zZyk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZ3Vlc3NWZXJzaW9uKCkge1xuICAgICAgICBjb25zdCBvYmogPSBwa2dVcCgpO1xuICAgICAgICByZXR1cm4gb2JqLnZlcnNpb24gfHwgJ3Vua25vd24nO1xuICAgIH1cbiAgICBsZXQgaGVscE9wdCA9IG51bGw7XG4gICAgc2VsZi5hZGRIZWxwT3B0ID0gc2VsZi5oZWxwID0gZnVuY3Rpb24gYWRkSGVscE9wdChvcHQsIG1zZykge1xuICAgICAgICBjb25zdCBkZWZhdWx0SGVscE9wdCA9ICdoZWxwJztcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoJ1tzdHJpbmd8Ym9vbGVhbl0gW3N0cmluZ10nLCBbb3B0LCBtc2ddLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgLy8gbnVrZSB0aGUga2V5IHByZXZpb3VzbHkgY29uZmlndXJlZFxuICAgICAgICAvLyB0byByZXR1cm4gaGVscC5cbiAgICAgICAgaWYgKGhlbHBPcHQpIHtcbiAgICAgICAgICAgIGRlbGV0ZUZyb21QYXJzZXJIaW50T2JqZWN0KGhlbHBPcHQpO1xuICAgICAgICAgICAgaGVscE9wdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmIChvcHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVzZSBhcmd1bWVudHMsIGZhbGxiYWNrIHRvIGRlZmF1bHRzIGZvciBvcHQgYW5kIG1zZ1xuICAgICAgICBoZWxwT3B0ID0gdHlwZW9mIG9wdCA9PT0gJ3N0cmluZycgPyBvcHQgOiBkZWZhdWx0SGVscE9wdDtcbiAgICAgICAgc2VsZi5ib29sZWFuKGhlbHBPcHQpO1xuICAgICAgICBzZWxmLmRlc2NyaWJlKGhlbHBPcHQsIG1zZyB8fCB1c2FnZS5kZWZlclkxOG5Mb29rdXAoJ1Nob3cgaGVscCcpKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBjb25zdCBkZWZhdWx0U2hvd0hpZGRlbk9wdCA9ICdzaG93LWhpZGRlbic7XG4gICAgb3B0aW9ucy5zaG93SGlkZGVuT3B0ID0gZGVmYXVsdFNob3dIaWRkZW5PcHQ7XG4gICAgc2VsZi5hZGRTaG93SGlkZGVuT3B0ID0gc2VsZi5zaG93SGlkZGVuID0gZnVuY3Rpb24gYWRkU2hvd0hpZGRlbk9wdChvcHQsIG1zZykge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnW3N0cmluZ3xib29sZWFuXSBbc3RyaW5nXScsIFtvcHQsIG1zZ10sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKG9wdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2hvd0hpZGRlbk9wdCA9IHR5cGVvZiBvcHQgPT09ICdzdHJpbmcnID8gb3B0IDogZGVmYXVsdFNob3dIaWRkZW5PcHQ7XG4gICAgICAgIHNlbGYuYm9vbGVhbihzaG93SGlkZGVuT3B0KTtcbiAgICAgICAgc2VsZi5kZXNjcmliZShzaG93SGlkZGVuT3B0LCBtc2cgfHwgdXNhZ2UuZGVmZXJZMThuTG9va3VwKCdTaG93IGhpZGRlbiBvcHRpb25zJykpO1xuICAgICAgICBvcHRpb25zLnNob3dIaWRkZW5PcHQgPSBzaG93SGlkZGVuT3B0O1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYuaGlkZSA9IGZ1bmN0aW9uIGhpZGUoa2V5KSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCc8c3RyaW5nPicsIFtrZXldLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgb3B0aW9ucy5oaWRkZW5PcHRpb25zLnB1c2goa2V5KTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLnNob3dIZWxwT25GYWlsID0gZnVuY3Rpb24gc2hvd0hlbHBPbkZhaWwoZW5hYmxlZCwgbWVzc2FnZSkge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnW2Jvb2xlYW58c3RyaW5nXSBbc3RyaW5nXScsIFtlbmFibGVkLCBtZXNzYWdlXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIHVzYWdlLnNob3dIZWxwT25GYWlsKGVuYWJsZWQsIG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHZhciBleGl0UHJvY2VzcyA9IHRydWU7XG4gICAgc2VsZi5leGl0UHJvY2VzcyA9IGZ1bmN0aW9uIChlbmFibGVkID0gdHJ1ZSkge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnW2Jvb2xlYW5dJywgW2VuYWJsZWRdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZXhpdFByb2Nlc3MgPSBlbmFibGVkO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYuZ2V0RXhpdFByb2Nlc3MgPSAoKSA9PiBleGl0UHJvY2VzcztcbiAgICB2YXIgY29tcGxldGlvbkNvbW1hbmQgPSBudWxsO1xuICAgIHNlbGYuY29tcGxldGlvbiA9IGZ1bmN0aW9uIChjbWQsIGRlc2MsIGZuKSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCdbc3RyaW5nXSBbc3RyaW5nfGJvb2xlYW58ZnVuY3Rpb25dIFtmdW5jdGlvbl0nLCBbY21kLCBkZXNjLCBmbl0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICAvLyBhIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiBnZW5lcmF0aW5nXG4gICAgICAgIC8vIGNvbXBsZXRpb25zIGNhbiBiZSBwcm92aWRlZCBhcyB0aGUgc2Vjb25kXG4gICAgICAgIC8vIG9yIHRoaXJkIGFyZ3VtZW50IHRvIGNvbXBsZXRpb24uXG4gICAgICAgIGlmICh0eXBlb2YgZGVzYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZm4gPSBkZXNjO1xuICAgICAgICAgICAgZGVzYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyByZWdpc3RlciB0aGUgY29tcGxldGlvbiBjb21tYW5kLlxuICAgICAgICBjb21wbGV0aW9uQ29tbWFuZCA9IGNtZCB8fCBjb21wbGV0aW9uQ29tbWFuZCB8fCAnY29tcGxldGlvbic7XG4gICAgICAgIGlmICghZGVzYyAmJiBkZXNjICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZGVzYyA9ICdnZW5lcmF0ZSBjb21wbGV0aW9uIHNjcmlwdCc7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5jb21tYW5kKGNvbXBsZXRpb25Db21tYW5kLCBkZXNjKTtcbiAgICAgICAgLy8gYSBmdW5jdGlvbiBjYW4gYmUgcHJvdmlkZWRcbiAgICAgICAgaWYgKGZuKVxuICAgICAgICAgICAgY29tcGxldGlvbi5yZWdpc3RlckZ1bmN0aW9uKGZuKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLnNob3dDb21wbGV0aW9uU2NyaXB0ID0gZnVuY3Rpb24gKCQwLCBjbWQpIHtcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoJ1tzdHJpbmddIFtzdHJpbmddJywgWyQwLCBjbWRdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgJDAgPSAkMCB8fCBzZWxmLiQwO1xuICAgICAgICBfbG9nZ2VyLmxvZyhjb21wbGV0aW9uLmdlbmVyYXRlQ29tcGxldGlvblNjcmlwdCgkMCwgY21kIHx8IGNvbXBsZXRpb25Db21tYW5kIHx8ICdjb21wbGV0aW9uJykpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYuZ2V0Q29tcGxldGlvbiA9IGZ1bmN0aW9uIChhcmdzLCBkb25lKSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCc8YXJyYXk+IDxmdW5jdGlvbj4nLCBbYXJncywgZG9uZV0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBjb21wbGV0aW9uLmdldENvbXBsZXRpb24oYXJncywgZG9uZSk7XG4gICAgfTtcbiAgICBzZWxmLmxvY2FsZSA9IGZ1bmN0aW9uIChsb2NhbGUpIHtcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoJ1tzdHJpbmddJywgW2xvY2FsZV0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAoIWxvY2FsZSkge1xuICAgICAgICAgICAgZ3Vlc3NMb2NhbGUoKTtcbiAgICAgICAgICAgIHJldHVybiB5MThuLmdldExvY2FsZSgpO1xuICAgICAgICB9XG4gICAgICAgIGRldGVjdExvY2FsZSA9IGZhbHNlO1xuICAgICAgICB5MThuLnNldExvY2FsZShsb2NhbGUpO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHNlbGYudXBkYXRlU3RyaW5ncyA9IHNlbGYudXBkYXRlTG9jYWxlID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnPG9iamVjdD4nLCBbb2JqXSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgIGRldGVjdExvY2FsZSA9IGZhbHNlO1xuICAgICAgICB5MThuLnVwZGF0ZUxvY2FsZShvYmopO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIGxldCBkZXRlY3RMb2NhbGUgPSB0cnVlO1xuICAgIHNlbGYuZGV0ZWN0TG9jYWxlID0gZnVuY3Rpb24gKGRldGVjdCkge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnPGJvb2xlYW4+JywgW2RldGVjdF0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBkZXRlY3RMb2NhbGUgPSBkZXRlY3Q7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5nZXREZXRlY3RMb2NhbGUgPSAoKSA9PiBkZXRlY3RMb2NhbGU7XG4gICAgdmFyIGhhc091dHB1dCA9IGZhbHNlO1xuICAgIHZhciBleGl0RXJyb3IgPSBudWxsO1xuICAgIC8vIG1heWJlIGV4aXQsIGFsd2F5cyBjYXB0dXJlXG4gICAgLy8gY29udGV4dCBhYm91dCB3aHkgd2Ugd2FudGVkIHRvIGV4aXQuXG4gICAgc2VsZi5leGl0ID0gKGNvZGUsIGVycikgPT4ge1xuICAgICAgICBoYXNPdXRwdXQgPSB0cnVlO1xuICAgICAgICBleGl0RXJyb3IgPSBlcnI7XG4gICAgICAgIGlmIChleGl0UHJvY2VzcylcbiAgICAgICAgICAgIHByb2Nlc3MuZXhpdChjb2RlKTtcbiAgICB9O1xuICAgIC8vIHdlIHVzZSBhIGN1c3RvbSBsb2dnZXIgdGhhdCBidWZmZXJzIG91dHB1dCxcbiAgICAvLyBzbyB0aGF0IHdlIGNhbiBwcmludCB0byBub24tQ0xJcywgZS5nLiwgY2hhdC1ib3RzLlxuICAgIGNvbnN0IF9sb2dnZXIgPSB7XG4gICAgICAgIGxvZyguLi5hcmdzKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYuX2hhc1BhcnNlQ2FsbGJhY2soKSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyguLi5hcmdzKTtcbiAgICAgICAgICAgIGhhc091dHB1dCA9IHRydWU7XG4gICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gJ1xcbic7XG4gICAgICAgICAgICBvdXRwdXQgKz0gYXJncy5qb2luKCcgJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGlmICghc2VsZi5faGFzUGFyc2VDYWxsYmFjaygpKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7XG4gICAgICAgICAgICBoYXNPdXRwdXQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9ICdcXG4nO1xuICAgICAgICAgICAgb3V0cHV0ICs9IGFyZ3Muam9pbignICcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzZWxmLl9nZXRMb2dnZXJJbnN0YW5jZSA9ICgpID0+IF9sb2dnZXI7XG4gICAgLy8gaGFzIHlhcmdzIG91dHB1dCBhbiBlcnJvciBvdXIgaGVscFxuICAgIC8vIG1lc3NhZ2UgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQuXG4gICAgc2VsZi5faGFzT3V0cHV0ID0gKCkgPT4gaGFzT3V0cHV0O1xuICAgIHNlbGYuX3NldEhhc091dHB1dCA9ICgpID0+IHtcbiAgICAgICAgaGFzT3V0cHV0ID0gdHJ1ZTtcbiAgICB9O1xuICAgIGxldCByZWNvbW1lbmRDb21tYW5kcztcbiAgICBzZWxmLnJlY29tbWVuZENvbW1hbmRzID0gZnVuY3Rpb24gKHJlY29tbWVuZCA9IHRydWUpIHtcbiAgICAgICAgYXJnc2VydF8xLmFyZ3NlcnQoJ1tib29sZWFuXScsIFtyZWNvbW1lbmRdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgcmVjb21tZW5kQ29tbWFuZHMgPSByZWNvbW1lbmQ7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgIH07XG4gICAgc2VsZi5nZXRVc2FnZUluc3RhbmNlID0gKCkgPT4gdXNhZ2U7XG4gICAgc2VsZi5nZXRWYWxpZGF0aW9uSW5zdGFuY2UgPSAoKSA9PiB2YWxpZGF0aW9uO1xuICAgIHNlbGYuZ2V0Q29tbWFuZEluc3RhbmNlID0gKCkgPT4gY29tbWFuZDtcbiAgICBzZWxmLnRlcm1pbmFsV2lkdGggPSAoKSA9PiB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KFtdLCAwKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzLnN0ZG91dC5jb2x1bW5zICE9PSAndW5kZWZpbmVkJyA/IHByb2Nlc3Muc3Rkb3V0LmNvbHVtbnMgOiBudWxsO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsICdhcmd2Jywge1xuICAgICAgICBnZXQ6ICgpID0+IHNlbGYuX3BhcnNlQXJncyhwcm9jZXNzQXJncyksXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBzZWxmLl9wYXJzZUFyZ3MgPSBmdW5jdGlvbiBwYXJzZUFyZ3MoYXJncywgc2hvcnRDaXJjdWl0LCBfY2FsbGVkRnJvbUNvbW1hbmQsIGNvbW1hbmRJbmRleCkge1xuICAgICAgICBsZXQgc2tpcFZhbGlkYXRpb24gPSAhIV9jYWxsZWRGcm9tQ29tbWFuZDtcbiAgICAgICAgYXJncyA9IGFyZ3MgfHwgcHJvY2Vzc0FyZ3M7XG4gICAgICAgIG9wdGlvbnMuX18gPSB5MThuLl9fO1xuICAgICAgICBvcHRpb25zLmNvbmZpZ3VyYXRpb24gPSBzZWxmLmdldFBhcnNlckNvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgY29uc3QgcG9wdWxhdGVEb3VibGVEYXNoID0gISFvcHRpb25zLmNvbmZpZ3VyYXRpb25bJ3BvcHVsYXRlLS0nXTtcbiAgICAgICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5jb25maWd1cmF0aW9uLCB7XG4gICAgICAgICAgICAncG9wdWxhdGUtLSc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IFBhcnNlci5kZXRhaWxlZChhcmdzLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICBjb25maWd1cmF0aW9uOiBjb25maWdcbiAgICAgICAgfSkpO1xuICAgICAgICBsZXQgYXJndiA9IHBhcnNlZC5hcmd2O1xuICAgICAgICBpZiAocGFyc2VDb250ZXh0KVxuICAgICAgICAgICAgYXJndiA9IE9iamVjdC5hc3NpZ24oe30sIGFyZ3YsIHBhcnNlQ29udGV4dCk7XG4gICAgICAgIGNvbnN0IGFsaWFzZXMgPSBwYXJzZWQuYWxpYXNlcztcbiAgICAgICAgYXJndi4kMCA9IHNlbGYuJDA7XG4gICAgICAgIHNlbGYucGFyc2VkID0gcGFyc2VkO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZ3Vlc3NMb2NhbGUoKTsgLy8gZ3Vlc3MgbG9jYWxlIGxhemlseSwgc28gdGhhdCBpdCBjYW4gYmUgdHVybmVkIG9mZiBpbiBjaGFpbi5cbiAgICAgICAgICAgIC8vIHdoaWxlIGJ1aWxkaW5nIHVwIHRoZSBhcmd2IG9iamVjdCwgdGhlcmVcbiAgICAgICAgICAgIC8vIGFyZSB0d28gcGFzc2VzIHRocm91Z2ggdGhlIHBhcnNlci4gSWYgY29tcGxldGlvblxuICAgICAgICAgICAgLy8gaXMgYmVpbmcgcGVyZm9ybWVkIHNob3J0LWNpcmN1aXQgb24gdGhlIGZpcnN0IHBhc3MuXG4gICAgICAgICAgICBpZiAoc2hvcnRDaXJjdWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwb3B1bGF0ZURvdWJsZURhc2ggfHwgX2NhbGxlZEZyb21Db21tYW5kKSA/IGFyZ3YgOiBzZWxmLl9jb3B5RG91YmxlRGFzaChhcmd2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYSBoYW5kbGVyIGFzc29jaWF0ZWQgd2l0aCBhXG4gICAgICAgICAgICAvLyBjb21tYW5kIGRlZmVyIHByb2Nlc3NpbmcgdG8gaXQuXG4gICAgICAgICAgICBpZiAoaGVscE9wdCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNpZGVyIGFueSBtdWx0aS1jaGFyIGhlbHBPcHQgYWxpYXMgYXMgYSB2YWxpZCBoZWxwIGNvbW1hbmRcbiAgICAgICAgICAgICAgICAvLyB1bmxlc3MgYWxsIGhlbHBPcHQgYWxpYXNlcyBhcmUgc2luZ2xlLWNoYXJcbiAgICAgICAgICAgICAgICAvLyBub3RlIHRoYXQgcGFyc2VkLmFsaWFzZXMgaXMgYSBub3JtYWxpemVkIGJpZGlyZWN0aW9uYWwgbWFwIDopXG4gICAgICAgICAgICAgICAgY29uc3QgaGVscENtZHMgPSBbaGVscE9wdF1cbiAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChhbGlhc2VzW2hlbHBPcHRdIHx8IFtdKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGsgPT4gay5sZW5ndGggPiAxKTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBoZWxwIHNob3VsZCB0cmlnZ2VyIGFuZCBzdHJpcCBpdCBmcm9tIF8uXG4gICAgICAgICAgICAgICAgaWYgKH5oZWxwQ21kcy5pbmRleE9mKGFyZ3YuX1thcmd2Ll8ubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3YuXy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgYXJndltoZWxwT3B0XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaGFuZGxlcktleXMgPSBjb21tYW5kLmdldENvbW1hbmRzKCk7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0Q29tcGxldGlvbnMgPSBjb21wbGV0aW9uLmNvbXBsZXRpb25LZXkgaW4gYXJndjtcbiAgICAgICAgICAgIGNvbnN0IHNraXBSZWNvbW1lbmRhdGlvbiA9IGFyZ3ZbaGVscE9wdF0gfHwgcmVxdWVzdENvbXBsZXRpb25zO1xuICAgICAgICAgICAgY29uc3Qgc2tpcERlZmF1bHRDb21tYW5kID0gc2tpcFJlY29tbWVuZGF0aW9uICYmIChoYW5kbGVyS2V5cy5sZW5ndGggPiAxIHx8IGhhbmRsZXJLZXlzWzBdICE9PSAnJDAnKTtcbiAgICAgICAgICAgIGlmIChhcmd2Ll8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZmlyc3RVbmtub3duQ29tbWFuZDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IChjb21tYW5kSW5kZXggfHwgMCksIGNtZDsgYXJndi5fW2ldICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY21kID0gU3RyaW5nKGFyZ3YuX1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAofmhhbmRsZXJLZXlzLmluZGV4T2YoY21kKSAmJiBjbWQgIT09IGNvbXBsZXRpb25Db21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tbWFuZHMgYXJlIGV4ZWN1dGVkIHVzaW5nIGEgcmVjdXJzaXZlIGFsZ29yaXRobSB0aGF0IGV4ZWN1dGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGRlZXBlc3QgY29tbWFuZCBmaXJzdDsgd2Uga2VlcCB0cmFjayBvZiB0aGUgcG9zaXRpb24gaW4gdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJndi5fIGFycmF5IHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIGV4ZWN1dGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyQXJndiA9IGNvbW1hbmQucnVuQ29tbWFuZChjbWQsIHNlbGYsIHBhcnNlZCwgaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3B1bGF0ZURvdWJsZURhc2ggPyBpbm5lckFyZ3YgOiBzZWxmLl9jb3B5RG91YmxlRGFzaChpbm5lckFyZ3YpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWZpcnN0VW5rbm93bkNvbW1hbmQgJiYgY21kICE9PSBjb21wbGV0aW9uQ29tbWFuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0VW5rbm93bkNvbW1hbmQgPSBjbWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gcnVuIHRoZSBkZWZhdWx0IGNvbW1hbmQsIGlmIGRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hbmQuaGFzRGVmYXVsdENvbW1hbmQoKSAmJiAhc2tpcERlZmF1bHRDb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbm5lckFyZ3YgPSBjb21tYW5kLnJ1bkNvbW1hbmQobnVsbCwgc2VsZiwgcGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3B1bGF0ZURvdWJsZURhc2ggPyBpbm5lckFyZ3YgOiBzZWxmLl9jb3B5RG91YmxlRGFzaChpbm5lckFyZ3YpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY29tbWVuZCBhIGNvbW1hbmQgaWYgcmVjb21tZW5kQ29tbWFuZHMoKSBoYXNcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVlbiBlbmFibGVkLCBhbmQgbm8gY29tbWFuZHMgd2VyZSBmb3VuZCB0byBleGVjdXRlXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvbW1lbmRDb21tYW5kcyAmJiBmaXJzdFVua25vd25Db21tYW5kICYmICFza2lwUmVjb21tZW5kYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb24ucmVjb21tZW5kQ29tbWFuZHMoZmlyc3RVbmtub3duQ29tbWFuZCwgaGFuZGxlcktleXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGdlbmVyYXRlIGEgY29tcGxldGlvbiBzY3JpcHQgZm9yIGFkZGluZyB0byB+Ly5iYXNocmMuXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBsZXRpb25Db21tYW5kICYmIH5hcmd2Ll8uaW5kZXhPZihjb21wbGV0aW9uQ29tbWFuZCkgJiYgIXJlcXVlc3RDb21wbGV0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpdFByb2Nlc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRCbG9ja2luZyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zaG93Q29tcGxldGlvblNjcmlwdCgpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmV4aXQoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tbWFuZC5oYXNEZWZhdWx0Q29tbWFuZCgpICYmICFza2lwRGVmYXVsdENvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lckFyZ3YgPSBjb21tYW5kLnJ1bkNvbW1hbmQobnVsbCwgc2VsZiwgcGFyc2VkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcG9wdWxhdGVEb3VibGVEYXNoID8gaW5uZXJBcmd2IDogc2VsZi5fY29weURvdWJsZURhc2goaW5uZXJBcmd2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIG11c3QgcnVuIGNvbXBsZXRpb25zIGZpcnN0LCBhIHVzZXIgbWlnaHRcbiAgICAgICAgICAgIC8vIHdhbnQgdG8gY29tcGxldGUgdGhlIC0taGVscCBvciAtLXZlcnNpb24gb3B0aW9uLlxuICAgICAgICAgICAgaWYgKHJlcXVlc3RDb21wbGV0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChleGl0UHJvY2VzcylcbiAgICAgICAgICAgICAgICAgICAgc2V0QmxvY2tpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgLy8gd2UgYWxsb3cgZm9yIGFzeW5jaHJvbm91cyBjb21wbGV0aW9ucyxcbiAgICAgICAgICAgICAgICAvLyBlLmcuLCBsb2FkaW5nIGluIGEgbGlzdCBvZiBjb21tYW5kcyBmcm9tIGFuIEFQSS5cbiAgICAgICAgICAgICAgICBhcmdzID0gW10uY29uY2F0KGFyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRpb25BcmdzID0gYXJncy5zbGljZShhcmdzLmluZGV4T2YoYC0tJHtjb21wbGV0aW9uLmNvbXBsZXRpb25LZXl9YCkgKyAxKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0aW9uLmdldENvbXBsZXRpb24oY29tcGxldGlvbkFyZ3MsIChjb21wbGV0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICA7XG4gICAgICAgICAgICAgICAgICAgIChjb21wbGV0aW9ucyB8fCBbXSkuZm9yRWFjaCgoY29tcGxldGlvbikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xvZ2dlci5sb2coY29tcGxldGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmV4aXQoMCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChwb3B1bGF0ZURvdWJsZURhc2ggfHwgX2NhbGxlZEZyb21Db21tYW5kKSA/IGFyZ3YgOiBzZWxmLl9jb3B5RG91YmxlRGFzaChhcmd2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhbmRsZSAnaGVscCcgYW5kICd2ZXJzaW9uJyBvcHRpb25zXG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlbid0IGFscmVhZHkgb3V0cHV0IGhlbHAhXG4gICAgICAgICAgICBpZiAoIWhhc091dHB1dCkge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGFyZ3YpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBoZWxwT3B0ICYmIGFyZ3Zba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXRQcm9jZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJsb2NraW5nKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zaG93SGVscCgnbG9nJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmV4aXQoMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSB2ZXJzaW9uT3B0ICYmIGFyZ3Zba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXRQcm9jZXNzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEJsb2NraW5nKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNhZ2Uuc2hvd1ZlcnNpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuZXhpdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgYW55IG9mIHRoZSBvcHRpb25zIHRvIHNraXAgdmFsaWRhdGlvbiB3ZXJlIHByb3ZpZGVkXG4gICAgICAgICAgICBpZiAoIXNraXBWYWxpZGF0aW9uICYmIG9wdGlvbnMuc2tpcFZhbGlkYXRpb24ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHNraXBWYWxpZGF0aW9uID0gT2JqZWN0LmtleXMoYXJndikuc29tZShrZXkgPT4gb3B0aW9ucy5za2lwVmFsaWRhdGlvbi5pbmRleE9mKGtleSkgPj0gMCAmJiBhcmd2W2tleV0gPT09IHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGhlbHAgb3IgdmVyc2lvbiBvcHRpb25zIHdoZXJlIHVzZWQgYW5kIGV4aXRQcm9jZXNzIGlzIGZhbHNlLFxuICAgICAgICAgICAgLy8gb3IgaWYgZXhwbGljaXRseSBza2lwcGVkLCB3ZSB3b24ndCBydW4gdmFsaWRhdGlvbnMuXG4gICAgICAgICAgICBpZiAoIXNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZC5lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IHllcnJvcl8xLllFcnJvcihwYXJzZWQuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgZXhlY3V0ZWQgdmlhIGJhc2ggY29tcGxldGlvbiwgZG9uJ3RcbiAgICAgICAgICAgICAgICAvLyBib3RoZXIgd2l0aCB2YWxpZGF0aW9uLlxuICAgICAgICAgICAgICAgIGlmICghcmVxdWVzdENvbXBsZXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3J1blZhbGlkYXRpb24oYXJndiwgYWxpYXNlcywge30sIHBhcnNlZC5lcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiB5ZXJyb3JfMS5ZRXJyb3IpXG4gICAgICAgICAgICAgICAgdXNhZ2UuZmFpbChlcnIubWVzc2FnZSwgZXJyKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChwb3B1bGF0ZURvdWJsZURhc2ggfHwgX2NhbGxlZEZyb21Db21tYW5kKSA/IGFyZ3YgOiBzZWxmLl9jb3B5RG91YmxlRGFzaChhcmd2KTtcbiAgICB9O1xuICAgIC8vIHRvIHNpbXBsaWZ5IHRoZSBwYXJzaW5nIG9mIHBvc2l0aW9uYWxzIGluIGNvbW1hbmRzLFxuICAgIC8vIHdlIHRlbXBvcmFyaWx5IHBvcHVsYXRlICctLScgcmF0aGVyIHRoYW4gXywgd2l0aCBhcmd1bWVudHNcbiAgICAvLyBhZnRlciB0aGUgJy0tJyBkaXJlY3RpdmUuIEFmdGVyIHRoZSBwYXJzZSwgd2UgY29weSB0aGVzZSBiYWNrLlxuICAgIHNlbGYuX2NvcHlEb3VibGVEYXNoID0gZnVuY3Rpb24gKGFyZ3YpIHtcbiAgICAgICAgaWYgKGlzX3Byb21pc2VfMS5pc1Byb21pc2UoYXJndikgfHwgIWFyZ3YuXyB8fCAhYXJndlsnLS0nXSlcbiAgICAgICAgICAgIHJldHVybiBhcmd2O1xuICAgICAgICBhcmd2Ll8ucHVzaC5hcHBseShhcmd2Ll8sIGFyZ3ZbJy0tJ10pO1xuICAgICAgICAvLyBUT0RPKGJjb2UpOiByZWZhY3RvciBjb21tYW5kIHBhcnNpbmcgc3VjaCB0aGF0IHRoaXMgZGVsZXRlIGlzIG5vdFxuICAgICAgICAvLyBuZWNlc3Nhcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS95YXJncy95YXJncy9pc3N1ZXMvMTQ4MlxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGVsZXRlIGFyZ3ZbJy0tJ107XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9lcnIpIHsgfVxuICAgICAgICByZXR1cm4gYXJndjtcbiAgICB9O1xuICAgIHNlbGYuX3J1blZhbGlkYXRpb24gPSBmdW5jdGlvbiBydW5WYWxpZGF0aW9uKGFyZ3YsIGFsaWFzZXMsIHBvc2l0aW9uYWxNYXAsIHBhcnNlRXJyb3JzLCBpc0RlZmF1bHRDb21tYW5kID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHBhcnNlRXJyb3JzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IHllcnJvcl8xLllFcnJvcihwYXJzZUVycm9ycy5tZXNzYWdlKTtcbiAgICAgICAgdmFsaWRhdGlvbi5ub25PcHRpb25Db3VudChhcmd2KTtcbiAgICAgICAgdmFsaWRhdGlvbi5yZXF1aXJlZEFyZ3VtZW50cyhhcmd2KTtcbiAgICAgICAgbGV0IGZhaWxlZFN0cmljdENvbW1hbmRzID0gZmFsc2U7XG4gICAgICAgIGlmIChzdHJpY3RDb21tYW5kcykge1xuICAgICAgICAgICAgZmFpbGVkU3RyaWN0Q29tbWFuZHMgPSB2YWxpZGF0aW9uLnVua25vd25Db21tYW5kcyhhcmd2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaWN0ICYmICFmYWlsZWRTdHJpY3RDb21tYW5kcykge1xuICAgICAgICAgICAgdmFsaWRhdGlvbi51bmtub3duQXJndW1lbnRzKGFyZ3YsIGFsaWFzZXMsIHBvc2l0aW9uYWxNYXAsIGlzRGVmYXVsdENvbW1hbmQpO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRpb24uY3VzdG9tQ2hlY2tzKGFyZ3YsIGFsaWFzZXMpO1xuICAgICAgICB2YWxpZGF0aW9uLmxpbWl0ZWRDaG9pY2VzKGFyZ3YpO1xuICAgICAgICB2YWxpZGF0aW9uLmltcGxpY2F0aW9ucyhhcmd2KTtcbiAgICAgICAgdmFsaWRhdGlvbi5jb25mbGljdGluZyhhcmd2KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGd1ZXNzTG9jYWxlKCkge1xuICAgICAgICBpZiAoIWRldGVjdExvY2FsZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbG9jYWxlID0gcHJvY2Vzcy5lbnYuTENfQUxMIHx8IHByb2Nlc3MuZW52LkxDX01FU1NBR0VTIHx8IHByb2Nlc3MuZW52LkxBTkcgfHwgcHJvY2Vzcy5lbnYuTEFOR1VBR0UgfHwgJ2VuX1VTJztcbiAgICAgICAgc2VsZi5sb2NhbGUobG9jYWxlLnJlcGxhY2UoL1suOl0uKi8sICcnKSk7XG4gICAgfVxuICAgIC8vIGFuIGFwcCBzaG91bGQgYWxtb3N0IGFsd2F5cyBoYXZlIC0tdmVyc2lvbiBhbmQgLS1oZWxwLFxuICAgIC8vIGlmIHlvdSAqcmVhbGx5KiB3YW50IHRvIGRpc2FibGUgdGhpcyB1c2UgLmhlbHAoZmFsc2UpLy52ZXJzaW9uKGZhbHNlKS5cbiAgICBzZWxmLmhlbHAoKTtcbiAgICBzZWxmLnZlcnNpb24oKTtcbiAgICByZXR1cm4gc2VsZjtcbn1cbmV4cG9ydHMuWWFyZ3MgPSBZYXJncztcbi8vIHJlYmFzZSBhbiBhYnNvbHV0ZSBwYXRoIHRvIGEgcmVsYXRpdmUgb25lIHdpdGggcmVzcGVjdCB0byBhIGJhc2UgZGlyZWN0b3J5XG4vLyBleHBvcnRlZCBmb3IgdGVzdHNcbmZ1bmN0aW9uIHJlYmFzZShiYXNlLCBkaXIpIHtcbiAgICByZXR1cm4gcGF0aC5yZWxhdGl2ZShiYXNlLCBkaXIpO1xufVxuZXhwb3J0cy5yZWJhc2UgPSByZWJhc2U7XG5mdW5jdGlvbiBpc1lhcmdzSW5zdGFuY2UoeSkge1xuICAgIHJldHVybiAhIXkgJiYgKHR5cGVvZiB5Ll9wYXJzZUFyZ3MgPT09ICdmdW5jdGlvbicpO1xufVxuZXhwb3J0cy5pc1lhcmdzSW5zdGFuY2UgPSBpc1lhcmdzSW5zdGFuY2U7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isCommandBuilderCallback = exports.isCommandBuilderDefinition = exports.isCommandHandlerDefinition = exports.command = void 0;\nconst common_types_1 = __webpack_require__(1);\nconst is_promise_1 = __webpack_require__(5);\nconst middleware_1 = __webpack_require__(21);\nconst parse_command_1 = __webpack_require__(11);\nconst path = __webpack_require__(0);\nconst util_1 = __webpack_require__(3);\nconst yargs_1 = __webpack_require__(19);\nconst requireDirectory = __webpack_require__(51);\nconst whichModule = __webpack_require__(52);\nconst Parser = __webpack_require__(12);\nconst DEFAULT_MARKER = /(^\\*)|(^\\$0)/;\n// handles parsing positional arguments,\n// and populating argv with said positional\n// arguments.\nfunction command(yargs, usage, validation, globalMiddleware = []) {\n    const self = {};\n    let handlers = {};\n    let aliasMap = {};\n    let defaultCommand;\n    self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {\n        let aliases = [];\n        const middlewares = middleware_1.commandMiddlewareFactory(commandMiddleware);\n        handler = handler || (() => { });\n        if (Array.isArray(cmd)) {\n            aliases = cmd.slice(1);\n            cmd = cmd[0];\n        }\n        else if (isCommandHandlerDefinition(cmd)) {\n            let command = (Array.isArray(cmd.command) || typeof cmd.command === 'string') ? cmd.command : moduleName(cmd);\n            if (cmd.aliases)\n                command = [].concat(command).concat(cmd.aliases);\n            self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);\n            return;\n        }\n        // allow a module to be provided instead of separate builder and handler\n        if (isCommandBuilderDefinition(builder)) {\n            self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);\n            return;\n        }\n        // parse positionals out of cmd string\n        const parsedCommand = parse_command_1.parseCommand(cmd);\n        // remove positional args from aliases only\n        aliases = aliases.map(alias => parse_command_1.parseCommand(alias).cmd);\n        // check for default and filter out '*''\n        let isDefault = false;\n        const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c) => {\n            if (DEFAULT_MARKER.test(c)) {\n                isDefault = true;\n                return false;\n            }\n            return true;\n        });\n        // standardize on $0 for default command.\n        if (parsedAliases.length === 0 && isDefault)\n            parsedAliases.push('$0');\n        // shift cmd and aliases after filtering out '*'\n        if (isDefault) {\n            parsedCommand.cmd = parsedAliases[0];\n            aliases = parsedAliases.slice(1);\n            cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);\n        }\n        // populate aliasMap\n        aliases.forEach((alias) => {\n            aliasMap[alias] = parsedCommand.cmd;\n        });\n        if (description !== false) {\n            usage.command(cmd, description, isDefault, aliases, deprecated);\n        }\n        handlers[parsedCommand.cmd] = {\n            original: cmd,\n            description,\n            handler,\n            builder: builder || {},\n            middlewares,\n            deprecated,\n            demanded: parsedCommand.demanded,\n            optional: parsedCommand.optional\n        };\n        if (isDefault)\n            defaultCommand = handlers[parsedCommand.cmd];\n    };\n    self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {\n        opts = opts || {};\n        // disable recursion to support nested directories of subcommands\n        if (typeof opts.recurse !== 'boolean')\n            opts.recurse = false;\n        // exclude 'json', 'coffee' from require-directory defaults\n        if (!Array.isArray(opts.extensions))\n            opts.extensions = ['js'];\n        // allow consumer to define their own visitor function\n        const parentVisit = typeof opts.visit === 'function' ? opts.visit : (o) => o;\n        // call addHandler via visitor function\n        opts.visit = function visit(obj, joined, filename) {\n            const visited = parentVisit(obj, joined, filename);\n            // allow consumer to skip modules with their own visitor\n            if (visited) {\n                // check for cyclic reference\n                // each command file path should only be seen once per execution\n                if (~context.files.indexOf(joined))\n                    return visited;\n                // keep track of visited files in context.files\n                context.files.push(joined);\n                self.addHandler(visited);\n            }\n            return visited;\n        };\n        requireDirectory({ require: req, filename: callerFile }, dir, opts);\n    };\n    // lookup module object from require()d command and derive name\n    // if module was not require()d and no name given, throw error\n    function moduleName(obj) {\n        const mod = whichModule(obj);\n        if (!mod)\n            throw new Error(`No command name given for module: ${util_1.inspect(obj)}`);\n        return commandFromFilename(mod.filename);\n    }\n    // derive command name from filename\n    function commandFromFilename(filename) {\n        return path.basename(filename, path.extname(filename));\n    }\n    function extractDesc({ describe, description, desc }) {\n        for (const test of [describe, description, desc]) {\n            if (typeof test === 'string' || test === false)\n                return test;\n            common_types_1.assertNotStrictEqual(test, true);\n        }\n        return false;\n    }\n    self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));\n    self.getCommandHandlers = () => handlers;\n    self.hasDefaultCommand = () => !!defaultCommand;\n    self.runCommand = function runCommand(command, yargs, parsed, commandIndex) {\n        let aliases = parsed.aliases;\n        const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;\n        const currentContext = yargs.getContext();\n        let numFiles = currentContext.files.length;\n        const parentCommands = currentContext.commands.slice();\n        // what does yargs look like after the builder is run?\n        let innerArgv = parsed.argv;\n        let positionalMap = {};\n        if (command) {\n            currentContext.commands.push(command);\n            currentContext.fullCommands.push(commandHandler.original);\n        }\n        const builder = commandHandler.builder;\n        if (isCommandBuilderCallback(builder)) {\n            // a function can be provided, which builds\n            // up a yargs chain and possibly returns it.\n            const builderOutput = builder(yargs.reset(parsed.aliases));\n            const innerYargs = yargs_1.isYargsInstance(builderOutput) ? builderOutput : yargs;\n            if (shouldUpdateUsage(innerYargs)) {\n                innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n            }\n            innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n            aliases = innerYargs.parsed.aliases;\n        }\n        else if (isCommandBuilderOptionDefinitions(builder)) {\n            // as a short hand, an object can instead be provided, specifying\n            // the options that a command takes.\n            const innerYargs = yargs.reset(parsed.aliases);\n            if (shouldUpdateUsage(innerYargs)) {\n                innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n            }\n            Object.keys(commandHandler.builder).forEach((key) => {\n                innerYargs.option(key, builder[key]);\n            });\n            innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n            aliases = innerYargs.parsed.aliases;\n        }\n        if (!yargs._hasOutput()) {\n            positionalMap = populatePositionals(commandHandler, innerArgv, currentContext);\n        }\n        const middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares);\n        middleware_1.applyMiddleware(innerArgv, yargs, middlewares, true);\n        // we apply validation post-hoc, so that custom\n        // checks get passed populated positional arguments.\n        if (!yargs._hasOutput()) {\n            yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error, !command);\n        }\n        if (commandHandler.handler && !yargs._hasOutput()) {\n            yargs._setHasOutput();\n            // to simplify the parsing of positionals in commands,\n            // we temporarily populate '--' rather than _, with arguments\n            const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];\n            if (!populateDoubleDash)\n                yargs._copyDoubleDash(innerArgv);\n            innerArgv = middleware_1.applyMiddleware(innerArgv, yargs, middlewares, false);\n            let handlerResult;\n            if (is_promise_1.isPromise(innerArgv)) {\n                handlerResult = innerArgv.then(argv => commandHandler.handler(argv));\n            }\n            else {\n                handlerResult = commandHandler.handler(innerArgv);\n            }\n            const handlerFinishCommand = yargs.getHandlerFinishCommand();\n            if (is_promise_1.isPromise(handlerResult)) {\n                yargs.getUsageInstance().cacheHelpMessage();\n                handlerResult\n                    .then(value => {\n                    if (handlerFinishCommand) {\n                        handlerFinishCommand(value);\n                    }\n                })\n                    .catch(error => {\n                    try {\n                        yargs.getUsageInstance().fail(null, error);\n                    }\n                    catch (err) {\n                        // fail's throwing would cause an unhandled rejection.\n                    }\n                })\n                    .then(() => {\n                    yargs.getUsageInstance().clearCachedHelpMessage();\n                });\n            }\n            else {\n                if (handlerFinishCommand) {\n                    handlerFinishCommand(handlerResult);\n                }\n            }\n        }\n        if (command) {\n            currentContext.commands.pop();\n            currentContext.fullCommands.pop();\n        }\n        numFiles = currentContext.files.length - numFiles;\n        if (numFiles > 0)\n            currentContext.files.splice(numFiles * -1, numFiles);\n        return innerArgv;\n    };\n    function shouldUpdateUsage(yargs) {\n        return !yargs.getUsageInstance().getUsageDisabled() &&\n            yargs.getUsageInstance().getUsage().length === 0;\n    }\n    function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {\n        const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original;\n        const pc = parentCommands.filter((c) => { return !DEFAULT_MARKER.test(c); });\n        pc.push(c);\n        return `$0 ${pc.join(' ')}`;\n    }\n    self.runDefaultBuilderOn = function (yargs) {\n        common_types_1.assertNotStrictEqual(defaultCommand, undefined);\n        if (shouldUpdateUsage(yargs)) {\n            // build the root-level command string from the default string.\n            const commandString = DEFAULT_MARKER.test(defaultCommand.original)\n                ? defaultCommand.original : defaultCommand.original.replace(/^[^[\\]<>]*/, '$0 ');\n            yargs.getUsageInstance().usage(commandString, defaultCommand.description);\n        }\n        const builder = defaultCommand.builder;\n        if (isCommandBuilderCallback(builder)) {\n            builder(yargs);\n        }\n        else {\n            Object.keys(builder).forEach((key) => {\n                yargs.option(key, builder[key]);\n            });\n        }\n    };\n    // transcribe all positional arguments \"command <foo> <bar> [apple]\"\n    // onto argv.\n    function populatePositionals(commandHandler, argv, context) {\n        argv._ = argv._.slice(context.commands.length); // nuke the current commands\n        const demanded = commandHandler.demanded.slice(0);\n        const optional = commandHandler.optional.slice(0);\n        const positionalMap = {};\n        validation.positionalCount(demanded.length, argv._.length);\n        while (demanded.length) {\n            const demand = demanded.shift();\n            populatePositional(demand, argv, positionalMap);\n        }\n        while (optional.length) {\n            const maybe = optional.shift();\n            populatePositional(maybe, argv, positionalMap);\n        }\n        argv._ = context.commands.concat(argv._);\n        postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));\n        return positionalMap;\n    }\n    function populatePositional(positional, argv, positionalMap) {\n        const cmd = positional.cmd[0];\n        if (positional.variadic) {\n            positionalMap[cmd] = argv._.splice(0).map(String);\n        }\n        else {\n            if (argv._.length)\n                positionalMap[cmd] = [String(argv._.shift())];\n        }\n    }\n    // we run yargs-parser against the positional arguments\n    // applying the same parsing logic used for flags.\n    function postProcessPositionals(argv, positionalMap, parseOptions) {\n        // combine the parsing hints we've inferred from the command\n        // string with explicitly configured parsing hints.\n        const options = Object.assign({}, yargs.getOptions());\n        options.default = Object.assign(parseOptions.default, options.default);\n        for (const key of Object.keys(parseOptions.alias)) {\n            options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);\n        }\n        options.array = options.array.concat(parseOptions.array);\n        delete options.config; //  don't load config when processing positionals.\n        const unparsed = [];\n        Object.keys(positionalMap).forEach((key) => {\n            positionalMap[key].map((value) => {\n                if (options.configuration['unknown-options-as-args'])\n                    options.key[key] = true;\n                unparsed.push(`--${key}`);\n                unparsed.push(value);\n            });\n        });\n        // short-circuit parse.\n        if (!unparsed.length)\n            return;\n        const config = Object.assign({}, options.configuration, {\n            'populate--': true\n        });\n        const parsed = Parser.detailed(unparsed, Object.assign({}, options, {\n            configuration: config\n        }));\n        if (parsed.error) {\n            yargs.getUsageInstance().fail(parsed.error.message, parsed.error);\n        }\n        else {\n            // only copy over positional keys (don't overwrite\n            // flag arguments that were already parsed).\n            const positionalKeys = Object.keys(positionalMap);\n            Object.keys(positionalMap).forEach((key) => {\n                positionalKeys.push(...parsed.aliases[key]);\n            });\n            Object.keys(parsed.argv).forEach((key) => {\n                if (positionalKeys.indexOf(key) !== -1) {\n                    // any new aliases need to be placed in positionalMap, which\n                    // is used for validation.\n                    if (!positionalMap[key])\n                        positionalMap[key] = parsed.argv[key];\n                    argv[key] = parsed.argv[key];\n                }\n            });\n        }\n    }\n    self.cmdToParseOptions = function (cmdString) {\n        const parseOptions = {\n            array: [],\n            default: {},\n            alias: {},\n            demand: {}\n        };\n        const parsed = parse_command_1.parseCommand(cmdString);\n        parsed.demanded.forEach((d) => {\n            const [cmd, ...aliases] = d.cmd;\n            if (d.variadic) {\n                parseOptions.array.push(cmd);\n                parseOptions.default[cmd] = [];\n            }\n            parseOptions.alias[cmd] = aliases;\n            parseOptions.demand[cmd] = true;\n        });\n        parsed.optional.forEach((o) => {\n            const [cmd, ...aliases] = o.cmd;\n            if (o.variadic) {\n                parseOptions.array.push(cmd);\n                parseOptions.default[cmd] = [];\n            }\n            parseOptions.alias[cmd] = aliases;\n        });\n        return parseOptions;\n    };\n    self.reset = () => {\n        handlers = {};\n        aliasMap = {};\n        defaultCommand = undefined;\n        return self;\n    };\n    // used by yargs.parse() to freeze\n    // the state of commands such that\n    // we can apply .parse() multiple times\n    // with the same yargs instance.\n    const frozens = [];\n    self.freeze = () => {\n        frozens.push({\n            handlers,\n            aliasMap,\n            defaultCommand\n        });\n    };\n    self.unfreeze = () => {\n        const frozen = frozens.pop();\n        common_types_1.assertNotStrictEqual(frozen, undefined);\n        ({\n            handlers,\n            aliasMap,\n            defaultCommand\n        } = frozen);\n    };\n    return self;\n}\nexports.command = command;\nfunction isCommandHandlerDefinition(cmd) {\n    return typeof cmd === 'object';\n}\nexports.isCommandHandlerDefinition = isCommandHandlerDefinition;\nfunction isCommandBuilderDefinition(builder) {\n    return typeof builder === 'object' &&\n        !!builder.builder &&\n        typeof builder.handler === 'function';\n}\nexports.isCommandBuilderDefinition = isCommandBuilderDefinition;\nfunction isCommandBuilderCallback(builder) {\n    return typeof builder === 'function';\n}\nexports.isCommandBuilderCallback = isCommandBuilderCallback;\nfunction isCommandBuilderOptionDefinitions(builder) {\n    return typeof builder === 'object';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliL2NvbW1hbmQuanM/MTZmNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsQ0FBZ0I7QUFDL0MscUJBQXFCLG1CQUFPLENBQUMsQ0FBYztBQUMzQyxxQkFBcUIsbUJBQU8sQ0FBQyxFQUFjO0FBQzNDLHdCQUF3QixtQkFBTyxDQUFDLEVBQWlCO0FBQ2pELGFBQWEsbUJBQU8sQ0FBQyxDQUFNO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxDQUFNO0FBQzdCLGdCQUFnQixtQkFBTyxDQUFDLEVBQVM7QUFDakMseUJBQXlCLG1CQUFPLENBQUMsRUFBbUI7QUFDcEQsb0JBQW9CLG1CQUFPLENBQUMsRUFBYztBQUMxQyxlQUFlLG1CQUFPLENBQUMsRUFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsRUFBRTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFDQUFxQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsb0JBQW9CO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxnQ0FBZ0MsRUFBRTtBQUNuRjtBQUNBLHFCQUFxQixhQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLElBQUk7QUFDdkM7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBLFNBQVM7QUFDVCxpRUFBaUU7QUFDakU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNDb21tYW5kQnVpbGRlckNhbGxiYWNrID0gZXhwb3J0cy5pc0NvbW1hbmRCdWlsZGVyRGVmaW5pdGlvbiA9IGV4cG9ydHMuaXNDb21tYW5kSGFuZGxlckRlZmluaXRpb24gPSBleHBvcnRzLmNvbW1hbmQgPSB2b2lkIDA7XG5jb25zdCBjb21tb25fdHlwZXNfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi10eXBlc1wiKTtcbmNvbnN0IGlzX3Byb21pc2VfMSA9IHJlcXVpcmUoXCIuL2lzLXByb21pc2VcIik7XG5jb25zdCBtaWRkbGV3YXJlXzEgPSByZXF1aXJlKFwiLi9taWRkbGV3YXJlXCIpO1xuY29uc3QgcGFyc2VfY29tbWFuZF8xID0gcmVxdWlyZShcIi4vcGFyc2UtY29tbWFuZFwiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCJ1dGlsXCIpO1xuY29uc3QgeWFyZ3NfMSA9IHJlcXVpcmUoXCIuL3lhcmdzXCIpO1xuY29uc3QgcmVxdWlyZURpcmVjdG9yeSA9IHJlcXVpcmUoXCJyZXF1aXJlLWRpcmVjdG9yeVwiKTtcbmNvbnN0IHdoaWNoTW9kdWxlID0gcmVxdWlyZShcIndoaWNoLW1vZHVsZVwiKTtcbmNvbnN0IFBhcnNlciA9IHJlcXVpcmUoXCJ5YXJncy1wYXJzZXJcIik7XG5jb25zdCBERUZBVUxUX01BUktFUiA9IC8oXlxcKil8KF5cXCQwKS87XG4vLyBoYW5kbGVzIHBhcnNpbmcgcG9zaXRpb25hbCBhcmd1bWVudHMsXG4vLyBhbmQgcG9wdWxhdGluZyBhcmd2IHdpdGggc2FpZCBwb3NpdGlvbmFsXG4vLyBhcmd1bWVudHMuXG5mdW5jdGlvbiBjb21tYW5kKHlhcmdzLCB1c2FnZSwgdmFsaWRhdGlvbiwgZ2xvYmFsTWlkZGxld2FyZSA9IFtdKSB7XG4gICAgY29uc3Qgc2VsZiA9IHt9O1xuICAgIGxldCBoYW5kbGVycyA9IHt9O1xuICAgIGxldCBhbGlhc01hcCA9IHt9O1xuICAgIGxldCBkZWZhdWx0Q29tbWFuZDtcbiAgICBzZWxmLmFkZEhhbmRsZXIgPSBmdW5jdGlvbiBhZGRIYW5kbGVyKGNtZCwgZGVzY3JpcHRpb24sIGJ1aWxkZXIsIGhhbmRsZXIsIGNvbW1hbmRNaWRkbGV3YXJlLCBkZXByZWNhdGVkKSB7XG4gICAgICAgIGxldCBhbGlhc2VzID0gW107XG4gICAgICAgIGNvbnN0IG1pZGRsZXdhcmVzID0gbWlkZGxld2FyZV8xLmNvbW1hbmRNaWRkbGV3YXJlRmFjdG9yeShjb21tYW5kTWlkZGxld2FyZSk7XG4gICAgICAgIGhhbmRsZXIgPSBoYW5kbGVyIHx8ICgoKSA9PiB7IH0pO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjbWQpKSB7XG4gICAgICAgICAgICBhbGlhc2VzID0gY21kLnNsaWNlKDEpO1xuICAgICAgICAgICAgY21kID0gY21kWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQ29tbWFuZEhhbmRsZXJEZWZpbml0aW9uKGNtZCkpIHtcbiAgICAgICAgICAgIGxldCBjb21tYW5kID0gKEFycmF5LmlzQXJyYXkoY21kLmNvbW1hbmQpIHx8IHR5cGVvZiBjbWQuY29tbWFuZCA9PT0gJ3N0cmluZycpID8gY21kLmNvbW1hbmQgOiBtb2R1bGVOYW1lKGNtZCk7XG4gICAgICAgICAgICBpZiAoY21kLmFsaWFzZXMpXG4gICAgICAgICAgICAgICAgY29tbWFuZCA9IFtdLmNvbmNhdChjb21tYW5kKS5jb25jYXQoY21kLmFsaWFzZXMpO1xuICAgICAgICAgICAgc2VsZi5hZGRIYW5kbGVyKGNvbW1hbmQsIGV4dHJhY3REZXNjKGNtZCksIGNtZC5idWlsZGVyLCBjbWQuaGFuZGxlciwgY21kLm1pZGRsZXdhcmVzLCBjbWQuZGVwcmVjYXRlZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWxsb3cgYSBtb2R1bGUgdG8gYmUgcHJvdmlkZWQgaW5zdGVhZCBvZiBzZXBhcmF0ZSBidWlsZGVyIGFuZCBoYW5kbGVyXG4gICAgICAgIGlmIChpc0NvbW1hbmRCdWlsZGVyRGVmaW5pdGlvbihidWlsZGVyKSkge1xuICAgICAgICAgICAgc2VsZi5hZGRIYW5kbGVyKFtjbWRdLmNvbmNhdChhbGlhc2VzKSwgZGVzY3JpcHRpb24sIGJ1aWxkZXIuYnVpbGRlciwgYnVpbGRlci5oYW5kbGVyLCBidWlsZGVyLm1pZGRsZXdhcmVzLCBidWlsZGVyLmRlcHJlY2F0ZWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhcnNlIHBvc2l0aW9uYWxzIG91dCBvZiBjbWQgc3RyaW5nXG4gICAgICAgIGNvbnN0IHBhcnNlZENvbW1hbmQgPSBwYXJzZV9jb21tYW5kXzEucGFyc2VDb21tYW5kKGNtZCk7XG4gICAgICAgIC8vIHJlbW92ZSBwb3NpdGlvbmFsIGFyZ3MgZnJvbSBhbGlhc2VzIG9ubHlcbiAgICAgICAgYWxpYXNlcyA9IGFsaWFzZXMubWFwKGFsaWFzID0+IHBhcnNlX2NvbW1hbmRfMS5wYXJzZUNvbW1hbmQoYWxpYXMpLmNtZCk7XG4gICAgICAgIC8vIGNoZWNrIGZvciBkZWZhdWx0IGFuZCBmaWx0ZXIgb3V0ICcqJydcbiAgICAgICAgbGV0IGlzRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBwYXJzZWRBbGlhc2VzID0gW3BhcnNlZENvbW1hbmQuY21kXS5jb25jYXQoYWxpYXNlcykuZmlsdGVyKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoREVGQVVMVF9NQVJLRVIudGVzdChjKSkge1xuICAgICAgICAgICAgICAgIGlzRGVmYXVsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBzdGFuZGFyZGl6ZSBvbiAkMCBmb3IgZGVmYXVsdCBjb21tYW5kLlxuICAgICAgICBpZiAocGFyc2VkQWxpYXNlcy5sZW5ndGggPT09IDAgJiYgaXNEZWZhdWx0KVxuICAgICAgICAgICAgcGFyc2VkQWxpYXNlcy5wdXNoKCckMCcpO1xuICAgICAgICAvLyBzaGlmdCBjbWQgYW5kIGFsaWFzZXMgYWZ0ZXIgZmlsdGVyaW5nIG91dCAnKidcbiAgICAgICAgaWYgKGlzRGVmYXVsdCkge1xuICAgICAgICAgICAgcGFyc2VkQ29tbWFuZC5jbWQgPSBwYXJzZWRBbGlhc2VzWzBdO1xuICAgICAgICAgICAgYWxpYXNlcyA9IHBhcnNlZEFsaWFzZXMuc2xpY2UoMSk7XG4gICAgICAgICAgICBjbWQgPSBjbWQucmVwbGFjZShERUZBVUxUX01BUktFUiwgcGFyc2VkQ29tbWFuZC5jbWQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBvcHVsYXRlIGFsaWFzTWFwXG4gICAgICAgIGFsaWFzZXMuZm9yRWFjaCgoYWxpYXMpID0+IHtcbiAgICAgICAgICAgIGFsaWFzTWFwW2FsaWFzXSA9IHBhcnNlZENvbW1hbmQuY21kO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdXNhZ2UuY29tbWFuZChjbWQsIGRlc2NyaXB0aW9uLCBpc0RlZmF1bHQsIGFsaWFzZXMsIGRlcHJlY2F0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZXJzW3BhcnNlZENvbW1hbmQuY21kXSA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsOiBjbWQsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICBidWlsZGVyOiBidWlsZGVyIHx8IHt9LFxuICAgICAgICAgICAgbWlkZGxld2FyZXMsXG4gICAgICAgICAgICBkZXByZWNhdGVkLFxuICAgICAgICAgICAgZGVtYW5kZWQ6IHBhcnNlZENvbW1hbmQuZGVtYW5kZWQsXG4gICAgICAgICAgICBvcHRpb25hbDogcGFyc2VkQ29tbWFuZC5vcHRpb25hbFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNEZWZhdWx0KVxuICAgICAgICAgICAgZGVmYXVsdENvbW1hbmQgPSBoYW5kbGVyc1twYXJzZWRDb21tYW5kLmNtZF07XG4gICAgfTtcbiAgICBzZWxmLmFkZERpcmVjdG9yeSA9IGZ1bmN0aW9uIGFkZERpcmVjdG9yeShkaXIsIGNvbnRleHQsIHJlcSwgY2FsbGVyRmlsZSwgb3B0cykge1xuICAgICAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAgICAgLy8gZGlzYWJsZSByZWN1cnNpb24gdG8gc3VwcG9ydCBuZXN0ZWQgZGlyZWN0b3JpZXMgb2Ygc3ViY29tbWFuZHNcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRzLnJlY3Vyc2UgIT09ICdib29sZWFuJylcbiAgICAgICAgICAgIG9wdHMucmVjdXJzZSA9IGZhbHNlO1xuICAgICAgICAvLyBleGNsdWRlICdqc29uJywgJ2NvZmZlZScgZnJvbSByZXF1aXJlLWRpcmVjdG9yeSBkZWZhdWx0c1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3B0cy5leHRlbnNpb25zKSlcbiAgICAgICAgICAgIG9wdHMuZXh0ZW5zaW9ucyA9IFsnanMnXTtcbiAgICAgICAgLy8gYWxsb3cgY29uc3VtZXIgdG8gZGVmaW5lIHRoZWlyIG93biB2aXNpdG9yIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHBhcmVudFZpc2l0ID0gdHlwZW9mIG9wdHMudmlzaXQgPT09ICdmdW5jdGlvbicgPyBvcHRzLnZpc2l0IDogKG8pID0+IG87XG4gICAgICAgIC8vIGNhbGwgYWRkSGFuZGxlciB2aWEgdmlzaXRvciBmdW5jdGlvblxuICAgICAgICBvcHRzLnZpc2l0ID0gZnVuY3Rpb24gdmlzaXQob2JqLCBqb2luZWQsIGZpbGVuYW1lKSB7XG4gICAgICAgICAgICBjb25zdCB2aXNpdGVkID0gcGFyZW50VmlzaXQob2JqLCBqb2luZWQsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgIC8vIGFsbG93IGNvbnN1bWVyIHRvIHNraXAgbW9kdWxlcyB3aXRoIHRoZWlyIG93biB2aXNpdG9yXG4gICAgICAgICAgICBpZiAodmlzaXRlZCkge1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGZvciBjeWNsaWMgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgLy8gZWFjaCBjb21tYW5kIGZpbGUgcGF0aCBzaG91bGQgb25seSBiZSBzZWVuIG9uY2UgcGVyIGV4ZWN1dGlvblxuICAgICAgICAgICAgICAgIGlmICh+Y29udGV4dC5maWxlcy5pbmRleE9mKGpvaW5lZCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2aXNpdGVkO1xuICAgICAgICAgICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgdmlzaXRlZCBmaWxlcyBpbiBjb250ZXh0LmZpbGVzXG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxlcy5wdXNoKGpvaW5lZCk7XG4gICAgICAgICAgICAgICAgc2VsZi5hZGRIYW5kbGVyKHZpc2l0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZpc2l0ZWQ7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVpcmVEaXJlY3RvcnkoeyByZXF1aXJlOiByZXEsIGZpbGVuYW1lOiBjYWxsZXJGaWxlIH0sIGRpciwgb3B0cyk7XG4gICAgfTtcbiAgICAvLyBsb29rdXAgbW9kdWxlIG9iamVjdCBmcm9tIHJlcXVpcmUoKWQgY29tbWFuZCBhbmQgZGVyaXZlIG5hbWVcbiAgICAvLyBpZiBtb2R1bGUgd2FzIG5vdCByZXF1aXJlKClkIGFuZCBubyBuYW1lIGdpdmVuLCB0aHJvdyBlcnJvclxuICAgIGZ1bmN0aW9uIG1vZHVsZU5hbWUob2JqKSB7XG4gICAgICAgIGNvbnN0IG1vZCA9IHdoaWNoTW9kdWxlKG9iaik7XG4gICAgICAgIGlmICghbW9kKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBjb21tYW5kIG5hbWUgZ2l2ZW4gZm9yIG1vZHVsZTogJHt1dGlsXzEuaW5zcGVjdChvYmopfWApO1xuICAgICAgICByZXR1cm4gY29tbWFuZEZyb21GaWxlbmFtZShtb2QuZmlsZW5hbWUpO1xuICAgIH1cbiAgICAvLyBkZXJpdmUgY29tbWFuZCBuYW1lIGZyb20gZmlsZW5hbWVcbiAgICBmdW5jdGlvbiBjb21tYW5kRnJvbUZpbGVuYW1lKGZpbGVuYW1lKSB7XG4gICAgICAgIHJldHVybiBwYXRoLmJhc2VuYW1lKGZpbGVuYW1lLCBwYXRoLmV4dG5hbWUoZmlsZW5hbWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXh0cmFjdERlc2MoeyBkZXNjcmliZSwgZGVzY3JpcHRpb24sIGRlc2MgfSkge1xuICAgICAgICBmb3IgKGNvbnN0IHRlc3Qgb2YgW2Rlc2NyaWJlLCBkZXNjcmlwdGlvbiwgZGVzY10pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGVzdCA9PT0gJ3N0cmluZycgfHwgdGVzdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRlc3Q7XG4gICAgICAgICAgICBjb21tb25fdHlwZXNfMS5hc3NlcnROb3RTdHJpY3RFcXVhbCh0ZXN0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNlbGYuZ2V0Q29tbWFuZHMgPSAoKSA9PiBPYmplY3Qua2V5cyhoYW5kbGVycykuY29uY2F0KE9iamVjdC5rZXlzKGFsaWFzTWFwKSk7XG4gICAgc2VsZi5nZXRDb21tYW5kSGFuZGxlcnMgPSAoKSA9PiBoYW5kbGVycztcbiAgICBzZWxmLmhhc0RlZmF1bHRDb21tYW5kID0gKCkgPT4gISFkZWZhdWx0Q29tbWFuZDtcbiAgICBzZWxmLnJ1bkNvbW1hbmQgPSBmdW5jdGlvbiBydW5Db21tYW5kKGNvbW1hbmQsIHlhcmdzLCBwYXJzZWQsIGNvbW1hbmRJbmRleCkge1xuICAgICAgICBsZXQgYWxpYXNlcyA9IHBhcnNlZC5hbGlhc2VzO1xuICAgICAgICBjb25zdCBjb21tYW5kSGFuZGxlciA9IGhhbmRsZXJzW2NvbW1hbmRdIHx8IGhhbmRsZXJzW2FsaWFzTWFwW2NvbW1hbmRdXSB8fCBkZWZhdWx0Q29tbWFuZDtcbiAgICAgICAgY29uc3QgY3VycmVudENvbnRleHQgPSB5YXJncy5nZXRDb250ZXh0KCk7XG4gICAgICAgIGxldCBudW1GaWxlcyA9IGN1cnJlbnRDb250ZXh0LmZpbGVzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcGFyZW50Q29tbWFuZHMgPSBjdXJyZW50Q29udGV4dC5jb21tYW5kcy5zbGljZSgpO1xuICAgICAgICAvLyB3aGF0IGRvZXMgeWFyZ3MgbG9vayBsaWtlIGFmdGVyIHRoZSBidWlsZGVyIGlzIHJ1bj9cbiAgICAgICAgbGV0IGlubmVyQXJndiA9IHBhcnNlZC5hcmd2O1xuICAgICAgICBsZXQgcG9zaXRpb25hbE1hcCA9IHt9O1xuICAgICAgICBpZiAoY29tbWFuZCkge1xuICAgICAgICAgICAgY3VycmVudENvbnRleHQuY29tbWFuZHMucHVzaChjb21tYW5kKTtcbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0LmZ1bGxDb21tYW5kcy5wdXNoKGNvbW1hbmRIYW5kbGVyLm9yaWdpbmFsKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWlsZGVyID0gY29tbWFuZEhhbmRsZXIuYnVpbGRlcjtcbiAgICAgICAgaWYgKGlzQ29tbWFuZEJ1aWxkZXJDYWxsYmFjayhidWlsZGVyKSkge1xuICAgICAgICAgICAgLy8gYSBmdW5jdGlvbiBjYW4gYmUgcHJvdmlkZWQsIHdoaWNoIGJ1aWxkc1xuICAgICAgICAgICAgLy8gdXAgYSB5YXJncyBjaGFpbiBhbmQgcG9zc2libHkgcmV0dXJucyBpdC5cbiAgICAgICAgICAgIGNvbnN0IGJ1aWxkZXJPdXRwdXQgPSBidWlsZGVyKHlhcmdzLnJlc2V0KHBhcnNlZC5hbGlhc2VzKSk7XG4gICAgICAgICAgICBjb25zdCBpbm5lcllhcmdzID0geWFyZ3NfMS5pc1lhcmdzSW5zdGFuY2UoYnVpbGRlck91dHB1dCkgPyBidWlsZGVyT3V0cHV0IDogeWFyZ3M7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVXBkYXRlVXNhZ2UoaW5uZXJZYXJncykpIHtcbiAgICAgICAgICAgICAgICBpbm5lcllhcmdzLmdldFVzYWdlSW5zdGFuY2UoKS51c2FnZSh1c2FnZUZyb21QYXJlbnRDb21tYW5kc0NvbW1hbmRIYW5kbGVyKHBhcmVudENvbW1hbmRzLCBjb21tYW5kSGFuZGxlciksIGNvbW1hbmRIYW5kbGVyLmRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlubmVyQXJndiA9IGlubmVyWWFyZ3MuX3BhcnNlQXJncyhudWxsLCBudWxsLCB0cnVlLCBjb21tYW5kSW5kZXgpO1xuICAgICAgICAgICAgYWxpYXNlcyA9IGlubmVyWWFyZ3MucGFyc2VkLmFsaWFzZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDb21tYW5kQnVpbGRlck9wdGlvbkRlZmluaXRpb25zKGJ1aWxkZXIpKSB7XG4gICAgICAgICAgICAvLyBhcyBhIHNob3J0IGhhbmQsIGFuIG9iamVjdCBjYW4gaW5zdGVhZCBiZSBwcm92aWRlZCwgc3BlY2lmeWluZ1xuICAgICAgICAgICAgLy8gdGhlIG9wdGlvbnMgdGhhdCBhIGNvbW1hbmQgdGFrZXMuXG4gICAgICAgICAgICBjb25zdCBpbm5lcllhcmdzID0geWFyZ3MucmVzZXQocGFyc2VkLmFsaWFzZXMpO1xuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZVVzYWdlKGlubmVyWWFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgaW5uZXJZYXJncy5nZXRVc2FnZUluc3RhbmNlKCkudXNhZ2UodXNhZ2VGcm9tUGFyZW50Q29tbWFuZHNDb21tYW5kSGFuZGxlcihwYXJlbnRDb21tYW5kcywgY29tbWFuZEhhbmRsZXIpLCBjb21tYW5kSGFuZGxlci5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhjb21tYW5kSGFuZGxlci5idWlsZGVyKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpbm5lcllhcmdzLm9wdGlvbihrZXksIGJ1aWxkZXJba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlubmVyQXJndiA9IGlubmVyWWFyZ3MuX3BhcnNlQXJncyhudWxsLCBudWxsLCB0cnVlLCBjb21tYW5kSW5kZXgpO1xuICAgICAgICAgICAgYWxpYXNlcyA9IGlubmVyWWFyZ3MucGFyc2VkLmFsaWFzZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF5YXJncy5faGFzT3V0cHV0KCkpIHtcbiAgICAgICAgICAgIHBvc2l0aW9uYWxNYXAgPSBwb3B1bGF0ZVBvc2l0aW9uYWxzKGNvbW1hbmRIYW5kbGVyLCBpbm5lckFyZ3YsIGN1cnJlbnRDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaWRkbGV3YXJlcyA9IGdsb2JhbE1pZGRsZXdhcmUuc2xpY2UoMCkuY29uY2F0KGNvbW1hbmRIYW5kbGVyLm1pZGRsZXdhcmVzKTtcbiAgICAgICAgbWlkZGxld2FyZV8xLmFwcGx5TWlkZGxld2FyZShpbm5lckFyZ3YsIHlhcmdzLCBtaWRkbGV3YXJlcywgdHJ1ZSk7XG4gICAgICAgIC8vIHdlIGFwcGx5IHZhbGlkYXRpb24gcG9zdC1ob2MsIHNvIHRoYXQgY3VzdG9tXG4gICAgICAgIC8vIGNoZWNrcyBnZXQgcGFzc2VkIHBvcHVsYXRlZCBwb3NpdGlvbmFsIGFyZ3VtZW50cy5cbiAgICAgICAgaWYgKCF5YXJncy5faGFzT3V0cHV0KCkpIHtcbiAgICAgICAgICAgIHlhcmdzLl9ydW5WYWxpZGF0aW9uKGlubmVyQXJndiwgYWxpYXNlcywgcG9zaXRpb25hbE1hcCwgeWFyZ3MucGFyc2VkLmVycm9yLCAhY29tbWFuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1hbmRIYW5kbGVyLmhhbmRsZXIgJiYgIXlhcmdzLl9oYXNPdXRwdXQoKSkge1xuICAgICAgICAgICAgeWFyZ3MuX3NldEhhc091dHB1dCgpO1xuICAgICAgICAgICAgLy8gdG8gc2ltcGxpZnkgdGhlIHBhcnNpbmcgb2YgcG9zaXRpb25hbHMgaW4gY29tbWFuZHMsXG4gICAgICAgICAgICAvLyB3ZSB0ZW1wb3JhcmlseSBwb3B1bGF0ZSAnLS0nIHJhdGhlciB0aGFuIF8sIHdpdGggYXJndW1lbnRzXG4gICAgICAgICAgICBjb25zdCBwb3B1bGF0ZURvdWJsZURhc2ggPSAhIXlhcmdzLmdldE9wdGlvbnMoKS5jb25maWd1cmF0aW9uWydwb3B1bGF0ZS0tJ107XG4gICAgICAgICAgICBpZiAoIXBvcHVsYXRlRG91YmxlRGFzaClcbiAgICAgICAgICAgICAgICB5YXJncy5fY29weURvdWJsZURhc2goaW5uZXJBcmd2KTtcbiAgICAgICAgICAgIGlubmVyQXJndiA9IG1pZGRsZXdhcmVfMS5hcHBseU1pZGRsZXdhcmUoaW5uZXJBcmd2LCB5YXJncywgbWlkZGxld2FyZXMsIGZhbHNlKTtcbiAgICAgICAgICAgIGxldCBoYW5kbGVyUmVzdWx0O1xuICAgICAgICAgICAgaWYgKGlzX3Byb21pc2VfMS5pc1Byb21pc2UoaW5uZXJBcmd2KSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJSZXN1bHQgPSBpbm5lckFyZ3YudGhlbihhcmd2ID0+IGNvbW1hbmRIYW5kbGVyLmhhbmRsZXIoYXJndikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlclJlc3VsdCA9IGNvbW1hbmRIYW5kbGVyLmhhbmRsZXIoaW5uZXJBcmd2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJGaW5pc2hDb21tYW5kID0geWFyZ3MuZ2V0SGFuZGxlckZpbmlzaENvbW1hbmQoKTtcbiAgICAgICAgICAgIGlmIChpc19wcm9taXNlXzEuaXNQcm9taXNlKGhhbmRsZXJSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgeWFyZ3MuZ2V0VXNhZ2VJbnN0YW5jZSgpLmNhY2hlSGVscE1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyUmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJGaW5pc2hDb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyRmluaXNoQ29tbWFuZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyb3IgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWFyZ3MuZ2V0VXNhZ2VJbnN0YW5jZSgpLmZhaWwobnVsbCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZhaWwncyB0aHJvd2luZyB3b3VsZCBjYXVzZSBhbiB1bmhhbmRsZWQgcmVqZWN0aW9uLlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB5YXJncy5nZXRVc2FnZUluc3RhbmNlKCkuY2xlYXJDYWNoZWRIZWxwTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJGaW5pc2hDb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZXJGaW5pc2hDb21tYW5kKGhhbmRsZXJSZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZCkge1xuICAgICAgICAgICAgY3VycmVudENvbnRleHQuY29tbWFuZHMucG9wKCk7XG4gICAgICAgICAgICBjdXJyZW50Q29udGV4dC5mdWxsQ29tbWFuZHMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgbnVtRmlsZXMgPSBjdXJyZW50Q29udGV4dC5maWxlcy5sZW5ndGggLSBudW1GaWxlcztcbiAgICAgICAgaWYgKG51bUZpbGVzID4gMClcbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0LmZpbGVzLnNwbGljZShudW1GaWxlcyAqIC0xLCBudW1GaWxlcyk7XG4gICAgICAgIHJldHVybiBpbm5lckFyZ3Y7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBzaG91bGRVcGRhdGVVc2FnZSh5YXJncykge1xuICAgICAgICByZXR1cm4gIXlhcmdzLmdldFVzYWdlSW5zdGFuY2UoKS5nZXRVc2FnZURpc2FibGVkKCkgJiZcbiAgICAgICAgICAgIHlhcmdzLmdldFVzYWdlSW5zdGFuY2UoKS5nZXRVc2FnZSgpLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXNhZ2VGcm9tUGFyZW50Q29tbWFuZHNDb21tYW5kSGFuZGxlcihwYXJlbnRDb21tYW5kcywgY29tbWFuZEhhbmRsZXIpIHtcbiAgICAgICAgY29uc3QgYyA9IERFRkFVTFRfTUFSS0VSLnRlc3QoY29tbWFuZEhhbmRsZXIub3JpZ2luYWwpID8gY29tbWFuZEhhbmRsZXIub3JpZ2luYWwucmVwbGFjZShERUZBVUxUX01BUktFUiwgJycpLnRyaW0oKSA6IGNvbW1hbmRIYW5kbGVyLm9yaWdpbmFsO1xuICAgICAgICBjb25zdCBwYyA9IHBhcmVudENvbW1hbmRzLmZpbHRlcigoYykgPT4geyByZXR1cm4gIURFRkFVTFRfTUFSS0VSLnRlc3QoYyk7IH0pO1xuICAgICAgICBwYy5wdXNoKGMpO1xuICAgICAgICByZXR1cm4gYCQwICR7cGMuam9pbignICcpfWA7XG4gICAgfVxuICAgIHNlbGYucnVuRGVmYXVsdEJ1aWxkZXJPbiA9IGZ1bmN0aW9uICh5YXJncykge1xuICAgICAgICBjb21tb25fdHlwZXNfMS5hc3NlcnROb3RTdHJpY3RFcXVhbChkZWZhdWx0Q29tbWFuZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZVVzYWdlKHlhcmdzKSkge1xuICAgICAgICAgICAgLy8gYnVpbGQgdGhlIHJvb3QtbGV2ZWwgY29tbWFuZCBzdHJpbmcgZnJvbSB0aGUgZGVmYXVsdCBzdHJpbmcuXG4gICAgICAgICAgICBjb25zdCBjb21tYW5kU3RyaW5nID0gREVGQVVMVF9NQVJLRVIudGVzdChkZWZhdWx0Q29tbWFuZC5vcmlnaW5hbClcbiAgICAgICAgICAgICAgICA/IGRlZmF1bHRDb21tYW5kLm9yaWdpbmFsIDogZGVmYXVsdENvbW1hbmQub3JpZ2luYWwucmVwbGFjZSgvXlteW1xcXTw+XSovLCAnJDAgJyk7XG4gICAgICAgICAgICB5YXJncy5nZXRVc2FnZUluc3RhbmNlKCkudXNhZ2UoY29tbWFuZFN0cmluZywgZGVmYXVsdENvbW1hbmQuZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1aWxkZXIgPSBkZWZhdWx0Q29tbWFuZC5idWlsZGVyO1xuICAgICAgICBpZiAoaXNDb21tYW5kQnVpbGRlckNhbGxiYWNrKGJ1aWxkZXIpKSB7XG4gICAgICAgICAgICBidWlsZGVyKHlhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGJ1aWxkZXIpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHlhcmdzLm9wdGlvbihrZXksIGJ1aWxkZXJba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gdHJhbnNjcmliZSBhbGwgcG9zaXRpb25hbCBhcmd1bWVudHMgXCJjb21tYW5kIDxmb28+IDxiYXI+IFthcHBsZV1cIlxuICAgIC8vIG9udG8gYXJndi5cbiAgICBmdW5jdGlvbiBwb3B1bGF0ZVBvc2l0aW9uYWxzKGNvbW1hbmRIYW5kbGVyLCBhcmd2LCBjb250ZXh0KSB7XG4gICAgICAgIGFyZ3YuXyA9IGFyZ3YuXy5zbGljZShjb250ZXh0LmNvbW1hbmRzLmxlbmd0aCk7IC8vIG51a2UgdGhlIGN1cnJlbnQgY29tbWFuZHNcbiAgICAgICAgY29uc3QgZGVtYW5kZWQgPSBjb21tYW5kSGFuZGxlci5kZW1hbmRlZC5zbGljZSgwKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uYWwgPSBjb21tYW5kSGFuZGxlci5vcHRpb25hbC5zbGljZSgwKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb25hbE1hcCA9IHt9O1xuICAgICAgICB2YWxpZGF0aW9uLnBvc2l0aW9uYWxDb3VudChkZW1hbmRlZC5sZW5ndGgsIGFyZ3YuXy5sZW5ndGgpO1xuICAgICAgICB3aGlsZSAoZGVtYW5kZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBkZW1hbmQgPSBkZW1hbmRlZC5zaGlmdCgpO1xuICAgICAgICAgICAgcG9wdWxhdGVQb3NpdGlvbmFsKGRlbWFuZCwgYXJndiwgcG9zaXRpb25hbE1hcCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG9wdGlvbmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbWF5YmUgPSBvcHRpb25hbC5zaGlmdCgpO1xuICAgICAgICAgICAgcG9wdWxhdGVQb3NpdGlvbmFsKG1heWJlLCBhcmd2LCBwb3NpdGlvbmFsTWFwKTtcbiAgICAgICAgfVxuICAgICAgICBhcmd2Ll8gPSBjb250ZXh0LmNvbW1hbmRzLmNvbmNhdChhcmd2Ll8pO1xuICAgICAgICBwb3N0UHJvY2Vzc1Bvc2l0aW9uYWxzKGFyZ3YsIHBvc2l0aW9uYWxNYXAsIHNlbGYuY21kVG9QYXJzZU9wdGlvbnMoY29tbWFuZEhhbmRsZXIub3JpZ2luYWwpKTtcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uYWxNYXA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcHVsYXRlUG9zaXRpb25hbChwb3NpdGlvbmFsLCBhcmd2LCBwb3NpdGlvbmFsTWFwKSB7XG4gICAgICAgIGNvbnN0IGNtZCA9IHBvc2l0aW9uYWwuY21kWzBdO1xuICAgICAgICBpZiAocG9zaXRpb25hbC52YXJpYWRpYykge1xuICAgICAgICAgICAgcG9zaXRpb25hbE1hcFtjbWRdID0gYXJndi5fLnNwbGljZSgwKS5tYXAoU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhcmd2Ll8ubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHBvc2l0aW9uYWxNYXBbY21kXSA9IFtTdHJpbmcoYXJndi5fLnNoaWZ0KCkpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyB3ZSBydW4geWFyZ3MtcGFyc2VyIGFnYWluc3QgdGhlIHBvc2l0aW9uYWwgYXJndW1lbnRzXG4gICAgLy8gYXBwbHlpbmcgdGhlIHNhbWUgcGFyc2luZyBsb2dpYyB1c2VkIGZvciBmbGFncy5cbiAgICBmdW5jdGlvbiBwb3N0UHJvY2Vzc1Bvc2l0aW9uYWxzKGFyZ3YsIHBvc2l0aW9uYWxNYXAsIHBhcnNlT3B0aW9ucykge1xuICAgICAgICAvLyBjb21iaW5lIHRoZSBwYXJzaW5nIGhpbnRzIHdlJ3ZlIGluZmVycmVkIGZyb20gdGhlIGNvbW1hbmRcbiAgICAgICAgLy8gc3RyaW5nIHdpdGggZXhwbGljaXRseSBjb25maWd1cmVkIHBhcnNpbmcgaGludHMuXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB5YXJncy5nZXRPcHRpb25zKCkpO1xuICAgICAgICBvcHRpb25zLmRlZmF1bHQgPSBPYmplY3QuYXNzaWduKHBhcnNlT3B0aW9ucy5kZWZhdWx0LCBvcHRpb25zLmRlZmF1bHQpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwYXJzZU9wdGlvbnMuYWxpYXMpKSB7XG4gICAgICAgICAgICBvcHRpb25zLmFsaWFzW2tleV0gPSAob3B0aW9ucy5hbGlhc1trZXldIHx8IFtdKS5jb25jYXQocGFyc2VPcHRpb25zLmFsaWFzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuYXJyYXkgPSBvcHRpb25zLmFycmF5LmNvbmNhdChwYXJzZU9wdGlvbnMuYXJyYXkpO1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5jb25maWc7IC8vICBkb24ndCBsb2FkIGNvbmZpZyB3aGVuIHByb2Nlc3NpbmcgcG9zaXRpb25hbHMuXG4gICAgICAgIGNvbnN0IHVucGFyc2VkID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKHBvc2l0aW9uYWxNYXApLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgcG9zaXRpb25hbE1hcFtrZXldLm1hcCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5jb25maWd1cmF0aW9uWyd1bmtub3duLW9wdGlvbnMtYXMtYXJncyddKVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmtleVtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB1bnBhcnNlZC5wdXNoKGAtLSR7a2V5fWApO1xuICAgICAgICAgICAgICAgIHVucGFyc2VkLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBzaG9ydC1jaXJjdWl0IHBhcnNlLlxuICAgICAgICBpZiAoIXVucGFyc2VkLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy5jb25maWd1cmF0aW9uLCB7XG4gICAgICAgICAgICAncG9wdWxhdGUtLSc6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IFBhcnNlci5kZXRhaWxlZCh1bnBhcnNlZCwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgY29uZmlndXJhdGlvbjogY29uZmlnXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKHBhcnNlZC5lcnJvcikge1xuICAgICAgICAgICAgeWFyZ3MuZ2V0VXNhZ2VJbnN0YW5jZSgpLmZhaWwocGFyc2VkLmVycm9yLm1lc3NhZ2UsIHBhcnNlZC5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBvbmx5IGNvcHkgb3ZlciBwb3NpdGlvbmFsIGtleXMgKGRvbid0IG92ZXJ3cml0ZVxuICAgICAgICAgICAgLy8gZmxhZyBhcmd1bWVudHMgdGhhdCB3ZXJlIGFscmVhZHkgcGFyc2VkKS5cbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uYWxLZXlzID0gT2JqZWN0LmtleXMocG9zaXRpb25hbE1hcCk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwb3NpdGlvbmFsTWFwKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbmFsS2V5cy5wdXNoKC4uLnBhcnNlZC5hbGlhc2VzW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJzZWQuYXJndikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uYWxLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYW55IG5ldyBhbGlhc2VzIG5lZWQgdG8gYmUgcGxhY2VkIGluIHBvc2l0aW9uYWxNYXAsIHdoaWNoXG4gICAgICAgICAgICAgICAgICAgIC8vIGlzIHVzZWQgZm9yIHZhbGlkYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGlmICghcG9zaXRpb25hbE1hcFtrZXldKVxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25hbE1hcFtrZXldID0gcGFyc2VkLmFyZ3Zba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgYXJndltrZXldID0gcGFyc2VkLmFyZ3Zba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxmLmNtZFRvUGFyc2VPcHRpb25zID0gZnVuY3Rpb24gKGNtZFN0cmluZykge1xuICAgICAgICBjb25zdCBwYXJzZU9wdGlvbnMgPSB7XG4gICAgICAgICAgICBhcnJheTogW10sXG4gICAgICAgICAgICBkZWZhdWx0OiB7fSxcbiAgICAgICAgICAgIGFsaWFzOiB7fSxcbiAgICAgICAgICAgIGRlbWFuZDoge31cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gcGFyc2VfY29tbWFuZF8xLnBhcnNlQ29tbWFuZChjbWRTdHJpbmcpO1xuICAgICAgICBwYXJzZWQuZGVtYW5kZWQuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2NtZCwgLi4uYWxpYXNlc10gPSBkLmNtZDtcbiAgICAgICAgICAgIGlmIChkLnZhcmlhZGljKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb25zLmFycmF5LnB1c2goY21kKTtcbiAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbnMuZGVmYXVsdFtjbWRdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJzZU9wdGlvbnMuYWxpYXNbY21kXSA9IGFsaWFzZXM7XG4gICAgICAgICAgICBwYXJzZU9wdGlvbnMuZGVtYW5kW2NtZF0gPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcGFyc2VkLm9wdGlvbmFsLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFtjbWQsIC4uLmFsaWFzZXNdID0gby5jbWQ7XG4gICAgICAgICAgICBpZiAoby52YXJpYWRpYykge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9ucy5hcnJheS5wdXNoKGNtZCk7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb25zLmRlZmF1bHRbY21kXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyc2VPcHRpb25zLmFsaWFzW2NtZF0gPSBhbGlhc2VzO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlT3B0aW9ucztcbiAgICB9O1xuICAgIHNlbGYucmVzZXQgPSAoKSA9PiB7XG4gICAgICAgIGhhbmRsZXJzID0ge307XG4gICAgICAgIGFsaWFzTWFwID0ge307XG4gICAgICAgIGRlZmF1bHRDb21tYW5kID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIC8vIHVzZWQgYnkgeWFyZ3MucGFyc2UoKSB0byBmcmVlemVcbiAgICAvLyB0aGUgc3RhdGUgb2YgY29tbWFuZHMgc3VjaCB0aGF0XG4gICAgLy8gd2UgY2FuIGFwcGx5IC5wYXJzZSgpIG11bHRpcGxlIHRpbWVzXG4gICAgLy8gd2l0aCB0aGUgc2FtZSB5YXJncyBpbnN0YW5jZS5cbiAgICBjb25zdCBmcm96ZW5zID0gW107XG4gICAgc2VsZi5mcmVlemUgPSAoKSA9PiB7XG4gICAgICAgIGZyb3plbnMucHVzaCh7XG4gICAgICAgICAgICBoYW5kbGVycyxcbiAgICAgICAgICAgIGFsaWFzTWFwLFxuICAgICAgICAgICAgZGVmYXVsdENvbW1hbmRcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBzZWxmLnVuZnJlZXplID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBmcm96ZW4gPSBmcm96ZW5zLnBvcCgpO1xuICAgICAgICBjb21tb25fdHlwZXNfMS5hc3NlcnROb3RTdHJpY3RFcXVhbChmcm96ZW4sIHVuZGVmaW5lZCk7XG4gICAgICAgICh7XG4gICAgICAgICAgICBoYW5kbGVycyxcbiAgICAgICAgICAgIGFsaWFzTWFwLFxuICAgICAgICAgICAgZGVmYXVsdENvbW1hbmRcbiAgICAgICAgfSA9IGZyb3plbik7XG4gICAgfTtcbiAgICByZXR1cm4gc2VsZjtcbn1cbmV4cG9ydHMuY29tbWFuZCA9IGNvbW1hbmQ7XG5mdW5jdGlvbiBpc0NvbW1hbmRIYW5kbGVyRGVmaW5pdGlvbihjbWQpIHtcbiAgICByZXR1cm4gdHlwZW9mIGNtZCA9PT0gJ29iamVjdCc7XG59XG5leHBvcnRzLmlzQ29tbWFuZEhhbmRsZXJEZWZpbml0aW9uID0gaXNDb21tYW5kSGFuZGxlckRlZmluaXRpb247XG5mdW5jdGlvbiBpc0NvbW1hbmRCdWlsZGVyRGVmaW5pdGlvbihidWlsZGVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBidWlsZGVyID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAhIWJ1aWxkZXIuYnVpbGRlciAmJlxuICAgICAgICB0eXBlb2YgYnVpbGRlci5oYW5kbGVyID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0NvbW1hbmRCdWlsZGVyRGVmaW5pdGlvbiA9IGlzQ29tbWFuZEJ1aWxkZXJEZWZpbml0aW9uO1xuZnVuY3Rpb24gaXNDb21tYW5kQnVpbGRlckNhbGxiYWNrKGJ1aWxkZXIpIHtcbiAgICByZXR1cm4gdHlwZW9mIGJ1aWxkZXIgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzQ29tbWFuZEJ1aWxkZXJDYWxsYmFjayA9IGlzQ29tbWFuZEJ1aWxkZXJDYWxsYmFjaztcbmZ1bmN0aW9uIGlzQ29tbWFuZEJ1aWxkZXJPcHRpb25EZWZpbml0aW9ucyhidWlsZGVyKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBidWlsZGVyID09PSAnb2JqZWN0Jztcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///20\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyMiddleware = exports.commandMiddlewareFactory = exports.globalMiddlewareFactory = void 0;\nconst argsert_1 = __webpack_require__(10);\nconst is_promise_1 = __webpack_require__(5);\nfunction globalMiddlewareFactory(globalMiddleware, context) {\n    return function (callback, applyBeforeValidation = false) {\n        argsert_1.argsert('<array|function> [boolean]', [callback, applyBeforeValidation], arguments.length);\n        if (Array.isArray(callback)) {\n            for (let i = 0; i < callback.length; i++) {\n                if (typeof callback[i] !== 'function') {\n                    throw Error('middleware must be a function');\n                }\n                callback[i].applyBeforeValidation = applyBeforeValidation;\n            }\n            Array.prototype.push.apply(globalMiddleware, callback);\n        }\n        else if (typeof callback === 'function') {\n            callback.applyBeforeValidation = applyBeforeValidation;\n            globalMiddleware.push(callback);\n        }\n        return context;\n    };\n}\nexports.globalMiddlewareFactory = globalMiddlewareFactory;\nfunction commandMiddlewareFactory(commandMiddleware) {\n    if (!commandMiddleware)\n        return [];\n    return commandMiddleware.map(middleware => {\n        middleware.applyBeforeValidation = false;\n        return middleware;\n    });\n}\nexports.commandMiddlewareFactory = commandMiddlewareFactory;\nfunction applyMiddleware(argv, yargs, middlewares, beforeValidation) {\n    const beforeValidationError = new Error('middleware cannot return a promise when applyBeforeValidation is true');\n    return middlewares\n        .reduce((acc, middleware) => {\n        if (middleware.applyBeforeValidation !== beforeValidation) {\n            return acc;\n        }\n        if (is_promise_1.isPromise(acc)) {\n            return acc\n                .then(initialObj => Promise.all([initialObj, middleware(initialObj, yargs)]))\n                .then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));\n        }\n        else {\n            const result = middleware(acc, yargs);\n            if (beforeValidation && is_promise_1.isPromise(result))\n                throw beforeValidationError;\n            return is_promise_1.isPromise(result)\n                ? result.then(middlewareObj => Object.assign(acc, middlewareObj))\n                : Object.assign(acc, result);\n        }\n    }, argv);\n}\nexports.applyMiddleware = applyMiddleware;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliL21pZGRsZXdhcmUuanM/MWQ1ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsRUFBVztBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyxDQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hcHBseU1pZGRsZXdhcmUgPSBleHBvcnRzLmNvbW1hbmRNaWRkbGV3YXJlRmFjdG9yeSA9IGV4cG9ydHMuZ2xvYmFsTWlkZGxld2FyZUZhY3RvcnkgPSB2b2lkIDA7XG5jb25zdCBhcmdzZXJ0XzEgPSByZXF1aXJlKFwiLi9hcmdzZXJ0XCIpO1xuY29uc3QgaXNfcHJvbWlzZV8xID0gcmVxdWlyZShcIi4vaXMtcHJvbWlzZVwiKTtcbmZ1bmN0aW9uIGdsb2JhbE1pZGRsZXdhcmVGYWN0b3J5KGdsb2JhbE1pZGRsZXdhcmUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrLCBhcHBseUJlZm9yZVZhbGlkYXRpb24gPSBmYWxzZSkge1xuICAgICAgICBhcmdzZXJ0XzEuYXJnc2VydCgnPGFycmF5fGZ1bmN0aW9uPiBbYm9vbGVhbl0nLCBbY2FsbGJhY2ssIGFwcGx5QmVmb3JlVmFsaWRhdGlvbl0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrW2ldICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdtaWRkbGV3YXJlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFja1tpXS5hcHBseUJlZm9yZVZhbGlkYXRpb24gPSBhcHBseUJlZm9yZVZhbGlkYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShnbG9iYWxNaWRkbGV3YXJlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseUJlZm9yZVZhbGlkYXRpb24gPSBhcHBseUJlZm9yZVZhbGlkYXRpb247XG4gICAgICAgICAgICBnbG9iYWxNaWRkbGV3YXJlLnB1c2goY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH07XG59XG5leHBvcnRzLmdsb2JhbE1pZGRsZXdhcmVGYWN0b3J5ID0gZ2xvYmFsTWlkZGxld2FyZUZhY3Rvcnk7XG5mdW5jdGlvbiBjb21tYW5kTWlkZGxld2FyZUZhY3RvcnkoY29tbWFuZE1pZGRsZXdhcmUpIHtcbiAgICBpZiAoIWNvbW1hbmRNaWRkbGV3YXJlKVxuICAgICAgICByZXR1cm4gW107XG4gICAgcmV0dXJuIGNvbW1hbmRNaWRkbGV3YXJlLm1hcChtaWRkbGV3YXJlID0+IHtcbiAgICAgICAgbWlkZGxld2FyZS5hcHBseUJlZm9yZVZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG1pZGRsZXdhcmU7XG4gICAgfSk7XG59XG5leHBvcnRzLmNvbW1hbmRNaWRkbGV3YXJlRmFjdG9yeSA9IGNvbW1hbmRNaWRkbGV3YXJlRmFjdG9yeTtcbmZ1bmN0aW9uIGFwcGx5TWlkZGxld2FyZShhcmd2LCB5YXJncywgbWlkZGxld2FyZXMsIGJlZm9yZVZhbGlkYXRpb24pIHtcbiAgICBjb25zdCBiZWZvcmVWYWxpZGF0aW9uRXJyb3IgPSBuZXcgRXJyb3IoJ21pZGRsZXdhcmUgY2Fubm90IHJldHVybiBhIHByb21pc2Ugd2hlbiBhcHBseUJlZm9yZVZhbGlkYXRpb24gaXMgdHJ1ZScpO1xuICAgIHJldHVybiBtaWRkbGV3YXJlc1xuICAgICAgICAucmVkdWNlKChhY2MsIG1pZGRsZXdhcmUpID0+IHtcbiAgICAgICAgaWYgKG1pZGRsZXdhcmUuYXBwbHlCZWZvcmVWYWxpZGF0aW9uICE9PSBiZWZvcmVWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19wcm9taXNlXzEuaXNQcm9taXNlKGFjYykpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2NcbiAgICAgICAgICAgICAgICAudGhlbihpbml0aWFsT2JqID0+IFByb21pc2UuYWxsKFtpbml0aWFsT2JqLCBtaWRkbGV3YXJlKGluaXRpYWxPYmosIHlhcmdzKV0pKVxuICAgICAgICAgICAgICAgIC50aGVuKChbaW5pdGlhbE9iaiwgbWlkZGxld2FyZU9ial0pID0+IE9iamVjdC5hc3NpZ24oaW5pdGlhbE9iaiwgbWlkZGxld2FyZU9iaikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbWlkZGxld2FyZShhY2MsIHlhcmdzKTtcbiAgICAgICAgICAgIGlmIChiZWZvcmVWYWxpZGF0aW9uICYmIGlzX3Byb21pc2VfMS5pc1Byb21pc2UocmVzdWx0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBiZWZvcmVWYWxpZGF0aW9uRXJyb3I7XG4gICAgICAgICAgICByZXR1cm4gaXNfcHJvbWlzZV8xLmlzUHJvbWlzZShyZXN1bHQpXG4gICAgICAgICAgICAgICAgPyByZXN1bHQudGhlbihtaWRkbGV3YXJlT2JqID0+IE9iamVjdC5hc3NpZ24oYWNjLCBtaWRkbGV3YXJlT2JqKSlcbiAgICAgICAgICAgICAgICA6IE9iamVjdC5hc3NpZ24oYWNjLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSwgYXJndik7XG59XG5leHBvcnRzLmFwcGx5TWlkZGxld2FyZSA9IGFwcGx5TWlkZGxld2FyZTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///21\n")},function(module,exports,__webpack_require__){"use strict";eval("\nmodule.exports = function (str, sep) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\tsep = typeof sep === 'undefined' ? '_' : sep;\n\n\treturn str\n\t\t.replace(/([a-z\\d])([A-Z])/g, '$1' + sep + '$2')\n\t\t.replace(/([A-Z]+)([A-Z][a-z\\d]+)/g, '$1' + sep + '$2')\n\t\t.toLowerCase();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVjYW1lbGl6ZS9pbmRleC5qcz85MDBhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0ciwgc2VwKSB7XG5cdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XG5cdH1cblxuXHRzZXAgPSB0eXBlb2Ygc2VwID09PSAndW5kZWZpbmVkJyA/ICdfJyA6IHNlcDtcblxuXHRyZXR1cm4gc3RyXG5cdFx0LnJlcGxhY2UoLyhbYS16XFxkXSkoW0EtWl0pL2csICckMScgKyBzZXAgKyAnJDInKVxuXHRcdC5yZXBsYWNlKC8oW0EtWl0rKShbQS1aXVthLXpcXGRdKykvZywgJyQxJyArIHNlcCArICckMicpXG5cdFx0LnRvTG93ZXJDYXNlKCk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22\n")},function(module,exports){eval("module.exports = function (blocking) {\n  [process.stdout, process.stderr].forEach(function (stream) {\n    if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === 'function') {\n      stream._handle.setBlocking(blocking)\n    }\n  })\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0LWJsb2NraW5nL2luZGV4LmpzPzJmMzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIyMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJsb2NraW5nKSB7XG4gIFtwcm9jZXNzLnN0ZG91dCwgcHJvY2Vzcy5zdGRlcnJdLmZvckVhY2goZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgIGlmIChzdHJlYW0uX2hhbmRsZSAmJiBzdHJlYW0uaXNUVFkgJiYgdHlwZW9mIHN0cmVhbS5faGFuZGxlLnNldEJsb2NraW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdHJlYW0uX2hhbmRsZS5zZXRCbG9ja2luZyhibG9ja2luZylcbiAgICB9XG4gIH0pXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.getProcessArgvBin = exports.getProcessArgvWithoutBin = void 0;\nfunction getProcessArgvBinIndex() {\n    // The binary name is the first command line argument for:\n    // - bundled Electron apps: bin argv1 argv2 ... argvn\n    if (isBundledElectronApp())\n        return 0;\n    // or the second one (default) for:\n    // - standard node apps: node bin.js argv1 argv2 ... argvn\n    // - unbundled Electron apps: electron bin.js argv1 arg2 ... argvn\n    return 1;\n}\nfunction isBundledElectronApp() {\n    // process.defaultApp is either set by electron in an electron unbundled app, or undefined\n    // see https://github.com/electron/electron/blob/master/docs/api/process.md#processdefaultapp-readonly\n    return isElectronApp() && !process.defaultApp;\n}\nfunction isElectronApp() {\n    // process.versions.electron is either set by electron, or undefined\n    // see https://github.com/electron/electron/blob/master/docs/api/process.md#processversionselectron-readonly\n    return !!process.versions.electron;\n}\nfunction getProcessArgvWithoutBin() {\n    return process.argv.slice(getProcessArgvBinIndex() + 1);\n}\nexports.getProcessArgvWithoutBin = getProcessArgvWithoutBin;\nfunction getProcessArgvBin() {\n    return process.argv[getProcessArgvBinIndex()];\n}\nexports.getProcessArgvBin = getProcessArgvBin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliL3Byb2Nlc3MtYXJndi5qcz9hZGZlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRQcm9jZXNzQXJndkJpbiA9IGV4cG9ydHMuZ2V0UHJvY2Vzc0FyZ3ZXaXRob3V0QmluID0gdm9pZCAwO1xuZnVuY3Rpb24gZ2V0UHJvY2Vzc0FyZ3ZCaW5JbmRleCgpIHtcbiAgICAvLyBUaGUgYmluYXJ5IG5hbWUgaXMgdGhlIGZpcnN0IGNvbW1hbmQgbGluZSBhcmd1bWVudCBmb3I6XG4gICAgLy8gLSBidW5kbGVkIEVsZWN0cm9uIGFwcHM6IGJpbiBhcmd2MSBhcmd2MiAuLi4gYXJndm5cbiAgICBpZiAoaXNCdW5kbGVkRWxlY3Ryb25BcHAoKSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgLy8gb3IgdGhlIHNlY29uZCBvbmUgKGRlZmF1bHQpIGZvcjpcbiAgICAvLyAtIHN0YW5kYXJkIG5vZGUgYXBwczogbm9kZSBiaW4uanMgYXJndjEgYXJndjIgLi4uIGFyZ3ZuXG4gICAgLy8gLSB1bmJ1bmRsZWQgRWxlY3Ryb24gYXBwczogZWxlY3Ryb24gYmluLmpzIGFyZ3YxIGFyZzIgLi4uIGFyZ3ZuXG4gICAgcmV0dXJuIDE7XG59XG5mdW5jdGlvbiBpc0J1bmRsZWRFbGVjdHJvbkFwcCgpIHtcbiAgICAvLyBwcm9jZXNzLmRlZmF1bHRBcHAgaXMgZWl0aGVyIHNldCBieSBlbGVjdHJvbiBpbiBhbiBlbGVjdHJvbiB1bmJ1bmRsZWQgYXBwLCBvciB1bmRlZmluZWRcbiAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uL2VsZWN0cm9uL2Jsb2IvbWFzdGVyL2RvY3MvYXBpL3Byb2Nlc3MubWQjcHJvY2Vzc2RlZmF1bHRhcHAtcmVhZG9ubHlcbiAgICByZXR1cm4gaXNFbGVjdHJvbkFwcCgpICYmICFwcm9jZXNzLmRlZmF1bHRBcHA7XG59XG5mdW5jdGlvbiBpc0VsZWN0cm9uQXBwKCkge1xuICAgIC8vIHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24gaXMgZWl0aGVyIHNldCBieSBlbGVjdHJvbiwgb3IgdW5kZWZpbmVkXG4gICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi9lbGVjdHJvbi9ibG9iL21hc3Rlci9kb2NzL2FwaS9wcm9jZXNzLm1kI3Byb2Nlc3N2ZXJzaW9uc2VsZWN0cm9uLXJlYWRvbmx5XG4gICAgcmV0dXJuICEhcHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbjtcbn1cbmZ1bmN0aW9uIGdldFByb2Nlc3NBcmd2V2l0aG91dEJpbigpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5hcmd2LnNsaWNlKGdldFByb2Nlc3NBcmd2QmluSW5kZXgoKSArIDEpO1xufVxuZXhwb3J0cy5nZXRQcm9jZXNzQXJndldpdGhvdXRCaW4gPSBnZXRQcm9jZXNzQXJndldpdGhvdXRCaW47XG5mdW5jdGlvbiBnZXRQcm9jZXNzQXJndkJpbigpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5hcmd2W2dldFByb2Nlc3NBcmd2QmluSW5kZXgoKV07XG59XG5leHBvcnRzLmdldFByb2Nlc3NBcmd2QmluID0gZ2V0UHJvY2Vzc0FyZ3ZCaW47XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///24\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar ScreenWriter_1 = __webpack_require__(26);\nvar InputEvents_1 = __webpack_require__(44);\nvar Snake_1 = __webpack_require__(45);\nvar parseArgs_1 = __webpack_require__(48);\nvar updateInterval = parseArgs_1.args.s, snakeHeadColor = parseArgs_1.args.g, snakeBodyColor = parseArgs_1.args.b, emptyColor = parseArgs_1.args.e, fruitColor = parseArgs_1.args.f, fillChar = parseArgs_1.args.u, rows = parseArgs_1.args.r, columns = parseArgs_1.args.c;\nvar screenWriter = new ScreenWriter_1.ScreenWriter();\nvar inputEvents = new InputEvents_1.InputEvents();\nvar snake = new Snake_1.Snake(screenWriter, inputEvents, {\n    updateInterval: updateInterval,\n    snakeHeadColor: snakeHeadColor,\n    snakeBodyColor: snakeBodyColor,\n    emptyColor: emptyColor,\n    fruitColor: fruitColor,\n    fillChar: fillChar,\n    columns: columns,\n    rows: rows,\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5kZXgudHM/ZmZiNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDZDQUE4QztBQUM5Qyw0Q0FBNEM7QUFDNUMsc0NBQXNDO0FBRXRDLDBDQUErQztBQUU3QyxJQUFHLGNBQWMsR0FRZixnQkFBSSxFQVJXLEVBQ2QsY0FBYyxHQU9mLGdCQUFJLEVBUFcsRUFDZCxjQUFjLEdBTWYsZ0JBQUksRUFOVyxFQUNkLFVBQVUsR0FLWCxnQkFBSSxFQUxPLEVBQ1YsVUFBVSxHQUlYLGdCQUFJLEVBSk8sRUFDVixRQUFRLEdBR1QsZ0JBQUksRUFISyxFQUNSLElBQUksR0FFTCxnQkFBSSxFQUZDLEVBQ0osT0FBTyxHQUNSLGdCQUFJLEVBREksQ0FDSDtBQUVULElBQU0sWUFBWSxHQUFHLElBQUksMkJBQVksRUFBRSxDQUFDO0FBQ3hDLElBQU0sV0FBVyxHQUFHLElBQUkseUJBQVcsRUFBRSxDQUFDO0FBQ3RDLElBQU0sS0FBSyxHQUFHLElBQUksYUFBSyxDQUFDLFlBQVksRUFBRSxXQUFXLEVBQUU7SUFDakQsY0FBYztJQUNkLGNBQWMsRUFBRSxjQUF1QjtJQUN2QyxjQUFjLEVBQUUsY0FBdUI7SUFDdkMsVUFBVSxFQUFFLFVBQW1CO0lBQy9CLFVBQVUsRUFBRSxVQUFtQjtJQUMvQixRQUFRO0lBQ1IsT0FBTztJQUNQLElBQUk7Q0FDTCxDQUFDLENBQUMiLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTY3JlZW5Xcml0ZXIgfSBmcm9tIFwiLi9TY3JlZW5Xcml0ZXJcIjtcbmltcG9ydCB7IElucHV0RXZlbnRzIH0gZnJvbSBcIi4vSW5wdXRFdmVudHNcIjtcbmltcG9ydCB7IFNuYWtlIH0gZnJvbSBcIi4vR2FtZXMvU25ha2VcIjtcbmltcG9ydCB7IENvbG9yIH0gZnJvbSBcIi4vY29sb3JzXCI7XG5pbXBvcnQgeyBhcmdzIH0gZnJvbSBcIi4vR2FtZXMvU25ha2UvcGFyc2VBcmdzXCI7XG5jb25zdCB7XG4gIHM6IHVwZGF0ZUludGVydmFsLFxuICBnOiBzbmFrZUhlYWRDb2xvcixcbiAgYjogc25ha2VCb2R5Q29sb3IsXG4gIGU6IGVtcHR5Q29sb3IsXG4gIGY6IGZydWl0Q29sb3IsXG4gIHU6IGZpbGxDaGFyLFxuICByOiByb3dzLFxuICBjOiBjb2x1bW5zLFxufSA9IGFyZ3M7XG5cbmNvbnN0IHNjcmVlbldyaXRlciA9IG5ldyBTY3JlZW5Xcml0ZXIoKTtcbmNvbnN0IGlucHV0RXZlbnRzID0gbmV3IElucHV0RXZlbnRzKCk7XG5jb25zdCBzbmFrZSA9IG5ldyBTbmFrZShzY3JlZW5Xcml0ZXIsIGlucHV0RXZlbnRzLCB7XG4gIHVwZGF0ZUludGVydmFsLFxuICBzbmFrZUhlYWRDb2xvcjogc25ha2VIZWFkQ29sb3IgYXMgQ29sb3IsXG4gIHNuYWtlQm9keUNvbG9yOiBzbmFrZUJvZHlDb2xvciBhcyBDb2xvcixcbiAgZW1wdHlDb2xvcjogZW1wdHlDb2xvciBhcyBDb2xvcixcbiAgZnJ1aXRDb2xvcjogZnJ1aXRDb2xvciBhcyBDb2xvcixcbiAgZmlsbENoYXIsXG4gIGNvbHVtbnMsXG4gIHJvd3MsXG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///25\n')},function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.ScreenWriter = void 0;\nvar events_1 = __webpack_require__(8);\nvar chalk_1 = __importDefault(__webpack_require__(15));\nvar cli_cursor_1 = __importDefault(__webpack_require__(37));\nvar strip_ansi_1 = __importDefault(__webpack_require__(4));\nvar colors_1 = __webpack_require__(9);\nvar ScreenWriter = /** @class */ (function (_super) {\n    __extends(ScreenWriter, _super);\n    function ScreenWriter(opts) {\n        if (opts === void 0) { opts = {}; }\n        var _this = _super.call(this) || this;\n        /** console columns */\n        _this._columns = 0;\n        /** console rows */\n        _this._rows = 0;\n        /** should the border be added */\n        _this._border = true;\n        /** used to determine which lines should be redrawn */\n        _this.previousLines = [];\n        _this.updateScreenSize(true);\n        // listen for screen resize\n        process.stdout.on("resize", function () { return _this.updateScreenSize(); });\n        if (opts.withBorder !== undefined)\n            _this._border = opts.withBorder;\n        // get border color\n        var borderColor = opts.borderColor !== null ? opts.borderColor || "white" : null;\n        var borderBgColor = opts.borderBgColor !== null ? opts.borderBgColor || "black" : null;\n        if (!borderBgColor && !borderColor)\n            _this._border = false;\n        else if (borderBgColor && borderColor)\n            _this.borderColor =\n                chalk_1.default[colors_1.getForegroundColor(borderColor)][colors_1.getBackgroundColor(borderBgColor)];\n        else if (borderColor)\n            _this.borderColor = chalk_1.default[colors_1.getForegroundColor(borderColor)];\n        else if (borderBgColor)\n            _this.borderColor = chalk_1.default[colors_1.getBackgroundColor(borderBgColor)];\n        return _this;\n    }\n    ScreenWriter.prototype.on = function (event, listener) {\n        return _super.prototype.on.call(this, event, listener);\n    };\n    ScreenWriter.prototype.updateScreenSize = function (noEmit) {\n        if (noEmit === void 0) { noEmit = false; }\n        var _a = process.stdout.getWindowSize(), columns = _a[0], rows = _a[1];\n        this._columns = columns;\n        this._rows = rows;\n        this.previousLines = [];\n        if (!noEmit)\n            this.emit("resize", { columns: columns, rows: rows });\n    };\n    Object.defineProperty(ScreenWriter.prototype, "columns", {\n        /**\n         * Returns number of columns available to write to\n         * Takes border into account\n         */\n        get: function () {\n            return this._border ? this._columns - 2 : this._columns;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ScreenWriter.prototype, "rows", {\n        /**\n         * Returns number of rows available to write to\n         * Takes border into account\n         */\n        get: function () {\n            return this._border ? this._rows - 2 : this._rows;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Centers lines on screen if needed\n     * @param strings\n     */\n    ScreenWriter.prototype.centerStringsOnScreen = function (strings) {\n        var _this = this;\n        var rows = this._rows;\n        var columns = this._columns;\n        if (strings.length === rows && strip_ansi_1.default(strings[0]).length === columns)\n            return strings;\n        var emptyLine = " ".repeat(columns);\n        var emptyLinesNeeded = (rows - strings.length) / 2;\n        return __spreadArrays(Array(Math.floor(emptyLinesNeeded)).fill(emptyLine), strings.map(function (str) { return _this.centerString(str, columns); }), Array(Math.ceil(emptyLinesNeeded)).fill(emptyLine));\n    };\n    ScreenWriter.prototype.clearScreen = function () {\n        this.previousLines = [];\n        console.clear();\n    };\n    /**\n     * helper function to center text\n     * @param str string to be centered\n     * @param lineWidth desired line width\n     * @param fillChar Character to be used as a filler, default: \' \'\n     */\n    ScreenWriter.prototype.centerString = function (str, lineWidth, fillChar) {\n        if (lineWidth === void 0) { lineWidth = this._columns; }\n        if (fillChar === void 0) { fillChar = " "; }\n        if (lineWidth <= 0)\n            throw new RangeError("Line width should be bigger than 0. Received: " + lineWidth);\n        var strippedStr = strip_ansi_1.default(str);\n        if (strippedStr.length === lineWidth)\n            return str;\n        // WRONG, how to properly strip a string with ansi chars?\n        if (strippedStr.length > lineWidth)\n            return strippedStr.slice(0, lineWidth);\n        var padding = (lineWidth - strippedStr.length) / 2;\n        return (fillChar.repeat(Math.floor(padding)) +\n            str +\n            fillChar.repeat(Math.ceil(padding)));\n    };\n    /**\n     * Write to stdout\n     * The assumption is all strings in the array are the same width\n     * @param strings Array of strings to write\n     */\n    ScreenWriter.prototype.print = function (strings) {\n        if (this._border)\n            strings = this.addBorder(strings);\n        strings = this.centerStringsOnScreen(strings);\n        for (var i = 0; i < strings.length; i++) {\n            var row = strings[i];\n            // we\'ll be redrawing only changed lines\n            if (row !== this.previousLines[i]) {\n                process.stdout.cursorTo(0, i);\n                process.stdout.write(row);\n                if (i < strings.length - 1)\n                    process.stdout.write("\\n");\n                this.previousLines[i] = row;\n            }\n        }\n        cli_cursor_1.default.hide();\n    };\n    ScreenWriter.prototype.addBorder = function (arr) {\n        if (!this._border || !this.borderColor)\n            return arr;\n        var sideBorder = this.borderColor("│");\n        var lineWidth = strip_ansi_1.default(arr[0]).length;\n        return __spreadArrays([\n            // top border\n            this.borderColor("┌" + "─".repeat(lineWidth) + "┐")\n        ], arr.map(function (row) { return sideBorder + row + sideBorder; }), [\n            // bottom border\n            this.borderColor("└" + "─".repeat(lineWidth) + "┘"),\n        ]);\n    };\n    return ScreenWriter;\n}(events_1.EventEmitter));\nexports.ScreenWriter = ScreenWriter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvU2NyZWVuV3JpdGVyL2luZGV4LnRzPzQ4ZDkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxzQ0FBc0M7QUFDdEMsdURBQTBCO0FBQzFCLDREQUFtQztBQUNuQywyREFBbUM7QUFDbkMsc0NBQTBFO0FBeUIxRTtJQUFrQyxnQ0FBWTtJQWdCNUMsc0JBQVksSUFBOEI7UUFBOUIsZ0NBQThCO1FBQTFDLFlBQ0UsaUJBQU8sU0F1QlI7UUF0Q0Qsc0JBQXNCO1FBQ2QsY0FBUSxHQUFXLENBQUMsQ0FBQztRQUM3QixtQkFBbUI7UUFDWCxXQUFLLEdBQVcsQ0FBQyxDQUFDO1FBSzFCLGlDQUFpQztRQUN6QixhQUFPLEdBQUcsSUFBSSxDQUFDO1FBRXZCLHNEQUFzRDtRQUM5QyxtQkFBYSxHQUFhLEVBQUUsQ0FBQztRQUtuQyxLQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDNUIsMkJBQTJCO1FBQzNCLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxjQUFNLFlBQUksQ0FBQyxnQkFBZ0IsRUFBRSxFQUF2QixDQUF1QixDQUFDLENBQUM7UUFFM0QsSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLFNBQVM7WUFBRSxLQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7UUFFbEUsbUJBQW1CO1FBQ25CLElBQU0sV0FBVyxHQUNmLElBQUksQ0FBQyxXQUFXLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxJQUFJLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQ2pFLElBQU0sYUFBYSxHQUNqQixJQUFJLENBQUMsYUFBYSxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsSUFBSSxPQUFPLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUNyRSxJQUFJLENBQUMsYUFBYSxJQUFJLENBQUMsV0FBVztZQUFFLEtBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO2FBQ3BELElBQUksYUFBYSxJQUFJLFdBQVc7WUFDbkMsS0FBSSxDQUFDLFdBQVc7Z0JBQ2QsZUFBSyxDQUFDLDJCQUFrQixDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQ3BDLDJCQUFrQixDQUFDLGFBQWEsQ0FBQyxDQUNsQyxDQUFDO2FBQ0QsSUFBSSxXQUFXO1lBQ2xCLEtBQUksQ0FBQyxXQUFXLEdBQUcsZUFBSyxDQUFDLDJCQUFrQixDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7YUFDdkQsSUFBSSxhQUFhO1lBQ3BCLEtBQUksQ0FBQyxXQUFXLEdBQUcsZUFBSyxDQUFDLDJCQUFrQixDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7O0lBQ2hFLENBQUM7SUFFRCx5QkFBRSxHQUFGLFVBQUcsS0FBZSxFQUFFLFFBQTZCO1FBQy9DLE9BQU8saUJBQU0sRUFBRSxZQUFDLEtBQUssRUFBRSxRQUFRLENBQUMsQ0FBQztJQUNuQyxDQUFDO0lBRU8sdUNBQWdCLEdBQXhCLFVBQXlCLE1BQWM7UUFBZCx1Q0FBYztRQUMvQixTQUFrQixPQUFPLENBQUMsTUFBTSxDQUFDLGFBQWEsRUFBRSxFQUEvQyxPQUFPLFVBQUUsSUFBSSxRQUFrQyxDQUFDO1FBQ3ZELElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO1FBQ2xCLElBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDO1FBRXhCLElBQUksQ0FBQyxNQUFNO1lBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRSxPQUFPLFdBQUUsSUFBSSxRQUFFLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBTUQsc0JBQUksaUNBQU87UUFKWDs7O1dBR0c7YUFDSDtZQUNFLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDMUQsQ0FBQzs7O09BQUE7SUFNRCxzQkFBSSw4QkFBSTtRQUpSOzs7V0FHRzthQUNIO1lBQ0UsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUNwRCxDQUFDOzs7T0FBQTtJQUVEOzs7T0FHRztJQUNILDRDQUFxQixHQUFyQixVQUFzQixPQUFpQjtRQUF2QyxpQkFnQkM7UUFmQyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQ3hCLElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7UUFFOUIsSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLElBQUksSUFBSSxvQkFBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sS0FBSyxPQUFPO1lBQ3JFLE9BQU8sT0FBTyxDQUFDO1FBRWpCLElBQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFdEMsSUFBTSxnQkFBZ0IsR0FBRyxDQUFDLElBQUksR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXJELHNCQUNLLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQ25ELE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBQyxHQUFHLElBQUssWUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLEVBQS9CLENBQStCLENBQUMsRUFDckQsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFDckQ7SUFDSixDQUFDO0lBRUQsa0NBQVcsR0FBWDtRQUNFLElBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDO1FBQ3hCLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNsQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxtQ0FBWSxHQUFaLFVBQWEsR0FBVyxFQUFFLFNBQWlDLEVBQUUsUUFBYztRQUFqRCx3Q0FBb0IsSUFBSSxDQUFDLFFBQVE7UUFBRSx5Q0FBYztRQUN6RSxJQUFJLFNBQVMsSUFBSSxDQUFDO1lBQ2hCLE1BQU0sSUFBSSxVQUFVLENBQ2xCLG1EQUFpRCxTQUFXLENBQzdELENBQUM7UUFFSixJQUFNLFdBQVcsR0FBRyxvQkFBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRW5DLElBQUksV0FBVyxDQUFDLE1BQU0sS0FBSyxTQUFTO1lBQUUsT0FBTyxHQUFHLENBQUM7UUFDakQseURBQXlEO1FBQ3pELElBQUksV0FBVyxDQUFDLE1BQU0sR0FBRyxTQUFTO1lBQUUsT0FBTyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztRQUUzRSxJQUFNLE9BQU8sR0FBRyxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRXJELE9BQU8sQ0FDTCxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDcEMsR0FBRztZQUNILFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUNwQyxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7O09BSUc7SUFDSCw0QkFBSyxHQUFMLFVBQU0sT0FBaUI7UUFDckIsSUFBSSxJQUFJLENBQUMsT0FBTztZQUFFLE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ3BELE9BQU8sR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFOUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDdkMsSUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3ZCLHdDQUF3QztZQUN4QyxJQUFJLEdBQUcsS0FBSyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFO2dCQUNqQyxPQUFPLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQzlCLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUMxQixJQUFJLENBQUMsR0FBRyxPQUFPLENBQUMsTUFBTSxHQUFHLENBQUM7b0JBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3ZELElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO2FBQzdCO1NBQ0Y7UUFFRCxvQkFBUyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ25CLENBQUM7SUFFRCxnQ0FBUyxHQUFULFVBQVUsR0FBYTtRQUNyQixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXO1lBQUUsT0FBTyxHQUFHLENBQUM7UUFFbkQsSUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN6QyxJQUFNLFNBQVMsR0FBRyxvQkFBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztRQUMzQztZQUNFLGFBQWE7WUFDYixJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztXQUVoRCxHQUFHLENBQUMsR0FBRyxDQUFDLFVBQUMsR0FBRyxJQUFLLGlCQUFVLEdBQUcsR0FBRyxHQUFHLFVBQVUsRUFBN0IsQ0FBNkIsQ0FBQztZQUNsRCxnQkFBZ0I7WUFDaEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxHQUFHLENBQUM7V0FDbkQ7SUFDSixDQUFDO0lBQ0gsbUJBQUM7QUFBRCxDQUFDLENBbEtpQyxxQkFBWSxHQWtLN0M7QUFsS1ksb0NBQVkiLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tIFwiZXZlbnRzXCI7XG5pbXBvcnQgY2hhbGsgZnJvbSBcImNoYWxrXCI7XG5pbXBvcnQgY2xpQ3Vyc29yIGZyb20gXCJjbGktY3Vyc29yXCI7XG5pbXBvcnQgc3RyaXBBbnNpIGZyb20gXCJzdHJpcC1hbnNpXCI7XG5pbXBvcnQgeyBnZXRCYWNrZ3JvdW5kQ29sb3IsIGdldEZvcmVncm91bmRDb2xvciwgQ29sb3IgfSBmcm9tIFwiLi4vY29sb3JzXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NyZWVuV3JpdGVySW50ZXJmYWNlIHtcbiAgcHJpbnQoc3RyaW5nczogc3RyaW5nW10pOiB2b2lkO1xuICBhZGRCb3JkZXIoc3RyaW5nczogc3RyaW5nW10pOiBzdHJpbmdbXTtcbiAgb24oZXZlbnQ6IFwicmVzaXplXCIsIGxpc3RlbmVyOiBSZXNpemVFdmVudExpc3RlbmVyKTogdGhpcztcbiAgY2VudGVyU3RyaW5nKHN0cjogc3RyaW5nLCBsaW5lV2lkdGg6IG51bWJlciwgZmlsbENoYXI/OiBzdHJpbmcpOiBzdHJpbmc7XG4gIGNsZWFyU2NyZWVuKCk6IHZvaWQ7XG4gIGNvbHVtbnM6IG51bWJlcjtcbiAgcm93czogbnVtYmVyO1xufVxuXG5pbnRlcmZhY2UgU2NyZWVuV3JpdGVyT3B0aW9ucyB7XG4gIHdpdGhCb3JkZXI/OiBib29sZWFuO1xuICBib3JkZXJDb2xvcj86IENvbG9yIHwgbnVsbDtcbiAgYm9yZGVyQmdDb2xvcj86IENvbG9yIHwgbnVsbDtcbn1cblxudHlwZSBSZXNpemVFdmVudExpc3RlbmVyID0gKG5ld1NjcmVlbkRpbWVuc2lvbnM6IFNjcmVlbkRpbWVuc2lvbnMpID0+IHZvaWQ7XG5cbmV4cG9ydCB0eXBlIFNjcmVlbkRpbWVuc2lvbnMgPSB7XG4gIGNvbHVtbnM6IG51bWJlcjtcbiAgcm93czogbnVtYmVyO1xufTtcblxuZXhwb3J0IGNsYXNzIFNjcmVlbldyaXRlciBleHRlbmRzIEV2ZW50RW1pdHRlclxuICBpbXBsZW1lbnRzIFNjcmVlbldyaXRlckludGVyZmFjZSB7XG4gIC8qKiBjb25zb2xlIGNvbHVtbnMgKi9cbiAgcHJpdmF0ZSBfY29sdW1uczogbnVtYmVyID0gMDtcbiAgLyoqIGNvbnNvbGUgcm93cyAqL1xuICBwcml2YXRlIF9yb3dzOiBudW1iZXIgPSAwO1xuXG4gIC8qKiBjaGFsayBmdW5jdGlvbiB1c2VkIHRvIGNvbG9yIHRoZSBib3JkZXIgKi9cbiAgYm9yZGVyQ29sb3I6IGNoYWxrLkNoYWxrIHwgdW5kZWZpbmVkO1xuXG4gIC8qKiBzaG91bGQgdGhlIGJvcmRlciBiZSBhZGRlZCAqL1xuICBwcml2YXRlIF9ib3JkZXIgPSB0cnVlO1xuXG4gIC8qKiB1c2VkIHRvIGRldGVybWluZSB3aGljaCBsaW5lcyBzaG91bGQgYmUgcmVkcmF3biAqL1xuICBwcml2YXRlIHByZXZpb3VzTGluZXM6IHN0cmluZ1tdID0gW107XG5cbiAgY29uc3RydWN0b3Iob3B0czogU2NyZWVuV3JpdGVyT3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMudXBkYXRlU2NyZWVuU2l6ZSh0cnVlKTtcbiAgICAvLyBsaXN0ZW4gZm9yIHNjcmVlbiByZXNpemVcbiAgICBwcm9jZXNzLnN0ZG91dC5vbihcInJlc2l6ZVwiLCAoKSA9PiB0aGlzLnVwZGF0ZVNjcmVlblNpemUoKSk7XG5cbiAgICBpZiAob3B0cy53aXRoQm9yZGVyICE9PSB1bmRlZmluZWQpIHRoaXMuX2JvcmRlciA9IG9wdHMud2l0aEJvcmRlcjtcblxuICAgIC8vIGdldCBib3JkZXIgY29sb3JcbiAgICBjb25zdCBib3JkZXJDb2xvciA9XG4gICAgICBvcHRzLmJvcmRlckNvbG9yICE9PSBudWxsID8gb3B0cy5ib3JkZXJDb2xvciB8fCBcIndoaXRlXCIgOiBudWxsO1xuICAgIGNvbnN0IGJvcmRlckJnQ29sb3IgPVxuICAgICAgb3B0cy5ib3JkZXJCZ0NvbG9yICE9PSBudWxsID8gb3B0cy5ib3JkZXJCZ0NvbG9yIHx8IFwiYmxhY2tcIiA6IG51bGw7XG4gICAgaWYgKCFib3JkZXJCZ0NvbG9yICYmICFib3JkZXJDb2xvcikgdGhpcy5fYm9yZGVyID0gZmFsc2U7XG4gICAgZWxzZSBpZiAoYm9yZGVyQmdDb2xvciAmJiBib3JkZXJDb2xvcilcbiAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPVxuICAgICAgICBjaGFsa1tnZXRGb3JlZ3JvdW5kQ29sb3IoYm9yZGVyQ29sb3IpXVtcbiAgICAgICAgICBnZXRCYWNrZ3JvdW5kQ29sb3IoYm9yZGVyQmdDb2xvcilcbiAgICAgICAgXTtcbiAgICBlbHNlIGlmIChib3JkZXJDb2xvcilcbiAgICAgIHRoaXMuYm9yZGVyQ29sb3IgPSBjaGFsa1tnZXRGb3JlZ3JvdW5kQ29sb3IoYm9yZGVyQ29sb3IpXTtcbiAgICBlbHNlIGlmIChib3JkZXJCZ0NvbG9yKVxuICAgICAgdGhpcy5ib3JkZXJDb2xvciA9IGNoYWxrW2dldEJhY2tncm91bmRDb2xvcihib3JkZXJCZ0NvbG9yKV07XG4gIH1cblxuICBvbihldmVudDogXCJyZXNpemVcIiwgbGlzdGVuZXI6IFJlc2l6ZUV2ZW50TGlzdGVuZXIpOiB0aGlzIHtcbiAgICByZXR1cm4gc3VwZXIub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlU2NyZWVuU2l6ZShub0VtaXQgPSBmYWxzZSkge1xuICAgIGNvbnN0IFtjb2x1bW5zLCByb3dzXSA9IHByb2Nlc3Muc3Rkb3V0LmdldFdpbmRvd1NpemUoKTtcbiAgICB0aGlzLl9jb2x1bW5zID0gY29sdW1ucztcbiAgICB0aGlzLl9yb3dzID0gcm93cztcbiAgICB0aGlzLnByZXZpb3VzTGluZXMgPSBbXTtcblxuICAgIGlmICghbm9FbWl0KSB0aGlzLmVtaXQoXCJyZXNpemVcIiwgeyBjb2x1bW5zLCByb3dzIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgbnVtYmVyIG9mIGNvbHVtbnMgYXZhaWxhYmxlIHRvIHdyaXRlIHRvXG4gICAqIFRha2VzIGJvcmRlciBpbnRvIGFjY291bnRcbiAgICovXG4gIGdldCBjb2x1bW5zKCkge1xuICAgIHJldHVybiB0aGlzLl9ib3JkZXIgPyB0aGlzLl9jb2x1bW5zIC0gMiA6IHRoaXMuX2NvbHVtbnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBudW1iZXIgb2Ygcm93cyBhdmFpbGFibGUgdG8gd3JpdGUgdG9cbiAgICogVGFrZXMgYm9yZGVyIGludG8gYWNjb3VudFxuICAgKi9cbiAgZ2V0IHJvd3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JvcmRlciA/IHRoaXMuX3Jvd3MgLSAyIDogdGhpcy5fcm93cztcbiAgfVxuXG4gIC8qKlxuICAgKiBDZW50ZXJzIGxpbmVzIG9uIHNjcmVlbiBpZiBuZWVkZWRcbiAgICogQHBhcmFtIHN0cmluZ3NcbiAgICovXG4gIGNlbnRlclN0cmluZ3NPblNjcmVlbihzdHJpbmdzOiBzdHJpbmdbXSkge1xuICAgIGNvbnN0IHJvd3MgPSB0aGlzLl9yb3dzO1xuICAgIGNvbnN0IGNvbHVtbnMgPSB0aGlzLl9jb2x1bW5zO1xuXG4gICAgaWYgKHN0cmluZ3MubGVuZ3RoID09PSByb3dzICYmIHN0cmlwQW5zaShzdHJpbmdzWzBdKS5sZW5ndGggPT09IGNvbHVtbnMpXG4gICAgICByZXR1cm4gc3RyaW5ncztcblxuICAgIGNvbnN0IGVtcHR5TGluZSA9IFwiIFwiLnJlcGVhdChjb2x1bW5zKTtcblxuICAgIGNvbnN0IGVtcHR5TGluZXNOZWVkZWQgPSAocm93cyAtIHN0cmluZ3MubGVuZ3RoKSAvIDI7XG5cbiAgICByZXR1cm4gW1xuICAgICAgLi4uQXJyYXkoTWF0aC5mbG9vcihlbXB0eUxpbmVzTmVlZGVkKSkuZmlsbChlbXB0eUxpbmUpLFxuICAgICAgLi4uc3RyaW5ncy5tYXAoKHN0cikgPT4gdGhpcy5jZW50ZXJTdHJpbmcoc3RyLCBjb2x1bW5zKSksXG4gICAgICAuLi5BcnJheShNYXRoLmNlaWwoZW1wdHlMaW5lc05lZWRlZCkpLmZpbGwoZW1wdHlMaW5lKSxcbiAgICBdO1xuICB9XG5cbiAgY2xlYXJTY3JlZW4oKSB7XG4gICAgdGhpcy5wcmV2aW91c0xpbmVzID0gW107XG4gICAgY29uc29sZS5jbGVhcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIGhlbHBlciBmdW5jdGlvbiB0byBjZW50ZXIgdGV4dFxuICAgKiBAcGFyYW0gc3RyIHN0cmluZyB0byBiZSBjZW50ZXJlZFxuICAgKiBAcGFyYW0gbGluZVdpZHRoIGRlc2lyZWQgbGluZSB3aWR0aFxuICAgKiBAcGFyYW0gZmlsbENoYXIgQ2hhcmFjdGVyIHRvIGJlIHVzZWQgYXMgYSBmaWxsZXIsIGRlZmF1bHQ6ICcgJ1xuICAgKi9cbiAgY2VudGVyU3RyaW5nKHN0cjogc3RyaW5nLCBsaW5lV2lkdGg6IG51bWJlciA9IHRoaXMuX2NvbHVtbnMsIGZpbGxDaGFyID0gXCIgXCIpIHtcbiAgICBpZiAobGluZVdpZHRoIDw9IDApXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgYExpbmUgd2lkdGggc2hvdWxkIGJlIGJpZ2dlciB0aGFuIDAuIFJlY2VpdmVkOiAke2xpbmVXaWR0aH1gXG4gICAgICApO1xuXG4gICAgY29uc3Qgc3RyaXBwZWRTdHIgPSBzdHJpcEFuc2koc3RyKTtcblxuICAgIGlmIChzdHJpcHBlZFN0ci5sZW5ndGggPT09IGxpbmVXaWR0aCkgcmV0dXJuIHN0cjtcbiAgICAvLyBXUk9ORywgaG93IHRvIHByb3Blcmx5IHN0cmlwIGEgc3RyaW5nIHdpdGggYW5zaSBjaGFycz9cbiAgICBpZiAoc3RyaXBwZWRTdHIubGVuZ3RoID4gbGluZVdpZHRoKSByZXR1cm4gc3RyaXBwZWRTdHIuc2xpY2UoMCwgbGluZVdpZHRoKTtcblxuICAgIGNvbnN0IHBhZGRpbmcgPSAobGluZVdpZHRoIC0gc3RyaXBwZWRTdHIubGVuZ3RoKSAvIDI7XG5cbiAgICByZXR1cm4gKFxuICAgICAgZmlsbENoYXIucmVwZWF0KE1hdGguZmxvb3IocGFkZGluZykpICtcbiAgICAgIHN0ciArXG4gICAgICBmaWxsQ2hhci5yZXBlYXQoTWF0aC5jZWlsKHBhZGRpbmcpKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgdG8gc3Rkb3V0XG4gICAqIFRoZSBhc3N1bXB0aW9uIGlzIGFsbCBzdHJpbmdzIGluIHRoZSBhcnJheSBhcmUgdGhlIHNhbWUgd2lkdGhcbiAgICogQHBhcmFtIHN0cmluZ3MgQXJyYXkgb2Ygc3RyaW5ncyB0byB3cml0ZVxuICAgKi9cbiAgcHJpbnQoc3RyaW5nczogc3RyaW5nW10pIHtcbiAgICBpZiAodGhpcy5fYm9yZGVyKSBzdHJpbmdzID0gdGhpcy5hZGRCb3JkZXIoc3RyaW5ncyk7XG4gICAgc3RyaW5ncyA9IHRoaXMuY2VudGVyU3RyaW5nc09uU2NyZWVuKHN0cmluZ3MpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCByb3cgPSBzdHJpbmdzW2ldO1xuICAgICAgLy8gd2UnbGwgYmUgcmVkcmF3aW5nIG9ubHkgY2hhbmdlZCBsaW5lc1xuICAgICAgaWYgKHJvdyAhPT0gdGhpcy5wcmV2aW91c0xpbmVzW2ldKSB7XG4gICAgICAgIHByb2Nlc3Muc3Rkb3V0LmN1cnNvclRvKDAsIGkpO1xuICAgICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShyb3cpO1xuICAgICAgICBpZiAoaSA8IHN0cmluZ3MubGVuZ3RoIC0gMSkgcHJvY2Vzcy5zdGRvdXQud3JpdGUoXCJcXG5cIik7XG4gICAgICAgIHRoaXMucHJldmlvdXNMaW5lc1tpXSA9IHJvdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbGlDdXJzb3IuaGlkZSgpO1xuICB9XG5cbiAgYWRkQm9yZGVyKGFycjogc3RyaW5nW10pIHtcbiAgICBpZiAoIXRoaXMuX2JvcmRlciB8fCAhdGhpcy5ib3JkZXJDb2xvcikgcmV0dXJuIGFycjtcblxuICAgIGNvbnN0IHNpZGVCb3JkZXIgPSB0aGlzLmJvcmRlckNvbG9yKFwi4pSCXCIpO1xuICAgIGNvbnN0IGxpbmVXaWR0aCA9IHN0cmlwQW5zaShhcnJbMF0pLmxlbmd0aDtcbiAgICByZXR1cm4gW1xuICAgICAgLy8gdG9wIGJvcmRlclxuICAgICAgdGhpcy5ib3JkZXJDb2xvcihcIuKUjFwiICsgXCLilIBcIi5yZXBlYXQobGluZVdpZHRoKSArIFwi4pSQXCIpLFxuICAgICAgLy8gYWRkIGxlZnQgYW5kIHJpZ2h0IGJvcmRlcnNcbiAgICAgIC4uLmFyci5tYXAoKHJvdykgPT4gc2lkZUJvcmRlciArIHJvdyArIHNpZGVCb3JkZXIpLFxuICAgICAgLy8gYm90dG9tIGJvcmRlclxuICAgICAgdGhpcy5ib3JkZXJDb2xvcihcIuKUlFwiICsgXCLilIBcIi5yZXBlYXQobGluZVdpZHRoKSArIFwi4pSYXCIpLFxuICAgIF07XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///26\n')},function(module,exports){eval('module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, "loaded", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, "id", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzP2NlZDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27\n')},function(module,exports,__webpack_require__){eval("const conversions = __webpack_require__(17);\nconst route = __webpack_require__(30);\n\nconst convert = {};\n\nconst models = Object.keys(conversions);\n\nfunction wrapRaw(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\treturn fn(args);\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nfunction wrapRounded(fn) {\n\tconst wrappedFn = function (...args) {\n\t\tconst arg0 = args[0];\n\n\t\tif (arg0 === undefined || arg0 === null) {\n\t\t\treturn arg0;\n\t\t}\n\n\t\tif (arg0.length > 1) {\n\t\t\targs = arg0;\n\t\t}\n\n\t\tconst result = fn(args);\n\n\t\t// We're assuming the result is an array here.\n\t\t// see notice in conversions.js; don't use box types\n\t\t// in conversion functions.\n\t\tif (typeof result === 'object') {\n\t\t\tfor (let len = result.length, i = 0; i < len; i++) {\n\t\t\t\tresult[i] = Math.round(result[i]);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t// Preserve .conversion property if there is one\n\tif ('conversion' in fn) {\n\t\twrappedFn.conversion = fn.conversion;\n\t}\n\n\treturn wrappedFn;\n}\n\nmodels.forEach(fromModel => {\n\tconvert[fromModel] = {};\n\n\tObject.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});\n\tObject.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});\n\n\tconst routes = route(fromModel);\n\tconst routeModels = Object.keys(routes);\n\n\trouteModels.forEach(toModel => {\n\t\tconst fn = routes[toModel];\n\n\t\tconvert[fromModel][toModel] = wrapRounded(fn);\n\t\tconvert[fromModel][toModel].raw = wrapRaw(fn);\n\t});\n});\n\nmodule.exports = convert;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29sb3ItY29udmVydC9pbmRleC5qcz9iYjE1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG9CQUFvQixtQkFBTyxDQUFDLEVBQWU7QUFDM0MsY0FBYyxtQkFBTyxDQUFDLEVBQVM7O0FBRS9COztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0RBQXdELHVDQUF1QztBQUMvRixzREFBc0QscUNBQXFDOztBQUUzRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVEIiwiZmlsZSI6IjI4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udmVyc2lvbnMgPSByZXF1aXJlKCcuL2NvbnZlcnNpb25zJyk7XG5jb25zdCByb3V0ZSA9IHJlcXVpcmUoJy4vcm91dGUnKTtcblxuY29uc3QgY29udmVydCA9IHt9O1xuXG5jb25zdCBtb2RlbHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9ucyk7XG5cbmZ1bmN0aW9uIHdyYXBSYXcoZm4pIHtcblx0Y29uc3Qgd3JhcHBlZEZuID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcblx0XHRjb25zdCBhcmcwID0gYXJnc1swXTtcblx0XHRpZiAoYXJnMCA9PT0gdW5kZWZpbmVkIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBhcmcwO1xuXHRcdH1cblxuXHRcdGlmIChhcmcwLmxlbmd0aCA+IDEpIHtcblx0XHRcdGFyZ3MgPSBhcmcwO1xuXHRcdH1cblxuXHRcdHJldHVybiBmbihhcmdzKTtcblx0fTtcblxuXHQvLyBQcmVzZXJ2ZSAuY29udmVyc2lvbiBwcm9wZXJ0eSBpZiB0aGVyZSBpcyBvbmVcblx0aWYgKCdjb252ZXJzaW9uJyBpbiBmbikge1xuXHRcdHdyYXBwZWRGbi5jb252ZXJzaW9uID0gZm4uY29udmVyc2lvbjtcblx0fVxuXG5cdHJldHVybiB3cmFwcGVkRm47XG59XG5cbmZ1bmN0aW9uIHdyYXBSb3VuZGVkKGZuKSB7XG5cdGNvbnN0IHdyYXBwZWRGbiA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG5cdFx0Y29uc3QgYXJnMCA9IGFyZ3NbMF07XG5cblx0XHRpZiAoYXJnMCA9PT0gdW5kZWZpbmVkIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBhcmcwO1xuXHRcdH1cblxuXHRcdGlmIChhcmcwLmxlbmd0aCA+IDEpIHtcblx0XHRcdGFyZ3MgPSBhcmcwO1xuXHRcdH1cblxuXHRcdGNvbnN0IHJlc3VsdCA9IGZuKGFyZ3MpO1xuXG5cdFx0Ly8gV2UncmUgYXNzdW1pbmcgdGhlIHJlc3VsdCBpcyBhbiBhcnJheSBoZXJlLlxuXHRcdC8vIHNlZSBub3RpY2UgaW4gY29udmVyc2lvbnMuanM7IGRvbid0IHVzZSBib3ggdHlwZXNcblx0XHQvLyBpbiBjb252ZXJzaW9uIGZ1bmN0aW9ucy5cblx0XHRpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGZvciAobGV0IGxlbiA9IHJlc3VsdC5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmVzdWx0W2ldID0gTWF0aC5yb3VuZChyZXN1bHRbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Ly8gUHJlc2VydmUgLmNvbnZlcnNpb24gcHJvcGVydHkgaWYgdGhlcmUgaXMgb25lXG5cdGlmICgnY29udmVyc2lvbicgaW4gZm4pIHtcblx0XHR3cmFwcGVkRm4uY29udmVyc2lvbiA9IGZuLmNvbnZlcnNpb247XG5cdH1cblxuXHRyZXR1cm4gd3JhcHBlZEZuO1xufVxuXG5tb2RlbHMuZm9yRWFjaChmcm9tTW9kZWwgPT4ge1xuXHRjb252ZXJ0W2Zyb21Nb2RlbF0gPSB7fTtcblxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udmVydFtmcm9tTW9kZWxdLCAnY2hhbm5lbHMnLCB7dmFsdWU6IGNvbnZlcnNpb25zW2Zyb21Nb2RlbF0uY2hhbm5lbHN9KTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGNvbnZlcnRbZnJvbU1vZGVsXSwgJ2xhYmVscycsIHt2YWx1ZTogY29udmVyc2lvbnNbZnJvbU1vZGVsXS5sYWJlbHN9KTtcblxuXHRjb25zdCByb3V0ZXMgPSByb3V0ZShmcm9tTW9kZWwpO1xuXHRjb25zdCByb3V0ZU1vZGVscyA9IE9iamVjdC5rZXlzKHJvdXRlcyk7XG5cblx0cm91dGVNb2RlbHMuZm9yRWFjaCh0b01vZGVsID0+IHtcblx0XHRjb25zdCBmbiA9IHJvdXRlc1t0b01vZGVsXTtcblxuXHRcdGNvbnZlcnRbZnJvbU1vZGVsXVt0b01vZGVsXSA9IHdyYXBSb3VuZGVkKGZuKTtcblx0XHRjb252ZXJ0W2Zyb21Nb2RlbF1bdG9Nb2RlbF0ucmF3ID0gd3JhcFJhdyhmbik7XG5cdH0pO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY29udmVydDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///28\n")},function(module,exports,__webpack_require__){"use strict";eval('\r\n\r\nmodule.exports = {\r\n\t"aliceblue": [240, 248, 255],\r\n\t"antiquewhite": [250, 235, 215],\r\n\t"aqua": [0, 255, 255],\r\n\t"aquamarine": [127, 255, 212],\r\n\t"azure": [240, 255, 255],\r\n\t"beige": [245, 245, 220],\r\n\t"bisque": [255, 228, 196],\r\n\t"black": [0, 0, 0],\r\n\t"blanchedalmond": [255, 235, 205],\r\n\t"blue": [0, 0, 255],\r\n\t"blueviolet": [138, 43, 226],\r\n\t"brown": [165, 42, 42],\r\n\t"burlywood": [222, 184, 135],\r\n\t"cadetblue": [95, 158, 160],\r\n\t"chartreuse": [127, 255, 0],\r\n\t"chocolate": [210, 105, 30],\r\n\t"coral": [255, 127, 80],\r\n\t"cornflowerblue": [100, 149, 237],\r\n\t"cornsilk": [255, 248, 220],\r\n\t"crimson": [220, 20, 60],\r\n\t"cyan": [0, 255, 255],\r\n\t"darkblue": [0, 0, 139],\r\n\t"darkcyan": [0, 139, 139],\r\n\t"darkgoldenrod": [184, 134, 11],\r\n\t"darkgray": [169, 169, 169],\r\n\t"darkgreen": [0, 100, 0],\r\n\t"darkgrey": [169, 169, 169],\r\n\t"darkkhaki": [189, 183, 107],\r\n\t"darkmagenta": [139, 0, 139],\r\n\t"darkolivegreen": [85, 107, 47],\r\n\t"darkorange": [255, 140, 0],\r\n\t"darkorchid": [153, 50, 204],\r\n\t"darkred": [139, 0, 0],\r\n\t"darksalmon": [233, 150, 122],\r\n\t"darkseagreen": [143, 188, 143],\r\n\t"darkslateblue": [72, 61, 139],\r\n\t"darkslategray": [47, 79, 79],\r\n\t"darkslategrey": [47, 79, 79],\r\n\t"darkturquoise": [0, 206, 209],\r\n\t"darkviolet": [148, 0, 211],\r\n\t"deeppink": [255, 20, 147],\r\n\t"deepskyblue": [0, 191, 255],\r\n\t"dimgray": [105, 105, 105],\r\n\t"dimgrey": [105, 105, 105],\r\n\t"dodgerblue": [30, 144, 255],\r\n\t"firebrick": [178, 34, 34],\r\n\t"floralwhite": [255, 250, 240],\r\n\t"forestgreen": [34, 139, 34],\r\n\t"fuchsia": [255, 0, 255],\r\n\t"gainsboro": [220, 220, 220],\r\n\t"ghostwhite": [248, 248, 255],\r\n\t"gold": [255, 215, 0],\r\n\t"goldenrod": [218, 165, 32],\r\n\t"gray": [128, 128, 128],\r\n\t"green": [0, 128, 0],\r\n\t"greenyellow": [173, 255, 47],\r\n\t"grey": [128, 128, 128],\r\n\t"honeydew": [240, 255, 240],\r\n\t"hotpink": [255, 105, 180],\r\n\t"indianred": [205, 92, 92],\r\n\t"indigo": [75, 0, 130],\r\n\t"ivory": [255, 255, 240],\r\n\t"khaki": [240, 230, 140],\r\n\t"lavender": [230, 230, 250],\r\n\t"lavenderblush": [255, 240, 245],\r\n\t"lawngreen": [124, 252, 0],\r\n\t"lemonchiffon": [255, 250, 205],\r\n\t"lightblue": [173, 216, 230],\r\n\t"lightcoral": [240, 128, 128],\r\n\t"lightcyan": [224, 255, 255],\r\n\t"lightgoldenrodyellow": [250, 250, 210],\r\n\t"lightgray": [211, 211, 211],\r\n\t"lightgreen": [144, 238, 144],\r\n\t"lightgrey": [211, 211, 211],\r\n\t"lightpink": [255, 182, 193],\r\n\t"lightsalmon": [255, 160, 122],\r\n\t"lightseagreen": [32, 178, 170],\r\n\t"lightskyblue": [135, 206, 250],\r\n\t"lightslategray": [119, 136, 153],\r\n\t"lightslategrey": [119, 136, 153],\r\n\t"lightsteelblue": [176, 196, 222],\r\n\t"lightyellow": [255, 255, 224],\r\n\t"lime": [0, 255, 0],\r\n\t"limegreen": [50, 205, 50],\r\n\t"linen": [250, 240, 230],\r\n\t"magenta": [255, 0, 255],\r\n\t"maroon": [128, 0, 0],\r\n\t"mediumaquamarine": [102, 205, 170],\r\n\t"mediumblue": [0, 0, 205],\r\n\t"mediumorchid": [186, 85, 211],\r\n\t"mediumpurple": [147, 112, 219],\r\n\t"mediumseagreen": [60, 179, 113],\r\n\t"mediumslateblue": [123, 104, 238],\r\n\t"mediumspringgreen": [0, 250, 154],\r\n\t"mediumturquoise": [72, 209, 204],\r\n\t"mediumvioletred": [199, 21, 133],\r\n\t"midnightblue": [25, 25, 112],\r\n\t"mintcream": [245, 255, 250],\r\n\t"mistyrose": [255, 228, 225],\r\n\t"moccasin": [255, 228, 181],\r\n\t"navajowhite": [255, 222, 173],\r\n\t"navy": [0, 0, 128],\r\n\t"oldlace": [253, 245, 230],\r\n\t"olive": [128, 128, 0],\r\n\t"olivedrab": [107, 142, 35],\r\n\t"orange": [255, 165, 0],\r\n\t"orangered": [255, 69, 0],\r\n\t"orchid": [218, 112, 214],\r\n\t"palegoldenrod": [238, 232, 170],\r\n\t"palegreen": [152, 251, 152],\r\n\t"paleturquoise": [175, 238, 238],\r\n\t"palevioletred": [219, 112, 147],\r\n\t"papayawhip": [255, 239, 213],\r\n\t"peachpuff": [255, 218, 185],\r\n\t"peru": [205, 133, 63],\r\n\t"pink": [255, 192, 203],\r\n\t"plum": [221, 160, 221],\r\n\t"powderblue": [176, 224, 230],\r\n\t"purple": [128, 0, 128],\r\n\t"rebeccapurple": [102, 51, 153],\r\n\t"red": [255, 0, 0],\r\n\t"rosybrown": [188, 143, 143],\r\n\t"royalblue": [65, 105, 225],\r\n\t"saddlebrown": [139, 69, 19],\r\n\t"salmon": [250, 128, 114],\r\n\t"sandybrown": [244, 164, 96],\r\n\t"seagreen": [46, 139, 87],\r\n\t"seashell": [255, 245, 238],\r\n\t"sienna": [160, 82, 45],\r\n\t"silver": [192, 192, 192],\r\n\t"skyblue": [135, 206, 235],\r\n\t"slateblue": [106, 90, 205],\r\n\t"slategray": [112, 128, 144],\r\n\t"slategrey": [112, 128, 144],\r\n\t"snow": [255, 250, 250],\r\n\t"springgreen": [0, 255, 127],\r\n\t"steelblue": [70, 130, 180],\r\n\t"tan": [210, 180, 140],\r\n\t"teal": [0, 128, 128],\r\n\t"thistle": [216, 191, 216],\r\n\t"tomato": [255, 99, 71],\r\n\t"turquoise": [64, 224, 208],\r\n\t"violet": [238, 130, 238],\r\n\t"wheat": [245, 222, 179],\r\n\t"white": [255, 255, 255],\r\n\t"whitesmoke": [245, 245, 245],\r\n\t"yellow": [255, 255, 0],\r\n\t"yellowgreen": [154, 205, 50]\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29sb3ItbmFtZS9pbmRleC5qcz80ZjRkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcblx0XCJhbGljZWJsdWVcIjogWzI0MCwgMjQ4LCAyNTVdLFxyXG5cdFwiYW50aXF1ZXdoaXRlXCI6IFsyNTAsIDIzNSwgMjE1XSxcclxuXHRcImFxdWFcIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImFxdWFtYXJpbmVcIjogWzEyNywgMjU1LCAyMTJdLFxyXG5cdFwiYXp1cmVcIjogWzI0MCwgMjU1LCAyNTVdLFxyXG5cdFwiYmVpZ2VcIjogWzI0NSwgMjQ1LCAyMjBdLFxyXG5cdFwiYmlzcXVlXCI6IFsyNTUsIDIyOCwgMTk2XSxcclxuXHRcImJsYWNrXCI6IFswLCAwLCAwXSxcclxuXHRcImJsYW5jaGVkYWxtb25kXCI6IFsyNTUsIDIzNSwgMjA1XSxcclxuXHRcImJsdWVcIjogWzAsIDAsIDI1NV0sXHJcblx0XCJibHVldmlvbGV0XCI6IFsxMzgsIDQzLCAyMjZdLFxyXG5cdFwiYnJvd25cIjogWzE2NSwgNDIsIDQyXSxcclxuXHRcImJ1cmx5d29vZFwiOiBbMjIyLCAxODQsIDEzNV0sXHJcblx0XCJjYWRldGJsdWVcIjogWzk1LCAxNTgsIDE2MF0sXHJcblx0XCJjaGFydHJldXNlXCI6IFsxMjcsIDI1NSwgMF0sXHJcblx0XCJjaG9jb2xhdGVcIjogWzIxMCwgMTA1LCAzMF0sXHJcblx0XCJjb3JhbFwiOiBbMjU1LCAxMjcsIDgwXSxcclxuXHRcImNvcm5mbG93ZXJibHVlXCI6IFsxMDAsIDE0OSwgMjM3XSxcclxuXHRcImNvcm5zaWxrXCI6IFsyNTUsIDI0OCwgMjIwXSxcclxuXHRcImNyaW1zb25cIjogWzIyMCwgMjAsIDYwXSxcclxuXHRcImN5YW5cIjogWzAsIDI1NSwgMjU1XSxcclxuXHRcImRhcmtibHVlXCI6IFswLCAwLCAxMzldLFxyXG5cdFwiZGFya2N5YW5cIjogWzAsIDEzOSwgMTM5XSxcclxuXHRcImRhcmtnb2xkZW5yb2RcIjogWzE4NCwgMTM0LCAxMV0sXHJcblx0XCJkYXJrZ3JheVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJrZ3JlZW5cIjogWzAsIDEwMCwgMF0sXHJcblx0XCJkYXJrZ3JleVwiOiBbMTY5LCAxNjksIDE2OV0sXHJcblx0XCJkYXJra2hha2lcIjogWzE4OSwgMTgzLCAxMDddLFxyXG5cdFwiZGFya21hZ2VudGFcIjogWzEzOSwgMCwgMTM5XSxcclxuXHRcImRhcmtvbGl2ZWdyZWVuXCI6IFs4NSwgMTA3LCA0N10sXHJcblx0XCJkYXJrb3JhbmdlXCI6IFsyNTUsIDE0MCwgMF0sXHJcblx0XCJkYXJrb3JjaGlkXCI6IFsxNTMsIDUwLCAyMDRdLFxyXG5cdFwiZGFya3JlZFwiOiBbMTM5LCAwLCAwXSxcclxuXHRcImRhcmtzYWxtb25cIjogWzIzMywgMTUwLCAxMjJdLFxyXG5cdFwiZGFya3NlYWdyZWVuXCI6IFsxNDMsIDE4OCwgMTQzXSxcclxuXHRcImRhcmtzbGF0ZWJsdWVcIjogWzcyLCA2MSwgMTM5XSxcclxuXHRcImRhcmtzbGF0ZWdyYXlcIjogWzQ3LCA3OSwgNzldLFxyXG5cdFwiZGFya3NsYXRlZ3JleVwiOiBbNDcsIDc5LCA3OV0sXHJcblx0XCJkYXJrdHVycXVvaXNlXCI6IFswLCAyMDYsIDIwOV0sXHJcblx0XCJkYXJrdmlvbGV0XCI6IFsxNDgsIDAsIDIxMV0sXHJcblx0XCJkZWVwcGlua1wiOiBbMjU1LCAyMCwgMTQ3XSxcclxuXHRcImRlZXBza3libHVlXCI6IFswLCAxOTEsIDI1NV0sXHJcblx0XCJkaW1ncmF5XCI6IFsxMDUsIDEwNSwgMTA1XSxcclxuXHRcImRpbWdyZXlcIjogWzEwNSwgMTA1LCAxMDVdLFxyXG5cdFwiZG9kZ2VyYmx1ZVwiOiBbMzAsIDE0NCwgMjU1XSxcclxuXHRcImZpcmVicmlja1wiOiBbMTc4LCAzNCwgMzRdLFxyXG5cdFwiZmxvcmFsd2hpdGVcIjogWzI1NSwgMjUwLCAyNDBdLFxyXG5cdFwiZm9yZXN0Z3JlZW5cIjogWzM0LCAxMzksIDM0XSxcclxuXHRcImZ1Y2hzaWFcIjogWzI1NSwgMCwgMjU1XSxcclxuXHRcImdhaW5zYm9yb1wiOiBbMjIwLCAyMjAsIDIyMF0sXHJcblx0XCJnaG9zdHdoaXRlXCI6IFsyNDgsIDI0OCwgMjU1XSxcclxuXHRcImdvbGRcIjogWzI1NSwgMjE1LCAwXSxcclxuXHRcImdvbGRlbnJvZFwiOiBbMjE4LCAxNjUsIDMyXSxcclxuXHRcImdyYXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiZ3JlZW5cIjogWzAsIDEyOCwgMF0sXHJcblx0XCJncmVlbnllbGxvd1wiOiBbMTczLCAyNTUsIDQ3XSxcclxuXHRcImdyZXlcIjogWzEyOCwgMTI4LCAxMjhdLFxyXG5cdFwiaG9uZXlkZXdcIjogWzI0MCwgMjU1LCAyNDBdLFxyXG5cdFwiaG90cGlua1wiOiBbMjU1LCAxMDUsIDE4MF0sXHJcblx0XCJpbmRpYW5yZWRcIjogWzIwNSwgOTIsIDkyXSxcclxuXHRcImluZGlnb1wiOiBbNzUsIDAsIDEzMF0sXHJcblx0XCJpdm9yeVwiOiBbMjU1LCAyNTUsIDI0MF0sXHJcblx0XCJraGFraVwiOiBbMjQwLCAyMzAsIDE0MF0sXHJcblx0XCJsYXZlbmRlclwiOiBbMjMwLCAyMzAsIDI1MF0sXHJcblx0XCJsYXZlbmRlcmJsdXNoXCI6IFsyNTUsIDI0MCwgMjQ1XSxcclxuXHRcImxhd25ncmVlblwiOiBbMTI0LCAyNTIsIDBdLFxyXG5cdFwibGVtb25jaGlmZm9uXCI6IFsyNTUsIDI1MCwgMjA1XSxcclxuXHRcImxpZ2h0Ymx1ZVwiOiBbMTczLCAyMTYsIDIzMF0sXHJcblx0XCJsaWdodGNvcmFsXCI6IFsyNDAsIDEyOCwgMTI4XSxcclxuXHRcImxpZ2h0Y3lhblwiOiBbMjI0LCAyNTUsIDI1NV0sXHJcblx0XCJsaWdodGdvbGRlbnJvZHllbGxvd1wiOiBbMjUwLCAyNTAsIDIxMF0sXHJcblx0XCJsaWdodGdyYXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRncmVlblwiOiBbMTQ0LCAyMzgsIDE0NF0sXHJcblx0XCJsaWdodGdyZXlcIjogWzIxMSwgMjExLCAyMTFdLFxyXG5cdFwibGlnaHRwaW5rXCI6IFsyNTUsIDE4MiwgMTkzXSxcclxuXHRcImxpZ2h0c2FsbW9uXCI6IFsyNTUsIDE2MCwgMTIyXSxcclxuXHRcImxpZ2h0c2VhZ3JlZW5cIjogWzMyLCAxNzgsIDE3MF0sXHJcblx0XCJsaWdodHNreWJsdWVcIjogWzEzNSwgMjA2LCAyNTBdLFxyXG5cdFwibGlnaHRzbGF0ZWdyYXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzbGF0ZWdyZXlcIjogWzExOSwgMTM2LCAxNTNdLFxyXG5cdFwibGlnaHRzdGVlbGJsdWVcIjogWzE3NiwgMTk2LCAyMjJdLFxyXG5cdFwibGlnaHR5ZWxsb3dcIjogWzI1NSwgMjU1LCAyMjRdLFxyXG5cdFwibGltZVwiOiBbMCwgMjU1LCAwXSxcclxuXHRcImxpbWVncmVlblwiOiBbNTAsIDIwNSwgNTBdLFxyXG5cdFwibGluZW5cIjogWzI1MCwgMjQwLCAyMzBdLFxyXG5cdFwibWFnZW50YVwiOiBbMjU1LCAwLCAyNTVdLFxyXG5cdFwibWFyb29uXCI6IFsxMjgsIDAsIDBdLFxyXG5cdFwibWVkaXVtYXF1YW1hcmluZVwiOiBbMTAyLCAyMDUsIDE3MF0sXHJcblx0XCJtZWRpdW1ibHVlXCI6IFswLCAwLCAyMDVdLFxyXG5cdFwibWVkaXVtb3JjaGlkXCI6IFsxODYsIDg1LCAyMTFdLFxyXG5cdFwibWVkaXVtcHVycGxlXCI6IFsxNDcsIDExMiwgMjE5XSxcclxuXHRcIm1lZGl1bXNlYWdyZWVuXCI6IFs2MCwgMTc5LCAxMTNdLFxyXG5cdFwibWVkaXVtc2xhdGVibHVlXCI6IFsxMjMsIDEwNCwgMjM4XSxcclxuXHRcIm1lZGl1bXNwcmluZ2dyZWVuXCI6IFswLCAyNTAsIDE1NF0sXHJcblx0XCJtZWRpdW10dXJxdW9pc2VcIjogWzcyLCAyMDksIDIwNF0sXHJcblx0XCJtZWRpdW12aW9sZXRyZWRcIjogWzE5OSwgMjEsIDEzM10sXHJcblx0XCJtaWRuaWdodGJsdWVcIjogWzI1LCAyNSwgMTEyXSxcclxuXHRcIm1pbnRjcmVhbVwiOiBbMjQ1LCAyNTUsIDI1MF0sXHJcblx0XCJtaXN0eXJvc2VcIjogWzI1NSwgMjI4LCAyMjVdLFxyXG5cdFwibW9jY2FzaW5cIjogWzI1NSwgMjI4LCAxODFdLFxyXG5cdFwibmF2YWpvd2hpdGVcIjogWzI1NSwgMjIyLCAxNzNdLFxyXG5cdFwibmF2eVwiOiBbMCwgMCwgMTI4XSxcclxuXHRcIm9sZGxhY2VcIjogWzI1MywgMjQ1LCAyMzBdLFxyXG5cdFwib2xpdmVcIjogWzEyOCwgMTI4LCAwXSxcclxuXHRcIm9saXZlZHJhYlwiOiBbMTA3LCAxNDIsIDM1XSxcclxuXHRcIm9yYW5nZVwiOiBbMjU1LCAxNjUsIDBdLFxyXG5cdFwib3JhbmdlcmVkXCI6IFsyNTUsIDY5LCAwXSxcclxuXHRcIm9yY2hpZFwiOiBbMjE4LCAxMTIsIDIxNF0sXHJcblx0XCJwYWxlZ29sZGVucm9kXCI6IFsyMzgsIDIzMiwgMTcwXSxcclxuXHRcInBhbGVncmVlblwiOiBbMTUyLCAyNTEsIDE1Ml0sXHJcblx0XCJwYWxldHVycXVvaXNlXCI6IFsxNzUsIDIzOCwgMjM4XSxcclxuXHRcInBhbGV2aW9sZXRyZWRcIjogWzIxOSwgMTEyLCAxNDddLFxyXG5cdFwicGFwYXlhd2hpcFwiOiBbMjU1LCAyMzksIDIxM10sXHJcblx0XCJwZWFjaHB1ZmZcIjogWzI1NSwgMjE4LCAxODVdLFxyXG5cdFwicGVydVwiOiBbMjA1LCAxMzMsIDYzXSxcclxuXHRcInBpbmtcIjogWzI1NSwgMTkyLCAyMDNdLFxyXG5cdFwicGx1bVwiOiBbMjIxLCAxNjAsIDIyMV0sXHJcblx0XCJwb3dkZXJibHVlXCI6IFsxNzYsIDIyNCwgMjMwXSxcclxuXHRcInB1cnBsZVwiOiBbMTI4LCAwLCAxMjhdLFxyXG5cdFwicmViZWNjYXB1cnBsZVwiOiBbMTAyLCA1MSwgMTUzXSxcclxuXHRcInJlZFwiOiBbMjU1LCAwLCAwXSxcclxuXHRcInJvc3licm93blwiOiBbMTg4LCAxNDMsIDE0M10sXHJcblx0XCJyb3lhbGJsdWVcIjogWzY1LCAxMDUsIDIyNV0sXHJcblx0XCJzYWRkbGVicm93blwiOiBbMTM5LCA2OSwgMTldLFxyXG5cdFwic2FsbW9uXCI6IFsyNTAsIDEyOCwgMTE0XSxcclxuXHRcInNhbmR5YnJvd25cIjogWzI0NCwgMTY0LCA5Nl0sXHJcblx0XCJzZWFncmVlblwiOiBbNDYsIDEzOSwgODddLFxyXG5cdFwic2Vhc2hlbGxcIjogWzI1NSwgMjQ1LCAyMzhdLFxyXG5cdFwic2llbm5hXCI6IFsxNjAsIDgyLCA0NV0sXHJcblx0XCJzaWx2ZXJcIjogWzE5MiwgMTkyLCAxOTJdLFxyXG5cdFwic2t5Ymx1ZVwiOiBbMTM1LCAyMDYsIDIzNV0sXHJcblx0XCJzbGF0ZWJsdWVcIjogWzEwNiwgOTAsIDIwNV0sXHJcblx0XCJzbGF0ZWdyYXlcIjogWzExMiwgMTI4LCAxNDRdLFxyXG5cdFwic2xhdGVncmV5XCI6IFsxMTIsIDEyOCwgMTQ0XSxcclxuXHRcInNub3dcIjogWzI1NSwgMjUwLCAyNTBdLFxyXG5cdFwic3ByaW5nZ3JlZW5cIjogWzAsIDI1NSwgMTI3XSxcclxuXHRcInN0ZWVsYmx1ZVwiOiBbNzAsIDEzMCwgMTgwXSxcclxuXHRcInRhblwiOiBbMjEwLCAxODAsIDE0MF0sXHJcblx0XCJ0ZWFsXCI6IFswLCAxMjgsIDEyOF0sXHJcblx0XCJ0aGlzdGxlXCI6IFsyMTYsIDE5MSwgMjE2XSxcclxuXHRcInRvbWF0b1wiOiBbMjU1LCA5OSwgNzFdLFxyXG5cdFwidHVycXVvaXNlXCI6IFs2NCwgMjI0LCAyMDhdLFxyXG5cdFwidmlvbGV0XCI6IFsyMzgsIDEzMCwgMjM4XSxcclxuXHRcIndoZWF0XCI6IFsyNDUsIDIyMiwgMTc5XSxcclxuXHRcIndoaXRlXCI6IFsyNTUsIDI1NSwgMjU1XSxcclxuXHRcIndoaXRlc21va2VcIjogWzI0NSwgMjQ1LCAyNDVdLFxyXG5cdFwieWVsbG93XCI6IFsyNTUsIDI1NSwgMF0sXHJcblx0XCJ5ZWxsb3dncmVlblwiOiBbMTU0LCAyMDUsIDUwXVxyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29\n')},function(module,exports,__webpack_require__){eval("const conversions = __webpack_require__(17);\n\n/*\n\tThis function routes a model to all other models.\n\n\tall functions that are routed have a property `.conversion` attached\n\tto the returned synthetic function. This property is an array\n\tof strings, each with the steps in between the 'from' and 'to'\n\tcolor models (inclusive).\n\n\tconversions that are not possible simply are not included.\n*/\n\nfunction buildGraph() {\n\tconst graph = {};\n\t// https://jsperf.com/object-keys-vs-for-in-with-closure/3\n\tconst models = Object.keys(conversions);\n\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tgraph[models[i]] = {\n\t\t\t// http://jsperf.com/1-vs-infinity\n\t\t\t// micro-opt, but this is simple.\n\t\t\tdistance: -1,\n\t\t\tparent: null\n\t\t};\n\t}\n\n\treturn graph;\n}\n\n// https://en.wikipedia.org/wiki/Breadth-first_search\nfunction deriveBFS(fromModel) {\n\tconst graph = buildGraph();\n\tconst queue = [fromModel]; // Unshift -> queue -> pop\n\n\tgraph[fromModel].distance = 0;\n\n\twhile (queue.length) {\n\t\tconst current = queue.pop();\n\t\tconst adjacents = Object.keys(conversions[current]);\n\n\t\tfor (let len = adjacents.length, i = 0; i < len; i++) {\n\t\t\tconst adjacent = adjacents[i];\n\t\t\tconst node = graph[adjacent];\n\n\t\t\tif (node.distance === -1) {\n\t\t\t\tnode.distance = graph[current].distance + 1;\n\t\t\t\tnode.parent = current;\n\t\t\t\tqueue.unshift(adjacent);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn graph;\n}\n\nfunction link(from, to) {\n\treturn function (args) {\n\t\treturn to(from(args));\n\t};\n}\n\nfunction wrapConversion(toModel, graph) {\n\tconst path = [graph[toModel].parent, toModel];\n\tlet fn = conversions[graph[toModel].parent][toModel];\n\n\tlet cur = graph[toModel].parent;\n\twhile (graph[cur].parent) {\n\t\tpath.unshift(graph[cur].parent);\n\t\tfn = link(conversions[graph[cur].parent][cur], fn);\n\t\tcur = graph[cur].parent;\n\t}\n\n\tfn.conversion = path;\n\treturn fn;\n}\n\nmodule.exports = function (fromModel) {\n\tconst graph = deriveBFS(fromModel);\n\tconst conversion = {};\n\n\tconst models = Object.keys(graph);\n\tfor (let len = models.length, i = 0; i < len; i++) {\n\t\tconst toModel = models[i];\n\t\tconst node = graph[toModel];\n\n\t\tif (node.parent === null) {\n\t\t\t// No possible conversion, or this node is the source model.\n\t\t\tcontinue;\n\t\t}\n\n\t\tconversion[toModel] = wrapConversion(toModel, graph);\n\t}\n\n\treturn conversion;\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29sb3ItY29udmVydC9yb3V0ZS5qcz9hMjc5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG9CQUFvQixtQkFBTyxDQUFDLEVBQWU7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsU0FBUztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjMwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29udmVyc2lvbnMgPSByZXF1aXJlKCcuL2NvbnZlcnNpb25zJyk7XG5cbi8qXG5cdFRoaXMgZnVuY3Rpb24gcm91dGVzIGEgbW9kZWwgdG8gYWxsIG90aGVyIG1vZGVscy5cblxuXHRhbGwgZnVuY3Rpb25zIHRoYXQgYXJlIHJvdXRlZCBoYXZlIGEgcHJvcGVydHkgYC5jb252ZXJzaW9uYCBhdHRhY2hlZFxuXHR0byB0aGUgcmV0dXJuZWQgc3ludGhldGljIGZ1bmN0aW9uLiBUaGlzIHByb3BlcnR5IGlzIGFuIGFycmF5XG5cdG9mIHN0cmluZ3MsIGVhY2ggd2l0aCB0aGUgc3RlcHMgaW4gYmV0d2VlbiB0aGUgJ2Zyb20nIGFuZCAndG8nXG5cdGNvbG9yIG1vZGVscyAoaW5jbHVzaXZlKS5cblxuXHRjb252ZXJzaW9ucyB0aGF0IGFyZSBub3QgcG9zc2libGUgc2ltcGx5IGFyZSBub3QgaW5jbHVkZWQuXG4qL1xuXG5mdW5jdGlvbiBidWlsZEdyYXBoKCkge1xuXHRjb25zdCBncmFwaCA9IHt9O1xuXHQvLyBodHRwczovL2pzcGVyZi5jb20vb2JqZWN0LWtleXMtdnMtZm9yLWluLXdpdGgtY2xvc3VyZS8zXG5cdGNvbnN0IG1vZGVscyA9IE9iamVjdC5rZXlzKGNvbnZlcnNpb25zKTtcblxuXHRmb3IgKGxldCBsZW4gPSBtb2RlbHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0Z3JhcGhbbW9kZWxzW2ldXSA9IHtcblx0XHRcdC8vIGh0dHA6Ly9qc3BlcmYuY29tLzEtdnMtaW5maW5pdHlcblx0XHRcdC8vIG1pY3JvLW9wdCwgYnV0IHRoaXMgaXMgc2ltcGxlLlxuXHRcdFx0ZGlzdGFuY2U6IC0xLFxuXHRcdFx0cGFyZW50OiBudWxsXG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiBncmFwaDtcbn1cblxuLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQnJlYWR0aC1maXJzdF9zZWFyY2hcbmZ1bmN0aW9uIGRlcml2ZUJGUyhmcm9tTW9kZWwpIHtcblx0Y29uc3QgZ3JhcGggPSBidWlsZEdyYXBoKCk7XG5cdGNvbnN0IHF1ZXVlID0gW2Zyb21Nb2RlbF07IC8vIFVuc2hpZnQgLT4gcXVldWUgLT4gcG9wXG5cblx0Z3JhcGhbZnJvbU1vZGVsXS5kaXN0YW5jZSA9IDA7XG5cblx0d2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuXHRcdGNvbnN0IGN1cnJlbnQgPSBxdWV1ZS5wb3AoKTtcblx0XHRjb25zdCBhZGphY2VudHMgPSBPYmplY3Qua2V5cyhjb252ZXJzaW9uc1tjdXJyZW50XSk7XG5cblx0XHRmb3IgKGxldCBsZW4gPSBhZGphY2VudHMubGVuZ3RoLCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRjb25zdCBhZGphY2VudCA9IGFkamFjZW50c1tpXTtcblx0XHRcdGNvbnN0IG5vZGUgPSBncmFwaFthZGphY2VudF07XG5cblx0XHRcdGlmIChub2RlLmRpc3RhbmNlID09PSAtMSkge1xuXHRcdFx0XHRub2RlLmRpc3RhbmNlID0gZ3JhcGhbY3VycmVudF0uZGlzdGFuY2UgKyAxO1xuXHRcdFx0XHRub2RlLnBhcmVudCA9IGN1cnJlbnQ7XG5cdFx0XHRcdHF1ZXVlLnVuc2hpZnQoYWRqYWNlbnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBncmFwaDtcbn1cblxuZnVuY3Rpb24gbGluayhmcm9tLCB0bykge1xuXHRyZXR1cm4gZnVuY3Rpb24gKGFyZ3MpIHtcblx0XHRyZXR1cm4gdG8oZnJvbShhcmdzKSk7XG5cdH07XG59XG5cbmZ1bmN0aW9uIHdyYXBDb252ZXJzaW9uKHRvTW9kZWwsIGdyYXBoKSB7XG5cdGNvbnN0IHBhdGggPSBbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50LCB0b01vZGVsXTtcblx0bGV0IGZuID0gY29udmVyc2lvbnNbZ3JhcGhbdG9Nb2RlbF0ucGFyZW50XVt0b01vZGVsXTtcblxuXHRsZXQgY3VyID0gZ3JhcGhbdG9Nb2RlbF0ucGFyZW50O1xuXHR3aGlsZSAoZ3JhcGhbY3VyXS5wYXJlbnQpIHtcblx0XHRwYXRoLnVuc2hpZnQoZ3JhcGhbY3VyXS5wYXJlbnQpO1xuXHRcdGZuID0gbGluayhjb252ZXJzaW9uc1tncmFwaFtjdXJdLnBhcmVudF1bY3VyXSwgZm4pO1xuXHRcdGN1ciA9IGdyYXBoW2N1cl0ucGFyZW50O1xuXHR9XG5cblx0Zm4uY29udmVyc2lvbiA9IHBhdGg7XG5cdHJldHVybiBmbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZnJvbU1vZGVsKSB7XG5cdGNvbnN0IGdyYXBoID0gZGVyaXZlQkZTKGZyb21Nb2RlbCk7XG5cdGNvbnN0IGNvbnZlcnNpb24gPSB7fTtcblxuXHRjb25zdCBtb2RlbHMgPSBPYmplY3Qua2V5cyhncmFwaCk7XG5cdGZvciAobGV0IGxlbiA9IG1vZGVscy5sZW5ndGgsIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRjb25zdCB0b01vZGVsID0gbW9kZWxzW2ldO1xuXHRcdGNvbnN0IG5vZGUgPSBncmFwaFt0b01vZGVsXTtcblxuXHRcdGlmIChub2RlLnBhcmVudCA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gTm8gcG9zc2libGUgY29udmVyc2lvbiwgb3IgdGhpcyBub2RlIGlzIHRoZSBzb3VyY2UgbW9kZWwuXG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjb252ZXJzaW9uW3RvTW9kZWxdID0gd3JhcENvbnZlcnNpb24odG9Nb2RlbCwgZ3JhcGgpO1xuXHR9XG5cblx0cmV0dXJuIGNvbnZlcnNpb247XG59O1xuXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///30\n")},function(module,exports,__webpack_require__){"use strict";eval("\nconst os = __webpack_require__(32);\nconst tty = __webpack_require__(33);\nconst hasFlag = __webpack_require__(34);\n\nconst {env} = process;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false') ||\n\thasFlag('color=never')) {\n\tforceColor = 0;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = 1;\n}\n\nif ('FORCE_COLOR' in env) {\n\tif (env.FORCE_COLOR === 'true') {\n\t\tforceColor = 1;\n\t} else if (env.FORCE_COLOR === 'false') {\n\t\tforceColor = 0;\n\t} else {\n\t\tforceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);\n\t}\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(haveStream, streamIsTTY) {\n\tif (forceColor === 0) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (haveStream && !streamIsTTY && forceColor === undefined) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor || 0;\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n\t\t// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif ('GITHUB_ACTIONS' in env) {\n\t\treturn 1;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream, stream && stream.isTTY);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: translateLevel(supportsColor(true, tty.isatty(1))),\n\tstderr: translateLevel(supportsColor(true, tty.isatty(2)))\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3VwcG9ydHMtY29sb3IvaW5kZXguanM/NmMwYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLFdBQVcsbUJBQU8sQ0FBQyxFQUFJO0FBQ3ZCLFlBQVksbUJBQU8sQ0FBQyxFQUFLO0FBQ3pCLGdCQUFnQixtQkFBTyxDQUFDLEVBQVU7O0FBRWxDLE9BQU8sSUFBSTs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLEdBQUc7QUFDcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjMxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgdHR5ID0gcmVxdWlyZSgndHR5Jyk7XG5jb25zdCBoYXNGbGFnID0gcmVxdWlyZSgnaGFzLWZsYWcnKTtcblxuY29uc3Qge2Vudn0gPSBwcm9jZXNzO1xuXG5sZXQgZm9yY2VDb2xvcjtcbmlmIChoYXNGbGFnKCduby1jb2xvcicpIHx8XG5cdGhhc0ZsYWcoJ25vLWNvbG9ycycpIHx8XG5cdGhhc0ZsYWcoJ2NvbG9yPWZhbHNlJykgfHxcblx0aGFzRmxhZygnY29sb3I9bmV2ZXInKSkge1xuXHRmb3JjZUNvbG9yID0gMDtcbn0gZWxzZSBpZiAoaGFzRmxhZygnY29sb3InKSB8fFxuXHRoYXNGbGFnKCdjb2xvcnMnKSB8fFxuXHRoYXNGbGFnKCdjb2xvcj10cnVlJykgfHxcblx0aGFzRmxhZygnY29sb3I9YWx3YXlzJykpIHtcblx0Zm9yY2VDb2xvciA9IDE7XG59XG5cbmlmICgnRk9SQ0VfQ09MT1InIGluIGVudikge1xuXHRpZiAoZW52LkZPUkNFX0NPTE9SID09PSAndHJ1ZScpIHtcblx0XHRmb3JjZUNvbG9yID0gMTtcblx0fSBlbHNlIGlmIChlbnYuRk9SQ0VfQ09MT1IgPT09ICdmYWxzZScpIHtcblx0XHRmb3JjZUNvbG9yID0gMDtcblx0fSBlbHNlIHtcblx0XHRmb3JjZUNvbG9yID0gZW52LkZPUkNFX0NPTE9SLmxlbmd0aCA9PT0gMCA/IDEgOiBNYXRoLm1pbihwYXJzZUludChlbnYuRk9SQ0VfQ09MT1IsIDEwKSwgMyk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlTGV2ZWwobGV2ZWwpIHtcblx0aWYgKGxldmVsID09PSAwKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRsZXZlbCxcblx0XHRoYXNCYXNpYzogdHJ1ZSxcblx0XHRoYXMyNTY6IGxldmVsID49IDIsXG5cdFx0aGFzMTZtOiBsZXZlbCA+PSAzXG5cdH07XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzQ29sb3IoaGF2ZVN0cmVhbSwgc3RyZWFtSXNUVFkpIHtcblx0aWYgKGZvcmNlQ29sb3IgPT09IDApIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGlmIChoYXNGbGFnKCdjb2xvcj0xNm0nKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPWZ1bGwnKSB8fFxuXHRcdGhhc0ZsYWcoJ2NvbG9yPXRydWVjb2xvcicpKSB7XG5cdFx0cmV0dXJuIDM7XG5cdH1cblxuXHRpZiAoaGFzRmxhZygnY29sb3I9MjU2JykpIHtcblx0XHRyZXR1cm4gMjtcblx0fVxuXG5cdGlmIChoYXZlU3RyZWFtICYmICFzdHJlYW1Jc1RUWSAmJiBmb3JjZUNvbG9yID09PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gMDtcblx0fVxuXG5cdGNvbnN0IG1pbiA9IGZvcmNlQ29sb3IgfHwgMDtcblxuXHRpZiAoZW52LlRFUk0gPT09ICdkdW1iJykge1xuXHRcdHJldHVybiBtaW47XG5cdH1cblxuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuXHRcdC8vIFdpbmRvd3MgMTAgYnVpbGQgMTA1ODYgaXMgdGhlIGZpcnN0IFdpbmRvd3MgcmVsZWFzZSB0aGF0IHN1cHBvcnRzIDI1NiBjb2xvcnMuXG5cdFx0Ly8gV2luZG93cyAxMCBidWlsZCAxNDkzMSBpcyB0aGUgZmlyc3QgcmVsZWFzZSB0aGF0IHN1cHBvcnRzIDE2bS9UcnVlQ29sb3IuXG5cdFx0Y29uc3Qgb3NSZWxlYXNlID0gb3MucmVsZWFzZSgpLnNwbGl0KCcuJyk7XG5cdFx0aWYgKFxuXHRcdFx0TnVtYmVyKG9zUmVsZWFzZVswXSkgPj0gMTAgJiZcblx0XHRcdE51bWJlcihvc1JlbGVhc2VbMl0pID49IDEwNTg2XG5cdFx0KSB7XG5cdFx0XHRyZXR1cm4gTnVtYmVyKG9zUmVsZWFzZVsyXSkgPj0gMTQ5MzEgPyAzIDogMjtcblx0XHR9XG5cblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmICgnQ0knIGluIGVudikge1xuXHRcdGlmIChbJ1RSQVZJUycsICdDSVJDTEVDSScsICdBUFBWRVlPUicsICdHSVRMQUJfQ0knXS5zb21lKHNpZ24gPT4gc2lnbiBpbiBlbnYpIHx8IGVudi5DSV9OQU1FID09PSAnY29kZXNoaXAnKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWluO1xuXHR9XG5cblx0aWYgKCdURUFNQ0lUWV9WRVJTSU9OJyBpbiBlbnYpIHtcblx0XHRyZXR1cm4gL14oOVxcLigwKlsxLTldXFxkKilcXC58XFxkezIsfVxcLikvLnRlc3QoZW52LlRFQU1DSVRZX1ZFUlNJT04pID8gMSA6IDA7XG5cdH1cblxuXHRpZiAoJ0dJVEhVQl9BQ1RJT05TJyBpbiBlbnYpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmIChlbnYuQ09MT1JURVJNID09PSAndHJ1ZWNvbG9yJykge1xuXHRcdHJldHVybiAzO1xuXHR9XG5cblx0aWYgKCdURVJNX1BST0dSQU0nIGluIGVudikge1xuXHRcdGNvbnN0IHZlcnNpb24gPSBwYXJzZUludCgoZW52LlRFUk1fUFJPR1JBTV9WRVJTSU9OIHx8ICcnKS5zcGxpdCgnLicpWzBdLCAxMCk7XG5cblx0XHRzd2l0Y2ggKGVudi5URVJNX1BST0dSQU0pIHtcblx0XHRcdGNhc2UgJ2lUZXJtLmFwcCc6XG5cdFx0XHRcdHJldHVybiB2ZXJzaW9uID49IDMgPyAzIDogMjtcblx0XHRcdGNhc2UgJ0FwcGxlX1Rlcm1pbmFsJzpcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHQvLyBObyBkZWZhdWx0XG5cdFx0fVxuXHR9XG5cblx0aWYgKC8tMjU2KGNvbG9yKT8kL2kudGVzdChlbnYuVEVSTSkpIHtcblx0XHRyZXR1cm4gMjtcblx0fVxuXG5cdGlmICgvXnNjcmVlbnxeeHRlcm18XnZ0MTAwfF52dDIyMHxecnh2dHxjb2xvcnxhbnNpfGN5Z3dpbnxsaW51eC9pLnRlc3QoZW52LlRFUk0pKSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRpZiAoJ0NPTE9SVEVSTScgaW4gZW52KSB7XG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRyZXR1cm4gbWluO1xufVxuXG5mdW5jdGlvbiBnZXRTdXBwb3J0TGV2ZWwoc3RyZWFtKSB7XG5cdGNvbnN0IGxldmVsID0gc3VwcG9ydHNDb2xvcihzdHJlYW0sIHN0cmVhbSAmJiBzdHJlYW0uaXNUVFkpO1xuXHRyZXR1cm4gdHJhbnNsYXRlTGV2ZWwobGV2ZWwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0c3VwcG9ydHNDb2xvcjogZ2V0U3VwcG9ydExldmVsLFxuXHRzdGRvdXQ6IHRyYW5zbGF0ZUxldmVsKHN1cHBvcnRzQ29sb3IodHJ1ZSwgdHR5LmlzYXR0eSgxKSkpLFxuXHRzdGRlcnI6IHRyYW5zbGF0ZUxldmVsKHN1cHBvcnRzQ29sb3IodHJ1ZSwgdHR5LmlzYXR0eSgyKSkpXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///31\n")},function(module,exports){eval('module.exports = require("os");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJvc1wiP2I3MTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJvc1wiKTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///32\n')},function(module,exports){eval('module.exports = require("tty");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJ0dHlcIj9hN2NiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjMzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidHR5XCIpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///33\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = (flag, argv = process.argv) => {\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst position = argv.indexOf(prefix + flag);\n\tconst terminatorPosition = argv.indexOf('--');\n\treturn position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3VwcG9ydHMtY29sb3Ivbm9kZV9tb2R1bGVzL2hhcy1mbGFnL2luZGV4LmpzP2ZhY2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjM0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmbGFnLCBhcmd2ID0gcHJvY2Vzcy5hcmd2KSA9PiB7XG5cdGNvbnN0IHByZWZpeCA9IGZsYWcuc3RhcnRzV2l0aCgnLScpID8gJycgOiAoZmxhZy5sZW5ndGggPT09IDEgPyAnLScgOiAnLS0nKTtcblx0Y29uc3QgcG9zaXRpb24gPSBhcmd2LmluZGV4T2YocHJlZml4ICsgZmxhZyk7XG5cdGNvbnN0IHRlcm1pbmF0b3JQb3NpdGlvbiA9IGFyZ3YuaW5kZXhPZignLS0nKTtcblx0cmV0dXJuIHBvc2l0aW9uICE9PSAtMSAmJiAodGVybWluYXRvclBvc2l0aW9uID09PSAtMSB8fCBwb3NpdGlvbiA8IHRlcm1pbmF0b3JQb3NpdGlvbik7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///34\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nconst stringReplaceAll = (string, substring, replacer) => {\n\tlet index = string.indexOf(substring);\n\tif (index === -1) {\n\t\treturn string;\n\t}\n\n\tconst substringLength = substring.length;\n\tlet endIndex = 0;\n\tlet returnValue = '';\n\tdo {\n\t\treturnValue += string.substr(endIndex, index - endIndex) + substring + replacer;\n\t\tendIndex = index + substringLength;\n\t\tindex = string.indexOf(substring, endIndex);\n\t} while (index !== -1);\n\n\treturnValue += string.substr(endIndex);\n\treturn returnValue;\n};\n\nconst stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {\n\tlet endIndex = 0;\n\tlet returnValue = '';\n\tdo {\n\t\tconst gotCR = string[index - 1] === '\\r';\n\t\treturnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? '\\r\\n' : '\\n') + postfix;\n\t\tendIndex = index + 1;\n\t\tindex = string.indexOf('\\n', endIndex);\n\t} while (index !== -1);\n\n\treturnValue += string.substr(endIndex);\n\treturn returnValue;\n};\n\nmodule.exports = {\n\tstringReplaceAll,\n\tstringEncaseCRLFWithFirstIndex\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hhbGsvc291cmNlL3V0aWwuanM/YWVmOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjM1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBzdHJpbmdSZXBsYWNlQWxsID0gKHN0cmluZywgc3Vic3RyaW5nLCByZXBsYWNlcikgPT4ge1xuXHRsZXQgaW5kZXggPSBzdHJpbmcuaW5kZXhPZihzdWJzdHJpbmcpO1xuXHRpZiAoaW5kZXggPT09IC0xKSB7XG5cdFx0cmV0dXJuIHN0cmluZztcblx0fVxuXG5cdGNvbnN0IHN1YnN0cmluZ0xlbmd0aCA9IHN1YnN0cmluZy5sZW5ndGg7XG5cdGxldCBlbmRJbmRleCA9IDA7XG5cdGxldCByZXR1cm5WYWx1ZSA9ICcnO1xuXHRkbyB7XG5cdFx0cmV0dXJuVmFsdWUgKz0gc3RyaW5nLnN1YnN0cihlbmRJbmRleCwgaW5kZXggLSBlbmRJbmRleCkgKyBzdWJzdHJpbmcgKyByZXBsYWNlcjtcblx0XHRlbmRJbmRleCA9IGluZGV4ICsgc3Vic3RyaW5nTGVuZ3RoO1xuXHRcdGluZGV4ID0gc3RyaW5nLmluZGV4T2Yoc3Vic3RyaW5nLCBlbmRJbmRleCk7XG5cdH0gd2hpbGUgKGluZGV4ICE9PSAtMSk7XG5cblx0cmV0dXJuVmFsdWUgKz0gc3RyaW5nLnN1YnN0cihlbmRJbmRleCk7XG5cdHJldHVybiByZXR1cm5WYWx1ZTtcbn07XG5cbmNvbnN0IHN0cmluZ0VuY2FzZUNSTEZXaXRoRmlyc3RJbmRleCA9IChzdHJpbmcsIHByZWZpeCwgcG9zdGZpeCwgaW5kZXgpID0+IHtcblx0bGV0IGVuZEluZGV4ID0gMDtcblx0bGV0IHJldHVyblZhbHVlID0gJyc7XG5cdGRvIHtcblx0XHRjb25zdCBnb3RDUiA9IHN0cmluZ1tpbmRleCAtIDFdID09PSAnXFxyJztcblx0XHRyZXR1cm5WYWx1ZSArPSBzdHJpbmcuc3Vic3RyKGVuZEluZGV4LCAoZ290Q1IgPyBpbmRleCAtIDEgOiBpbmRleCkgLSBlbmRJbmRleCkgKyBwcmVmaXggKyAoZ290Q1IgPyAnXFxyXFxuJyA6ICdcXG4nKSArIHBvc3RmaXg7XG5cdFx0ZW5kSW5kZXggPSBpbmRleCArIDE7XG5cdFx0aW5kZXggPSBzdHJpbmcuaW5kZXhPZignXFxuJywgZW5kSW5kZXgpO1xuXHR9IHdoaWxlIChpbmRleCAhPT0gLTEpO1xuXG5cdHJldHVyblZhbHVlICs9IHN0cmluZy5zdWJzdHIoZW5kSW5kZXgpO1xuXHRyZXR1cm4gcmV0dXJuVmFsdWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0c3RyaW5nUmVwbGFjZUFsbCxcblx0c3RyaW5nRW5jYXNlQ1JMRldpdGhGaXJzdEluZGV4XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///35\n")},function(module,exports,__webpack_require__){"use strict";eval("\nconst TEMPLATE_REGEX = /(?:\\\\(u(?:[a-f\\d]{4}|\\{[a-f\\d]{1,6}\\})|x[a-f\\d]{2}|.))|(?:\\{(~)?(\\w+(?:\\([^)]*\\))?(?:\\.\\w+(?:\\([^)]*\\))?)*)(?:[ \\t]|(?=\\r?\\n)))|(\\})|((?:.|[\\r\\n\\f])+?)/gi;\nconst STYLE_REGEX = /(?:^|\\.)(\\w+)(?:\\(([^)]*)\\))?/g;\nconst STRING_REGEX = /^(['\"])((?:\\\\.|(?!\\1)[^\\\\])*)\\1$/;\nconst ESCAPE_REGEX = /\\\\(u(?:[a-f\\d]{4}|{[a-f\\d]{1,6}})|x[a-f\\d]{2}|.)|([^\\\\])/gi;\n\nconst ESCAPES = new Map([\n\t['n', '\\n'],\n\t['r', '\\r'],\n\t['t', '\\t'],\n\t['b', '\\b'],\n\t['f', '\\f'],\n\t['v', '\\v'],\n\t['0', '\\0'],\n\t['\\\\', '\\\\'],\n\t['e', '\\u001B'],\n\t['a', '\\u0007']\n]);\n\nfunction unescape(c) {\n\tconst u = c[0] === 'u';\n\tconst bracket = c[1] === '{';\n\n\tif ((u && !bracket && c.length === 5) || (c[0] === 'x' && c.length === 3)) {\n\t\treturn String.fromCharCode(parseInt(c.slice(1), 16));\n\t}\n\n\tif (u && bracket) {\n\t\treturn String.fromCodePoint(parseInt(c.slice(2, -1), 16));\n\t}\n\n\treturn ESCAPES.get(c) || c;\n}\n\nfunction parseArguments(name, arguments_) {\n\tconst results = [];\n\tconst chunks = arguments_.trim().split(/\\s*,\\s*/g);\n\tlet matches;\n\n\tfor (const chunk of chunks) {\n\t\tconst number = Number(chunk);\n\t\tif (!Number.isNaN(number)) {\n\t\t\tresults.push(number);\n\t\t} else if ((matches = chunk.match(STRING_REGEX))) {\n\t\t\tresults.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape(escape) : character));\n\t\t} else {\n\t\t\tthrow new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction parseStyle(style) {\n\tSTYLE_REGEX.lastIndex = 0;\n\n\tconst results = [];\n\tlet matches;\n\n\twhile ((matches = STYLE_REGEX.exec(style)) !== null) {\n\t\tconst name = matches[1];\n\n\t\tif (matches[2]) {\n\t\t\tconst args = parseArguments(name, matches[2]);\n\t\t\tresults.push([name].concat(args));\n\t\t} else {\n\t\t\tresults.push([name]);\n\t\t}\n\t}\n\n\treturn results;\n}\n\nfunction buildStyle(chalk, styles) {\n\tconst enabled = {};\n\n\tfor (const layer of styles) {\n\t\tfor (const style of layer.styles) {\n\t\t\tenabled[style[0]] = layer.inverse ? null : style.slice(1);\n\t\t}\n\t}\n\n\tlet current = chalk;\n\tfor (const [styleName, styles] of Object.entries(enabled)) {\n\t\tif (!Array.isArray(styles)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(styleName in current)) {\n\t\t\tthrow new Error(`Unknown Chalk style: ${styleName}`);\n\t\t}\n\n\t\tcurrent = styles.length > 0 ? current[styleName](...styles) : current[styleName];\n\t}\n\n\treturn current;\n}\n\nmodule.exports = (chalk, temporary) => {\n\tconst styles = [];\n\tconst chunks = [];\n\tlet chunk = [];\n\n\t// eslint-disable-next-line max-params\n\ttemporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {\n\t\tif (escapeCharacter) {\n\t\t\tchunk.push(unescape(escapeCharacter));\n\t\t} else if (style) {\n\t\t\tconst string = chunk.join('');\n\t\t\tchunk = [];\n\t\t\tchunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));\n\t\t\tstyles.push({inverse, styles: parseStyle(style)});\n\t\t} else if (close) {\n\t\t\tif (styles.length === 0) {\n\t\t\t\tthrow new Error('Found extraneous } in Chalk template literal');\n\t\t\t}\n\n\t\t\tchunks.push(buildStyle(chalk, styles)(chunk.join('')));\n\t\t\tchunk = [];\n\t\t\tstyles.pop();\n\t\t} else {\n\t\t\tchunk.push(character);\n\t\t}\n\t});\n\n\tchunks.push(chunk.join(''));\n\n\tif (styles.length > 0) {\n\t\tconst errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? '' : 's'} (\\`}\\`)`;\n\t\tthrow new Error(errMessage);\n\t}\n\n\treturn chunks.join('');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2hhbGsvc291cmNlL3RlbXBsYXRlcy5qcz9hOGRhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsMENBQTBDLEVBQUUsR0FBRyxRQUFRLElBQUksRUFBRSxXQUFXLEVBQUUsVUFBVSx1RUFBdUU7QUFDM0o7QUFDQTtBQUNBLHFDQUFxQyxFQUFFLEVBQUUsUUFBUSxLQUFLLFdBQVcsRUFBRTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCw2REFBNkQsTUFBTSxjQUFjLEtBQUs7QUFDdEY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUNBQW1DO0FBQ25ELEdBQUc7QUFDSDtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQSwwREFBMEQsY0FBYyxrQkFBa0IsK0JBQStCLEtBQUs7QUFDOUg7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjM2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgVEVNUExBVEVfUkVHRVggPSAvKD86XFxcXCh1KD86W2EtZlxcZF17NH18XFx7W2EtZlxcZF17MSw2fVxcfSl8eFthLWZcXGRdezJ9fC4pKXwoPzpcXHsofik/KFxcdysoPzpcXChbXildKlxcKSk/KD86XFwuXFx3Kyg/OlxcKFteKV0qXFwpKT8pKikoPzpbIFxcdF18KD89XFxyP1xcbikpKXwoXFx9KXwoKD86LnxbXFxyXFxuXFxmXSkrPykvZ2k7XG5jb25zdCBTVFlMRV9SRUdFWCA9IC8oPzpefFxcLikoXFx3KykoPzpcXCgoW14pXSopXFwpKT8vZztcbmNvbnN0IFNUUklOR19SRUdFWCA9IC9eKFsnXCJdKSgoPzpcXFxcLnwoPyFcXDEpW15cXFxcXSkqKVxcMSQvO1xuY29uc3QgRVNDQVBFX1JFR0VYID0gL1xcXFwodSg/OlthLWZcXGRdezR9fHtbYS1mXFxkXXsxLDZ9fSl8eFthLWZcXGRdezJ9fC4pfChbXlxcXFxdKS9naTtcblxuY29uc3QgRVNDQVBFUyA9IG5ldyBNYXAoW1xuXHRbJ24nLCAnXFxuJ10sXG5cdFsncicsICdcXHInXSxcblx0Wyd0JywgJ1xcdCddLFxuXHRbJ2InLCAnXFxiJ10sXG5cdFsnZicsICdcXGYnXSxcblx0Wyd2JywgJ1xcdiddLFxuXHRbJzAnLCAnXFwwJ10sXG5cdFsnXFxcXCcsICdcXFxcJ10sXG5cdFsnZScsICdcXHUwMDFCJ10sXG5cdFsnYScsICdcXHUwMDA3J11cbl0pO1xuXG5mdW5jdGlvbiB1bmVzY2FwZShjKSB7XG5cdGNvbnN0IHUgPSBjWzBdID09PSAndSc7XG5cdGNvbnN0IGJyYWNrZXQgPSBjWzFdID09PSAneyc7XG5cblx0aWYgKCh1ICYmICFicmFja2V0ICYmIGMubGVuZ3RoID09PSA1KSB8fCAoY1swXSA9PT0gJ3gnICYmIGMubGVuZ3RoID09PSAzKSkge1xuXHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGMuc2xpY2UoMSksIDE2KSk7XG5cdH1cblxuXHRpZiAodSAmJiBicmFja2V0KSB7XG5cdFx0cmV0dXJuIFN0cmluZy5mcm9tQ29kZVBvaW50KHBhcnNlSW50KGMuc2xpY2UoMiwgLTEpLCAxNikpO1xuXHR9XG5cblx0cmV0dXJuIEVTQ0FQRVMuZ2V0KGMpIHx8IGM7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKG5hbWUsIGFyZ3VtZW50c18pIHtcblx0Y29uc3QgcmVzdWx0cyA9IFtdO1xuXHRjb25zdCBjaHVua3MgPSBhcmd1bWVudHNfLnRyaW0oKS5zcGxpdCgvXFxzKixcXHMqL2cpO1xuXHRsZXQgbWF0Y2hlcztcblxuXHRmb3IgKGNvbnN0IGNodW5rIG9mIGNodW5rcykge1xuXHRcdGNvbnN0IG51bWJlciA9IE51bWJlcihjaHVuayk7XG5cdFx0aWYgKCFOdW1iZXIuaXNOYU4obnVtYmVyKSkge1xuXHRcdFx0cmVzdWx0cy5wdXNoKG51bWJlcik7XG5cdFx0fSBlbHNlIGlmICgobWF0Y2hlcyA9IGNodW5rLm1hdGNoKFNUUklOR19SRUdFWCkpKSB7XG5cdFx0XHRyZXN1bHRzLnB1c2gobWF0Y2hlc1syXS5yZXBsYWNlKEVTQ0FQRV9SRUdFWCwgKG0sIGVzY2FwZSwgY2hhcmFjdGVyKSA9PiBlc2NhcGUgPyB1bmVzY2FwZShlc2NhcGUpIDogY2hhcmFjdGVyKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBDaGFsayB0ZW1wbGF0ZSBzdHlsZSBhcmd1bWVudDogJHtjaHVua30gKGluIHN0eWxlICcke25hbWV9JylgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gcGFyc2VTdHlsZShzdHlsZSkge1xuXHRTVFlMRV9SRUdFWC5sYXN0SW5kZXggPSAwO1xuXG5cdGNvbnN0IHJlc3VsdHMgPSBbXTtcblx0bGV0IG1hdGNoZXM7XG5cblx0d2hpbGUgKChtYXRjaGVzID0gU1RZTEVfUkVHRVguZXhlYyhzdHlsZSkpICE9PSBudWxsKSB7XG5cdFx0Y29uc3QgbmFtZSA9IG1hdGNoZXNbMV07XG5cblx0XHRpZiAobWF0Y2hlc1syXSkge1xuXHRcdFx0Y29uc3QgYXJncyA9IHBhcnNlQXJndW1lbnRzKG5hbWUsIG1hdGNoZXNbMl0pO1xuXHRcdFx0cmVzdWx0cy5wdXNoKFtuYW1lXS5jb25jYXQoYXJncykpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXN1bHRzLnB1c2goW25hbWVdKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gYnVpbGRTdHlsZShjaGFsaywgc3R5bGVzKSB7XG5cdGNvbnN0IGVuYWJsZWQgPSB7fTtcblxuXHRmb3IgKGNvbnN0IGxheWVyIG9mIHN0eWxlcykge1xuXHRcdGZvciAoY29uc3Qgc3R5bGUgb2YgbGF5ZXIuc3R5bGVzKSB7XG5cdFx0XHRlbmFibGVkW3N0eWxlWzBdXSA9IGxheWVyLmludmVyc2UgPyBudWxsIDogc3R5bGUuc2xpY2UoMSk7XG5cdFx0fVxuXHR9XG5cblx0bGV0IGN1cnJlbnQgPSBjaGFsaztcblx0Zm9yIChjb25zdCBbc3R5bGVOYW1lLCBzdHlsZXNdIG9mIE9iamVjdC5lbnRyaWVzKGVuYWJsZWQpKSB7XG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KHN0eWxlcykpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmICghKHN0eWxlTmFtZSBpbiBjdXJyZW50KSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIENoYWxrIHN0eWxlOiAke3N0eWxlTmFtZX1gKTtcblx0XHR9XG5cblx0XHRjdXJyZW50ID0gc3R5bGVzLmxlbmd0aCA+IDAgPyBjdXJyZW50W3N0eWxlTmFtZV0oLi4uc3R5bGVzKSA6IGN1cnJlbnRbc3R5bGVOYW1lXTtcblx0fVxuXG5cdHJldHVybiBjdXJyZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChjaGFsaywgdGVtcG9yYXJ5KSA9PiB7XG5cdGNvbnN0IHN0eWxlcyA9IFtdO1xuXHRjb25zdCBjaHVua3MgPSBbXTtcblx0bGV0IGNodW5rID0gW107XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1wYXJhbXNcblx0dGVtcG9yYXJ5LnJlcGxhY2UoVEVNUExBVEVfUkVHRVgsIChtLCBlc2NhcGVDaGFyYWN0ZXIsIGludmVyc2UsIHN0eWxlLCBjbG9zZSwgY2hhcmFjdGVyKSA9PiB7XG5cdFx0aWYgKGVzY2FwZUNoYXJhY3Rlcikge1xuXHRcdFx0Y2h1bmsucHVzaCh1bmVzY2FwZShlc2NhcGVDaGFyYWN0ZXIpKTtcblx0XHR9IGVsc2UgaWYgKHN0eWxlKSB7XG5cdFx0XHRjb25zdCBzdHJpbmcgPSBjaHVuay5qb2luKCcnKTtcblx0XHRcdGNodW5rID0gW107XG5cdFx0XHRjaHVua3MucHVzaChzdHlsZXMubGVuZ3RoID09PSAwID8gc3RyaW5nIDogYnVpbGRTdHlsZShjaGFsaywgc3R5bGVzKShzdHJpbmcpKTtcblx0XHRcdHN0eWxlcy5wdXNoKHtpbnZlcnNlLCBzdHlsZXM6IHBhcnNlU3R5bGUoc3R5bGUpfSk7XG5cdFx0fSBlbHNlIGlmIChjbG9zZSkge1xuXHRcdFx0aWYgKHN0eWxlcy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdGb3VuZCBleHRyYW5lb3VzIH0gaW4gQ2hhbGsgdGVtcGxhdGUgbGl0ZXJhbCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRjaHVua3MucHVzaChidWlsZFN0eWxlKGNoYWxrLCBzdHlsZXMpKGNodW5rLmpvaW4oJycpKSk7XG5cdFx0XHRjaHVuayA9IFtdO1xuXHRcdFx0c3R5bGVzLnBvcCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaHVuay5wdXNoKGNoYXJhY3Rlcik7XG5cdFx0fVxuXHR9KTtcblxuXHRjaHVua3MucHVzaChjaHVuay5qb2luKCcnKSk7XG5cblx0aWYgKHN0eWxlcy5sZW5ndGggPiAwKSB7XG5cdFx0Y29uc3QgZXJyTWVzc2FnZSA9IGBDaGFsayB0ZW1wbGF0ZSBsaXRlcmFsIGlzIG1pc3NpbmcgJHtzdHlsZXMubGVuZ3RofSBjbG9zaW5nIGJyYWNrZXQke3N0eWxlcy5sZW5ndGggPT09IDEgPyAnJyA6ICdzJ30gKFxcYH1cXGApYDtcblx0XHR0aHJvdyBuZXcgRXJyb3IoZXJyTWVzc2FnZSk7XG5cdH1cblxuXHRyZXR1cm4gY2h1bmtzLmpvaW4oJycpO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///36\n")},function(module,exports,__webpack_require__){"use strict";eval("\nconst restoreCursor = __webpack_require__(38);\n\nlet isHidden = false;\n\nexports.show = (writableStream = process.stderr) => {\n\tif (!writableStream.isTTY) {\n\t\treturn;\n\t}\n\n\tisHidden = false;\n\twritableStream.write('\\u001B[?25h');\n};\n\nexports.hide = (writableStream = process.stderr) => {\n\tif (!writableStream.isTTY) {\n\t\treturn;\n\t}\n\n\trestoreCursor();\n\tisHidden = true;\n\twritableStream.write('\\u001B[?25l');\n};\n\nexports.toggle = (force, writableStream) => {\n\tif (force !== undefined) {\n\t\tisHidden = force;\n\t}\n\n\tif (isHidden) {\n\t\texports.show(writableStream);\n\t} else {\n\t\texports.hide(writableStream);\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xpLWN1cnNvci9pbmRleC5qcz9lMDViIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2Isc0JBQXNCLG1CQUFPLENBQUMsRUFBZ0I7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSIsImZpbGUiOiIzNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IHJlc3RvcmVDdXJzb3IgPSByZXF1aXJlKCdyZXN0b3JlLWN1cnNvcicpO1xuXG5sZXQgaXNIaWRkZW4gPSBmYWxzZTtcblxuZXhwb3J0cy5zaG93ID0gKHdyaXRhYmxlU3RyZWFtID0gcHJvY2Vzcy5zdGRlcnIpID0+IHtcblx0aWYgKCF3cml0YWJsZVN0cmVhbS5pc1RUWSkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGlzSGlkZGVuID0gZmFsc2U7XG5cdHdyaXRhYmxlU3RyZWFtLndyaXRlKCdcXHUwMDFCWz8yNWgnKTtcbn07XG5cbmV4cG9ydHMuaGlkZSA9ICh3cml0YWJsZVN0cmVhbSA9IHByb2Nlc3Muc3RkZXJyKSA9PiB7XG5cdGlmICghd3JpdGFibGVTdHJlYW0uaXNUVFkpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRyZXN0b3JlQ3Vyc29yKCk7XG5cdGlzSGlkZGVuID0gdHJ1ZTtcblx0d3JpdGFibGVTdHJlYW0ud3JpdGUoJ1xcdTAwMUJbPzI1bCcpO1xufTtcblxuZXhwb3J0cy50b2dnbGUgPSAoZm9yY2UsIHdyaXRhYmxlU3RyZWFtKSA9PiB7XG5cdGlmIChmb3JjZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0aXNIaWRkZW4gPSBmb3JjZTtcblx0fVxuXG5cdGlmIChpc0hpZGRlbikge1xuXHRcdGV4cG9ydHMuc2hvdyh3cml0YWJsZVN0cmVhbSk7XG5cdH0gZWxzZSB7XG5cdFx0ZXhwb3J0cy5oaWRlKHdyaXRhYmxlU3RyZWFtKTtcblx0fVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///37\n")},function(module,exports,__webpack_require__){"use strict";eval("\nconst onetime = __webpack_require__(39);\nconst signalExit = __webpack_require__(41);\n\nmodule.exports = onetime(() => {\n\tsignalExit(() => {\n\t\tprocess.stderr.write('\\u001B[?25h');\n\t}, {alwaysLast: true});\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVzdG9yZS1jdXJzb3IvaW5kZXguanM/NDI3OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGdCQUFnQixtQkFBTyxDQUFDLEVBQVM7QUFDakMsbUJBQW1CLG1CQUFPLENBQUMsRUFBYTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0EsRUFBRSxHQUFHLGlCQUFpQjtBQUN0QixDQUFDIiwiZmlsZSI6IjM4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3Qgb25ldGltZSA9IHJlcXVpcmUoJ29uZXRpbWUnKTtcbmNvbnN0IHNpZ25hbEV4aXQgPSByZXF1aXJlKCdzaWduYWwtZXhpdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9uZXRpbWUoKCkgPT4ge1xuXHRzaWduYWxFeGl0KCgpID0+IHtcblx0XHRwcm9jZXNzLnN0ZGVyci53cml0ZSgnXFx1MDAxQls/MjVoJyk7XG5cdH0sIHthbHdheXNMYXN0OiB0cnVlfSk7XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///38\n")},function(module,exports,__webpack_require__){"use strict";eval("\nconst mimicFn = __webpack_require__(40);\n\nconst calledFunctions = new WeakMap();\n\nconst onetime = (function_, options = {}) => {\n\tif (typeof function_ !== 'function') {\n\t\tthrow new TypeError('Expected a function');\n\t}\n\n\tlet returnValue;\n\tlet callCount = 0;\n\tconst functionName = function_.displayName || function_.name || '<anonymous>';\n\n\tconst onetime = function (...arguments_) {\n\t\tcalledFunctions.set(onetime, ++callCount);\n\n\t\tif (callCount === 1) {\n\t\t\treturnValue = function_.apply(this, arguments_);\n\t\t\tfunction_ = null;\n\t\t} else if (options.throw === true) {\n\t\t\tthrow new Error(`Function \\`${functionName}\\` can only be called once`);\n\t\t}\n\n\t\treturn returnValue;\n\t};\n\n\tmimicFn(onetime, function_);\n\tcalledFunctions.set(onetime, callCount);\n\n\treturn onetime;\n};\n\nmodule.exports = onetime;\n// TODO: Remove this for the next major release\nmodule.exports.default = onetime;\n\nmodule.exports.callCount = function_ => {\n\tif (!calledFunctions.has(function_)) {\n\t\tthrow new Error(`The given function \\`${function_.name}\\` is not wrapped by the \\`onetime\\` package`);\n\t}\n\n\treturn calledFunctions.get(function_);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb25ldGltZS9pbmRleC5qcz8zZDQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsZ0JBQWdCLG1CQUFPLENBQUMsRUFBVTs7QUFFbEM7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsaUNBQWlDLGFBQWE7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsZUFBZTtBQUN6RDs7QUFFQTtBQUNBIiwiZmlsZSI6IjM5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgbWltaWNGbiA9IHJlcXVpcmUoJ21pbWljLWZuJyk7XG5cbmNvbnN0IGNhbGxlZEZ1bmN0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG5cbmNvbnN0IG9uZXRpbWUgPSAoZnVuY3Rpb25fLCBvcHRpb25zID0ge30pID0+IHtcblx0aWYgKHR5cGVvZiBmdW5jdGlvbl8gIT09ICdmdW5jdGlvbicpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBhIGZ1bmN0aW9uJyk7XG5cdH1cblxuXHRsZXQgcmV0dXJuVmFsdWU7XG5cdGxldCBjYWxsQ291bnQgPSAwO1xuXHRjb25zdCBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbl8uZGlzcGxheU5hbWUgfHwgZnVuY3Rpb25fLm5hbWUgfHwgJzxhbm9ueW1vdXM+JztcblxuXHRjb25zdCBvbmV0aW1lID0gZnVuY3Rpb24gKC4uLmFyZ3VtZW50c18pIHtcblx0XHRjYWxsZWRGdW5jdGlvbnMuc2V0KG9uZXRpbWUsICsrY2FsbENvdW50KTtcblxuXHRcdGlmIChjYWxsQ291bnQgPT09IDEpIHtcblx0XHRcdHJldHVyblZhbHVlID0gZnVuY3Rpb25fLmFwcGx5KHRoaXMsIGFyZ3VtZW50c18pO1xuXHRcdFx0ZnVuY3Rpb25fID0gbnVsbDtcblx0XHR9IGVsc2UgaWYgKG9wdGlvbnMudGhyb3cgPT09IHRydWUpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihgRnVuY3Rpb24gXFxgJHtmdW5jdGlvbk5hbWV9XFxgIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlYCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldHVyblZhbHVlO1xuXHR9O1xuXG5cdG1pbWljRm4ob25ldGltZSwgZnVuY3Rpb25fKTtcblx0Y2FsbGVkRnVuY3Rpb25zLnNldChvbmV0aW1lLCBjYWxsQ291bnQpO1xuXG5cdHJldHVybiBvbmV0aW1lO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBvbmV0aW1lO1xuLy8gVE9ETzogUmVtb3ZlIHRoaXMgZm9yIHRoZSBuZXh0IG1ham9yIHJlbGVhc2Vcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBvbmV0aW1lO1xuXG5tb2R1bGUuZXhwb3J0cy5jYWxsQ291bnQgPSBmdW5jdGlvbl8gPT4ge1xuXHRpZiAoIWNhbGxlZEZ1bmN0aW9ucy5oYXMoZnVuY3Rpb25fKSkge1xuXHRcdHRocm93IG5ldyBFcnJvcihgVGhlIGdpdmVuIGZ1bmN0aW9uIFxcYCR7ZnVuY3Rpb25fLm5hbWV9XFxgIGlzIG5vdCB3cmFwcGVkIGJ5IHRoZSBcXGBvbmV0aW1lXFxgIHBhY2thZ2VgKTtcblx0fVxuXG5cdHJldHVybiBjYWxsZWRGdW5jdGlvbnMuZ2V0KGZ1bmN0aW9uXyk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///39\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nconst mimicFn = (to, from) => {\n\tfor (const prop of Reflect.ownKeys(from)) {\n\t\tObject.defineProperty(to, prop, Object.getOwnPropertyDescriptor(from, prop));\n\t}\n\n\treturn to;\n};\n\nmodule.exports = mimicFn;\n// TODO: Remove this for the next major release\nmodule.exports.default = mimicFn;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWltaWMtZm4vaW5kZXguanM/OTU2OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiI0MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgbWltaWNGbiA9ICh0bywgZnJvbSkgPT4ge1xuXHRmb3IgKGNvbnN0IHByb3Agb2YgUmVmbGVjdC5vd25LZXlzKGZyb20pKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRvLCBwcm9wLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGZyb20sIHByb3ApKTtcblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWltaWNGbjtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbWltaWNGbjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///40\n")},function(module,exports,__webpack_require__){eval("// Note: since nyc uses this module to output coverage, any lines\n// that are in the direct sync flow of nyc's outputCoverage are\n// ignored, since we can never get coverage for them.\nvar assert = __webpack_require__(18)\nvar signals = __webpack_require__(42)\nvar isWin = /^win/i.test(process.platform)\n\nvar EE = __webpack_require__(8)\n/* istanbul ignore if */\nif (typeof EE !== 'function') {\n  EE = EE.EventEmitter\n}\n\nvar emitter\nif (process.__signal_exit_emitter__) {\n  emitter = process.__signal_exit_emitter__\n} else {\n  emitter = process.__signal_exit_emitter__ = new EE()\n  emitter.count = 0\n  emitter.emitted = {}\n}\n\n// Because this emitter is a global, we have to check to see if a\n// previous version of this library failed to enable infinite listeners.\n// I know what you're about to say.  But literally everything about\n// signal-exit is a compromise with evil.  Get used to it.\nif (!emitter.infinite) {\n  emitter.setMaxListeners(Infinity)\n  emitter.infinite = true\n}\n\nmodule.exports = function (cb, opts) {\n  assert.equal(typeof cb, 'function', 'a callback must be provided for exit handler')\n\n  if (loaded === false) {\n    load()\n  }\n\n  var ev = 'exit'\n  if (opts && opts.alwaysLast) {\n    ev = 'afterexit'\n  }\n\n  var remove = function () {\n    emitter.removeListener(ev, cb)\n    if (emitter.listeners('exit').length === 0 &&\n        emitter.listeners('afterexit').length === 0) {\n      unload()\n    }\n  }\n  emitter.on(ev, cb)\n\n  return remove\n}\n\nmodule.exports.unload = unload\nfunction unload () {\n  if (!loaded) {\n    return\n  }\n  loaded = false\n\n  signals.forEach(function (sig) {\n    try {\n      process.removeListener(sig, sigListeners[sig])\n    } catch (er) {}\n  })\n  process.emit = originalProcessEmit\n  process.reallyExit = originalProcessReallyExit\n  emitter.count -= 1\n}\n\nfunction emit (event, code, signal) {\n  if (emitter.emitted[event]) {\n    return\n  }\n  emitter.emitted[event] = true\n  emitter.emit(event, code, signal)\n}\n\n// { <signal>: <listener fn>, ... }\nvar sigListeners = {}\nsignals.forEach(function (sig) {\n  sigListeners[sig] = function listener () {\n    // If there are no other listeners, an exit is coming!\n    // Simplest way: remove us and then re-send the signal.\n    // We know that this will kill the process, so we can\n    // safely emit now.\n    var listeners = process.listeners(sig)\n    if (listeners.length === emitter.count) {\n      unload()\n      emit('exit', null, sig)\n      /* istanbul ignore next */\n      emit('afterexit', null, sig)\n      /* istanbul ignore next */\n      if (isWin && sig === 'SIGHUP') {\n        // \"SIGHUP\" throws an `ENOSYS` error on Windows,\n        // so use a supported signal instead\n        sig = 'SIGINT'\n      }\n      process.kill(process.pid, sig)\n    }\n  }\n})\n\nmodule.exports.signals = function () {\n  return signals\n}\n\nmodule.exports.load = load\n\nvar loaded = false\n\nfunction load () {\n  if (loaded) {\n    return\n  }\n  loaded = true\n\n  // This is the number of onSignalExit's that are in play.\n  // It's important so that we can count the correct number of\n  // listeners on signals, and don't wait for the other one to\n  // handle it instead of us.\n  emitter.count += 1\n\n  signals = signals.filter(function (sig) {\n    try {\n      process.on(sig, sigListeners[sig])\n      return true\n    } catch (er) {\n      return false\n    }\n  })\n\n  process.emit = processEmit\n  process.reallyExit = processReallyExit\n}\n\nvar originalProcessReallyExit = process.reallyExit\nfunction processReallyExit (code) {\n  process.exitCode = code || 0\n  emit('exit', process.exitCode, null)\n  /* istanbul ignore next */\n  emit('afterexit', process.exitCode, null)\n  /* istanbul ignore next */\n  originalProcessReallyExit.call(process, process.exitCode)\n}\n\nvar originalProcessEmit = process.emit\nfunction processEmit (ev, arg) {\n  if (ev === 'exit') {\n    if (arg !== undefined) {\n      process.exitCode = arg\n    }\n    var ret = originalProcessEmit.apply(this, arguments)\n    emit('exit', process.exitCode, null)\n    /* istanbul ignore next */\n    emit('afterexit', process.exitCode, null)\n    return ret\n  } else {\n    return originalProcessEmit.apply(this, arguments)\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2lnbmFsLWV4aXQvaW5kZXguanM/NmVlMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsRUFBUTtBQUM3QixjQUFjLG1CQUFPLENBQUMsRUFBYztBQUNwQzs7QUFFQSxTQUFTLG1CQUFPLENBQUMsQ0FBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBOb3RlOiBzaW5jZSBueWMgdXNlcyB0aGlzIG1vZHVsZSB0byBvdXRwdXQgY292ZXJhZ2UsIGFueSBsaW5lc1xuLy8gdGhhdCBhcmUgaW4gdGhlIGRpcmVjdCBzeW5jIGZsb3cgb2YgbnljJ3Mgb3V0cHV0Q292ZXJhZ2UgYXJlXG4vLyBpZ25vcmVkLCBzaW5jZSB3ZSBjYW4gbmV2ZXIgZ2V0IGNvdmVyYWdlIGZvciB0aGVtLlxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG52YXIgc2lnbmFscyA9IHJlcXVpcmUoJy4vc2lnbmFscy5qcycpXG52YXIgaXNXaW4gPSAvXndpbi9pLnRlc3QocHJvY2Vzcy5wbGF0Zm9ybSlcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJylcbi8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuaWYgKHR5cGVvZiBFRSAhPT0gJ2Z1bmN0aW9uJykge1xuICBFRSA9IEVFLkV2ZW50RW1pdHRlclxufVxuXG52YXIgZW1pdHRlclxuaWYgKHByb2Nlc3MuX19zaWduYWxfZXhpdF9lbWl0dGVyX18pIHtcbiAgZW1pdHRlciA9IHByb2Nlc3MuX19zaWduYWxfZXhpdF9lbWl0dGVyX19cbn0gZWxzZSB7XG4gIGVtaXR0ZXIgPSBwcm9jZXNzLl9fc2lnbmFsX2V4aXRfZW1pdHRlcl9fID0gbmV3IEVFKClcbiAgZW1pdHRlci5jb3VudCA9IDBcbiAgZW1pdHRlci5lbWl0dGVkID0ge31cbn1cblxuLy8gQmVjYXVzZSB0aGlzIGVtaXR0ZXIgaXMgYSBnbG9iYWwsIHdlIGhhdmUgdG8gY2hlY2sgdG8gc2VlIGlmIGFcbi8vIHByZXZpb3VzIHZlcnNpb24gb2YgdGhpcyBsaWJyYXJ5IGZhaWxlZCB0byBlbmFibGUgaW5maW5pdGUgbGlzdGVuZXJzLlxuLy8gSSBrbm93IHdoYXQgeW91J3JlIGFib3V0IHRvIHNheS4gIEJ1dCBsaXRlcmFsbHkgZXZlcnl0aGluZyBhYm91dFxuLy8gc2lnbmFsLWV4aXQgaXMgYSBjb21wcm9taXNlIHdpdGggZXZpbC4gIEdldCB1c2VkIHRvIGl0LlxuaWYgKCFlbWl0dGVyLmluZmluaXRlKSB7XG4gIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKEluZmluaXR5KVxuICBlbWl0dGVyLmluZmluaXRlID0gdHJ1ZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjYiwgb3B0cykge1xuICBhc3NlcnQuZXF1YWwodHlwZW9mIGNiLCAnZnVuY3Rpb24nLCAnYSBjYWxsYmFjayBtdXN0IGJlIHByb3ZpZGVkIGZvciBleGl0IGhhbmRsZXInKVxuXG4gIGlmIChsb2FkZWQgPT09IGZhbHNlKSB7XG4gICAgbG9hZCgpXG4gIH1cblxuICB2YXIgZXYgPSAnZXhpdCdcbiAgaWYgKG9wdHMgJiYgb3B0cy5hbHdheXNMYXN0KSB7XG4gICAgZXYgPSAnYWZ0ZXJleGl0J1xuICB9XG5cbiAgdmFyIHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKGV2LCBjYilcbiAgICBpZiAoZW1pdHRlci5saXN0ZW5lcnMoJ2V4aXQnKS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgZW1pdHRlci5saXN0ZW5lcnMoJ2FmdGVyZXhpdCcpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdW5sb2FkKClcbiAgICB9XG4gIH1cbiAgZW1pdHRlci5vbihldiwgY2IpXG5cbiAgcmV0dXJuIHJlbW92ZVxufVxuXG5tb2R1bGUuZXhwb3J0cy51bmxvYWQgPSB1bmxvYWRcbmZ1bmN0aW9uIHVubG9hZCAoKSB7XG4gIGlmICghbG9hZGVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgbG9hZGVkID0gZmFsc2VcblxuICBzaWduYWxzLmZvckVhY2goZnVuY3Rpb24gKHNpZykge1xuICAgIHRyeSB7XG4gICAgICBwcm9jZXNzLnJlbW92ZUxpc3RlbmVyKHNpZywgc2lnTGlzdGVuZXJzW3NpZ10pXG4gICAgfSBjYXRjaCAoZXIpIHt9XG4gIH0pXG4gIHByb2Nlc3MuZW1pdCA9IG9yaWdpbmFsUHJvY2Vzc0VtaXRcbiAgcHJvY2Vzcy5yZWFsbHlFeGl0ID0gb3JpZ2luYWxQcm9jZXNzUmVhbGx5RXhpdFxuICBlbWl0dGVyLmNvdW50IC09IDFcbn1cblxuZnVuY3Rpb24gZW1pdCAoZXZlbnQsIGNvZGUsIHNpZ25hbCkge1xuICBpZiAoZW1pdHRlci5lbWl0dGVkW2V2ZW50XSkge1xuICAgIHJldHVyblxuICB9XG4gIGVtaXR0ZXIuZW1pdHRlZFtldmVudF0gPSB0cnVlXG4gIGVtaXR0ZXIuZW1pdChldmVudCwgY29kZSwgc2lnbmFsKVxufVxuXG4vLyB7IDxzaWduYWw+OiA8bGlzdGVuZXIgZm4+LCAuLi4gfVxudmFyIHNpZ0xpc3RlbmVycyA9IHt9XG5zaWduYWxzLmZvckVhY2goZnVuY3Rpb24gKHNpZykge1xuICBzaWdMaXN0ZW5lcnNbc2lnXSA9IGZ1bmN0aW9uIGxpc3RlbmVyICgpIHtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gb3RoZXIgbGlzdGVuZXJzLCBhbiBleGl0IGlzIGNvbWluZyFcbiAgICAvLyBTaW1wbGVzdCB3YXk6IHJlbW92ZSB1cyBhbmQgdGhlbiByZS1zZW5kIHRoZSBzaWduYWwuXG4gICAgLy8gV2Uga25vdyB0aGF0IHRoaXMgd2lsbCBraWxsIHRoZSBwcm9jZXNzLCBzbyB3ZSBjYW5cbiAgICAvLyBzYWZlbHkgZW1pdCBub3cuXG4gICAgdmFyIGxpc3RlbmVycyA9IHByb2Nlc3MubGlzdGVuZXJzKHNpZylcbiAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gZW1pdHRlci5jb3VudCkge1xuICAgICAgdW5sb2FkKClcbiAgICAgIGVtaXQoJ2V4aXQnLCBudWxsLCBzaWcpXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgZW1pdCgnYWZ0ZXJleGl0JywgbnVsbCwgc2lnKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGlmIChpc1dpbiAmJiBzaWcgPT09ICdTSUdIVVAnKSB7XG4gICAgICAgIC8vIFwiU0lHSFVQXCIgdGhyb3dzIGFuIGBFTk9TWVNgIGVycm9yIG9uIFdpbmRvd3MsXG4gICAgICAgIC8vIHNvIHVzZSBhIHN1cHBvcnRlZCBzaWduYWwgaW5zdGVhZFxuICAgICAgICBzaWcgPSAnU0lHSU5UJ1xuICAgICAgfVxuICAgICAgcHJvY2Vzcy5raWxsKHByb2Nlc3MucGlkLCBzaWcpXG4gICAgfVxuICB9XG59KVxuXG5tb2R1bGUuZXhwb3J0cy5zaWduYWxzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gc2lnbmFsc1xufVxuXG5tb2R1bGUuZXhwb3J0cy5sb2FkID0gbG9hZFxuXG52YXIgbG9hZGVkID0gZmFsc2VcblxuZnVuY3Rpb24gbG9hZCAoKSB7XG4gIGlmIChsb2FkZWQpIHtcbiAgICByZXR1cm5cbiAgfVxuICBsb2FkZWQgPSB0cnVlXG5cbiAgLy8gVGhpcyBpcyB0aGUgbnVtYmVyIG9mIG9uU2lnbmFsRXhpdCdzIHRoYXQgYXJlIGluIHBsYXkuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHNvIHRoYXQgd2UgY2FuIGNvdW50IHRoZSBjb3JyZWN0IG51bWJlciBvZlxuICAvLyBsaXN0ZW5lcnMgb24gc2lnbmFscywgYW5kIGRvbid0IHdhaXQgZm9yIHRoZSBvdGhlciBvbmUgdG9cbiAgLy8gaGFuZGxlIGl0IGluc3RlYWQgb2YgdXMuXG4gIGVtaXR0ZXIuY291bnQgKz0gMVxuXG4gIHNpZ25hbHMgPSBzaWduYWxzLmZpbHRlcihmdW5jdGlvbiAoc2lnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHByb2Nlc3Mub24oc2lnLCBzaWdMaXN0ZW5lcnNbc2lnXSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSlcblxuICBwcm9jZXNzLmVtaXQgPSBwcm9jZXNzRW1pdFxuICBwcm9jZXNzLnJlYWxseUV4aXQgPSBwcm9jZXNzUmVhbGx5RXhpdFxufVxuXG52YXIgb3JpZ2luYWxQcm9jZXNzUmVhbGx5RXhpdCA9IHByb2Nlc3MucmVhbGx5RXhpdFxuZnVuY3Rpb24gcHJvY2Vzc1JlYWxseUV4aXQgKGNvZGUpIHtcbiAgcHJvY2Vzcy5leGl0Q29kZSA9IGNvZGUgfHwgMFxuICBlbWl0KCdleGl0JywgcHJvY2Vzcy5leGl0Q29kZSwgbnVsbClcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZW1pdCgnYWZ0ZXJleGl0JywgcHJvY2Vzcy5leGl0Q29kZSwgbnVsbClcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgb3JpZ2luYWxQcm9jZXNzUmVhbGx5RXhpdC5jYWxsKHByb2Nlc3MsIHByb2Nlc3MuZXhpdENvZGUpXG59XG5cbnZhciBvcmlnaW5hbFByb2Nlc3NFbWl0ID0gcHJvY2Vzcy5lbWl0XG5mdW5jdGlvbiBwcm9jZXNzRW1pdCAoZXYsIGFyZykge1xuICBpZiAoZXYgPT09ICdleGl0Jykge1xuICAgIGlmIChhcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcHJvY2Vzcy5leGl0Q29kZSA9IGFyZ1xuICAgIH1cbiAgICB2YXIgcmV0ID0gb3JpZ2luYWxQcm9jZXNzRW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgZW1pdCgnZXhpdCcsIHByb2Nlc3MuZXhpdENvZGUsIG51bGwpXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBlbWl0KCdhZnRlcmV4aXQnLCBwcm9jZXNzLmV4aXRDb2RlLCBudWxsKVxuICAgIHJldHVybiByZXRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb3JpZ2luYWxQcm9jZXNzRW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///41\n")},function(module,exports){eval("// This is not the set of all possible signals.\n//\n// It IS, however, the set of all signals that trigger\n// an exit on either Linux or BSD systems.  Linux is a\n// superset of the signal names supported on BSD, and\n// the unknown signals just fail to register, so we can\n// catch that easily enough.\n//\n// Don't bother with SIGKILL.  It's uncatchable, which\n// means that we can't fire any callbacks anyway.\n//\n// If a user does happen to register a handler on a non-\n// fatal signal like SIGWINCH or something, and then\n// exit, it'll end up firing `process.emit('exit')`, so\n// the handler will be fired anyway.\n//\n// SIGBUS, SIGFPE, SIGSEGV and SIGILL, when not raised\n// artificially, inherently leave the process in a\n// state from which it is not safe to try and enter JS\n// listeners.\nmodule.exports = [\n  'SIGABRT',\n  'SIGALRM',\n  'SIGHUP',\n  'SIGINT',\n  'SIGTERM'\n]\n\nif (process.platform !== 'win32') {\n  module.exports.push(\n    'SIGVTALRM',\n    'SIGXCPU',\n    'SIGXFSZ',\n    'SIGUSR2',\n    'SIGTRAP',\n    'SIGSYS',\n    'SIGQUIT',\n    'SIGIOT'\n    // should detect profiler and enable/disable accordingly.\n    // see #21\n    // 'SIGPROF'\n  )\n}\n\nif (process.platform === 'linux') {\n  module.exports.push(\n    'SIGIO',\n    'SIGPOLL',\n    'SIGPWR',\n    'SIGSTKFLT',\n    'SIGUNUSED'\n  )\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2lnbmFsLWV4aXQvc2lnbmFscy5qcz9jN2VmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjQyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBpcyBub3QgdGhlIHNldCBvZiBhbGwgcG9zc2libGUgc2lnbmFscy5cbi8vXG4vLyBJdCBJUywgaG93ZXZlciwgdGhlIHNldCBvZiBhbGwgc2lnbmFscyB0aGF0IHRyaWdnZXJcbi8vIGFuIGV4aXQgb24gZWl0aGVyIExpbnV4IG9yIEJTRCBzeXN0ZW1zLiAgTGludXggaXMgYVxuLy8gc3VwZXJzZXQgb2YgdGhlIHNpZ25hbCBuYW1lcyBzdXBwb3J0ZWQgb24gQlNELCBhbmRcbi8vIHRoZSB1bmtub3duIHNpZ25hbHMganVzdCBmYWlsIHRvIHJlZ2lzdGVyLCBzbyB3ZSBjYW5cbi8vIGNhdGNoIHRoYXQgZWFzaWx5IGVub3VnaC5cbi8vXG4vLyBEb24ndCBib3RoZXIgd2l0aCBTSUdLSUxMLiAgSXQncyB1bmNhdGNoYWJsZSwgd2hpY2hcbi8vIG1lYW5zIHRoYXQgd2UgY2FuJ3QgZmlyZSBhbnkgY2FsbGJhY2tzIGFueXdheS5cbi8vXG4vLyBJZiBhIHVzZXIgZG9lcyBoYXBwZW4gdG8gcmVnaXN0ZXIgYSBoYW5kbGVyIG9uIGEgbm9uLVxuLy8gZmF0YWwgc2lnbmFsIGxpa2UgU0lHV0lOQ0ggb3Igc29tZXRoaW5nLCBhbmQgdGhlblxuLy8gZXhpdCwgaXQnbGwgZW5kIHVwIGZpcmluZyBgcHJvY2Vzcy5lbWl0KCdleGl0JylgLCBzb1xuLy8gdGhlIGhhbmRsZXIgd2lsbCBiZSBmaXJlZCBhbnl3YXkuXG4vL1xuLy8gU0lHQlVTLCBTSUdGUEUsIFNJR1NFR1YgYW5kIFNJR0lMTCwgd2hlbiBub3QgcmFpc2VkXG4vLyBhcnRpZmljaWFsbHksIGluaGVyZW50bHkgbGVhdmUgdGhlIHByb2Nlc3MgaW4gYVxuLy8gc3RhdGUgZnJvbSB3aGljaCBpdCBpcyBub3Qgc2FmZSB0byB0cnkgYW5kIGVudGVyIEpTXG4vLyBsaXN0ZW5lcnMuXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ1NJR0FCUlQnLFxuICAnU0lHQUxSTScsXG4gICdTSUdIVVAnLFxuICAnU0lHSU5UJyxcbiAgJ1NJR1RFUk0nXG5dXG5cbmlmIChwcm9jZXNzLnBsYXRmb3JtICE9PSAnd2luMzInKSB7XG4gIG1vZHVsZS5leHBvcnRzLnB1c2goXG4gICAgJ1NJR1ZUQUxSTScsXG4gICAgJ1NJR1hDUFUnLFxuICAgICdTSUdYRlNaJyxcbiAgICAnU0lHVVNSMicsXG4gICAgJ1NJR1RSQVAnLFxuICAgICdTSUdTWVMnLFxuICAgICdTSUdRVUlUJyxcbiAgICAnU0lHSU9UJ1xuICAgIC8vIHNob3VsZCBkZXRlY3QgcHJvZmlsZXIgYW5kIGVuYWJsZS9kaXNhYmxlIGFjY29yZGluZ2x5LlxuICAgIC8vIHNlZSAjMjFcbiAgICAvLyAnU0lHUFJPRidcbiAgKVxufVxuXG5pZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ2xpbnV4Jykge1xuICBtb2R1bGUuZXhwb3J0cy5wdXNoKFxuICAgICdTSUdJTycsXG4gICAgJ1NJR1BPTEwnLFxuICAgICdTSUdQV1InLFxuICAgICdTSUdTVEtGTFQnLFxuICAgICdTSUdVTlVTRUQnXG4gIClcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///42\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = ({onlyFirst = false} = {}) => {\n\tconst pattern = [\n\t\t'[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n\t\t'(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'\n\t].join('|');\n\n\treturn new RegExp(pattern, onlyFirst ? undefined : 'g');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcz85ZWVlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLG1CQUFtQixrQkFBa0IsS0FBSztBQUMxQztBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQsYUFBYSxJQUFJLElBQUksSUFBSSxJQUFJO0FBQzdCOztBQUVBO0FBQ0EiLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gKHtvbmx5Rmlyc3QgPSBmYWxzZX0gPSB7fSkgPT4ge1xuXHRjb25zdCBwYXR0ZXJuID0gW1xuXHRcdCdbXFxcXHUwMDFCXFxcXHUwMDlCXVtbXFxcXF0oKSM7P10qKD86KD86KD86W2EtekEtWlxcXFxkXSooPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10qKSopP1xcXFx1MDAwNyknLFxuXHRcdCcoPzooPzpcXFxcZHsxLDR9KD86O1xcXFxkezAsNH0pKik/W1xcXFxkQS1QUi1UWmNmLW50cXJ5PT48fl0pKSdcblx0XS5qb2luKCd8Jyk7XG5cblx0cmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgb25seUZpcnN0ID8gdW5kZWZpbmVkIDogJ2cnKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///43\n")},function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.InputEvents = void 0;\nvar events_1 = __webpack_require__(8);\nvar BUILTIN_KEYSTROKES = [\n    ["keydown", Buffer.from([0x1b, 0x5b, 0x42])],\n    ["keyup", Buffer.from([0x1b, 0x5b, 0x41])],\n    ["keyright", Buffer.from([0x1b, 0x5b, 0x43])],\n    ["keyleft", Buffer.from([0x1b, 0x5b, 0x44])],\n    ["space", Buffer.from([0x20])],\n    ["enter", Buffer.from([0x0d])],\n    ["backspace", Buffer.from([0x7f])],\n    ["escape", Buffer.from([0x1b])],\n    ["tab", Buffer.from([0x09])],\n    ["ctrl+d", Buffer.from([0x04])],\n    ["ctrl+z", Buffer.from([0x1a])],\n];\nvar ctrlZBuffer = Buffer.from([0x3]);\n/**\n * Instance of this class will emit a `KEYPRESS` event on each user input\n * `SIGINT` event will be called when user clicks ctrl+c\n */\nvar InputEvents = /** @class */ (function (_super) {\n    __extends(InputEvents, _super);\n    function InputEvents() {\n        var _this = _super.call(this) || this;\n        // set raw mode on stdin to register each keypress\n        process.stdin.setRawMode(true);\n        // listen for ctrl+c (SIGINT event is not fired\n        // on the process object when raw mode is set on stdin)\n        process.stdin.on("data", function (chunk) {\n            if (chunk.equals(ctrlZBuffer)) {\n                _this.emit("SIGINT");\n                return;\n            }\n            _this.emit("KEYPRESS", {\n                name: _this.checkKeystroke(chunk),\n                pressed: chunk.toString(),\n            });\n        });\n        return _this;\n    }\n    InputEvents.prototype.on = function (event, listener) {\n        return _super.prototype.on.call(this, event, listener);\n    };\n    /**\n     * Checks if user clicked some of the BuiltInKeystrokes\n     * as defined in BUILTIN_KEYSTROKES\n     * @param buf\n     */\n    InputEvents.prototype.checkKeystroke = function (buf) {\n        for (var _i = 0, BUILTIN_KEYSTROKES_1 = BUILTIN_KEYSTROKES; _i < BUILTIN_KEYSTROKES_1.length; _i++) {\n            var _a = BUILTIN_KEYSTROKES_1[_i], name_1 = _a[0], buffer = _a[1];\n            if (buf.equals(buffer))\n                return name_1;\n        }\n        return undefined;\n    };\n    return InputEvents;\n}(events_1.EventEmitter));\nexports.InputEvents = InputEvents;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvSW5wdXRFdmVudHMvaW5kZXgudHM/Mjg1MSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsc0NBQXNDO0FBZ0N0QyxJQUFNLGtCQUFrQixHQUFrQztJQUN4RCxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzVDLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDMUMsQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUM3QyxDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzVDLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzlCLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzlCLENBQUMsV0FBVyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ2xDLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQy9CLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzVCLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQy9CLENBQUMsUUFBUSxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0NBQ2hDLENBQUM7QUFFRixJQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUV2Qzs7O0dBR0c7QUFDSDtJQUFpQywrQkFBWTtJQUMzQztRQUFBLFlBQ0UsaUJBQU8sU0FpQlI7UUFmQyxrREFBa0Q7UUFDbEQsT0FBTyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7UUFFL0IsK0NBQStDO1FBQy9DLHVEQUF1RDtRQUN2RCxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsVUFBQyxLQUFLO1lBQzdCLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsRUFBRTtnQkFDN0IsS0FBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDcEIsT0FBTzthQUNSO1lBQ0QsS0FBSSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ3BCLElBQUksRUFBRSxLQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQztnQkFDaEMsT0FBTyxFQUFFLEtBQUssQ0FBQyxRQUFRLEVBQUU7YUFDMUIsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7O0lBQ0wsQ0FBQztJQUlELHdCQUFFLEdBQUYsVUFBRyxLQUFhLEVBQUUsUUFBa0M7UUFDbEQsT0FBTyxpQkFBTSxFQUFFLFlBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ25DLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssb0NBQWMsR0FBdEIsVUFBdUIsR0FBVztRQUNoQyxLQUE2QixVQUFrQixFQUFsQix5Q0FBa0IsRUFBbEIsZ0NBQWtCLEVBQWxCLElBQWtCO1lBQXBDLGlDQUFjLEVBQWIsTUFBSSxVQUFFLE1BQU07WUFDdEIsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztnQkFBRSxPQUFPLE1BQUksQ0FBQztTQUFBO1FBQ3RDLE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFDSCxrQkFBQztBQUFELENBQUMsQ0FyQ2dDLHFCQUFZLEdBcUM1QztBQXJDWSxrQ0FBVyIsImZpbGUiOiI0NC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gXCJldmVudHNcIjtcblxuLyoqXG4gKiBOb3QgaWRlYWwuLi4gSnVzdCBuZWVkIHRvIGZpZ3VyZSBvdXQgaG93IHRvIG1ha2VcbiAqIHNvbWV0aGluZyBsaWtlIGBCdWlsdEluS2V5c3Ryb2tlcyB8IHN0cmluZ2Agc2hvd1xuICogYWN0dWFsbHkgdGhlIGJ1aWx0IGluIG5hbWVzLi4uXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgS2V5UHJlc3Mge1xuICBuYW1lPzogQnVpbHRJbktleXN0cm9rZXM7XG4gIHByZXNzZWQ6IHN0cmluZztcbn1cblxuZXhwb3J0IHR5cGUgS2V5UHJlc3NFdmVudExpc3RlbmVyID0gKGtleVByZXNzOiBLZXlQcmVzcykgPT4gdm9pZDtcblxuZXhwb3J0IGludGVyZmFjZSBJbnB1dEV2ZW50c0ludGVyZmFjZSB7XG4gIG9uKGV2ZW50OiBcIlNJR0lOVFwiLCBsaXN0ZW5lcjogKCkgPT4gdm9pZCk6IHRoaXM7XG4gIG9uKGV2ZW50OiBcIktFWVBSRVNTXCIsIGxpc3RlbmVyOiBLZXlQcmVzc0V2ZW50TGlzdGVuZXIpOiB0aGlzO1xufVxuXG5leHBvcnQgdHlwZSBCdWlsdEluS2V5c3Ryb2tlcyA9XG4gIHwgXCJrZXl1cFwiXG4gIHwgXCJrZXlkb3duXCJcbiAgfCBcImtleXJpZ2h0XCJcbiAgfCBcImtleWxlZnRcIlxuICB8IFwic3BhY2VcIlxuICB8IFwiZW50ZXJcIlxuICB8IFwiYmFja3NwYWNlXCJcbiAgfCBcImVzY2FwZVwiXG4gIHwgXCJ0YWJcIlxuICB8IFwiY3RybCtkXCJcbiAgfCBcImN0cmwrelwiO1xuXG5jb25zdCBCVUlMVElOX0tFWVNUUk9LRVM6IFtCdWlsdEluS2V5c3Ryb2tlcywgQnVmZmVyXVtdID0gW1xuICBbXCJrZXlkb3duXCIsIEJ1ZmZlci5mcm9tKFsweDFiLCAweDViLCAweDQyXSldLFxuICBbXCJrZXl1cFwiLCBCdWZmZXIuZnJvbShbMHgxYiwgMHg1YiwgMHg0MV0pXSxcbiAgW1wia2V5cmlnaHRcIiwgQnVmZmVyLmZyb20oWzB4MWIsIDB4NWIsIDB4NDNdKV0sXG4gIFtcImtleWxlZnRcIiwgQnVmZmVyLmZyb20oWzB4MWIsIDB4NWIsIDB4NDRdKV0sXG4gIFtcInNwYWNlXCIsIEJ1ZmZlci5mcm9tKFsweDIwXSldLFxuICBbXCJlbnRlclwiLCBCdWZmZXIuZnJvbShbMHgwZF0pXSxcbiAgW1wiYmFja3NwYWNlXCIsIEJ1ZmZlci5mcm9tKFsweDdmXSldLFxuICBbXCJlc2NhcGVcIiwgQnVmZmVyLmZyb20oWzB4MWJdKV0sXG4gIFtcInRhYlwiLCBCdWZmZXIuZnJvbShbMHgwOV0pXSxcbiAgW1wiY3RybCtkXCIsIEJ1ZmZlci5mcm9tKFsweDA0XSldLFxuICBbXCJjdHJsK3pcIiwgQnVmZmVyLmZyb20oWzB4MWFdKV0sXG5dO1xuXG5jb25zdCBjdHJsWkJ1ZmZlciA9IEJ1ZmZlci5mcm9tKFsweDNdKTtcblxuLyoqXG4gKiBJbnN0YW5jZSBvZiB0aGlzIGNsYXNzIHdpbGwgZW1pdCBhIGBLRVlQUkVTU2AgZXZlbnQgb24gZWFjaCB1c2VyIGlucHV0XG4gKiBgU0lHSU5UYCBldmVudCB3aWxsIGJlIGNhbGxlZCB3aGVuIHVzZXIgY2xpY2tzIGN0cmwrY1xuICovXG5leHBvcnQgY2xhc3MgSW5wdXRFdmVudHMgZXh0ZW5kcyBFdmVudEVtaXR0ZXIgaW1wbGVtZW50cyBJbnB1dEV2ZW50c0ludGVyZmFjZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvLyBzZXQgcmF3IG1vZGUgb24gc3RkaW4gdG8gcmVnaXN0ZXIgZWFjaCBrZXlwcmVzc1xuICAgIHByb2Nlc3Muc3RkaW4uc2V0UmF3TW9kZSh0cnVlKTtcblxuICAgIC8vIGxpc3RlbiBmb3IgY3RybCtjIChTSUdJTlQgZXZlbnQgaXMgbm90IGZpcmVkXG4gICAgLy8gb24gdGhlIHByb2Nlc3Mgb2JqZWN0IHdoZW4gcmF3IG1vZGUgaXMgc2V0IG9uIHN0ZGluKVxuICAgIHByb2Nlc3Muc3RkaW4ub24oXCJkYXRhXCIsIChjaHVuaykgPT4ge1xuICAgICAgaWYgKGNodW5rLmVxdWFscyhjdHJsWkJ1ZmZlcikpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwiU0lHSU5UXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoXCJLRVlQUkVTU1wiLCB7XG4gICAgICAgIG5hbWU6IHRoaXMuY2hlY2tLZXlzdHJva2UoY2h1bmspLFxuICAgICAgICBwcmVzc2VkOiBjaHVuay50b1N0cmluZygpLFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBvbihldmVudDogXCJTSUdJTlRcIiwgbGlzdGVuZXI6ICgpID0+IHZvaWQpOiB0aGlzO1xuICBvbihldmVudDogXCJLRVlQUkVTU1wiLCBsaXN0ZW5lcjogS2V5UHJlc3NFdmVudExpc3RlbmVyKTogdGhpcztcbiAgb24oZXZlbnQ6IHN0cmluZywgbGlzdGVuZXI6ICguLi5hcmdzOiBhbnlbXSkgPT4gdm9pZCk6IHRoaXMge1xuICAgIHJldHVybiBzdXBlci5vbihldmVudCwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB1c2VyIGNsaWNrZWQgc29tZSBvZiB0aGUgQnVpbHRJbktleXN0cm9rZXNcbiAgICogYXMgZGVmaW5lZCBpbiBCVUlMVElOX0tFWVNUUk9LRVNcbiAgICogQHBhcmFtIGJ1ZlxuICAgKi9cbiAgcHJpdmF0ZSBjaGVja0tleXN0cm9rZShidWY6IEJ1ZmZlcik6IEJ1aWx0SW5LZXlzdHJva2VzIHwgdm9pZCB7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgYnVmZmVyXSBvZiBCVUlMVElOX0tFWVNUUk9LRVMpXG4gICAgICBpZiAoYnVmLmVxdWFscyhidWZmZXIpKSByZXR1cm4gbmFtZTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///44\n')},function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.Snake = void 0;\nvar chalk_1 = __importDefault(__webpack_require__(15));\nvar humanize_duration_1 = __importDefault(__webpack_require__(46));\nvar AbstractGame_1 = __webpack_require__(47);\nvar colors_1 = __webpack_require__(9);\n/**\n * Get a random int\n * @param min integer\n * @param max integer (not inclusive)\n */\nvar getRandomInt = function (min, max) {\n    return Math.floor(Math.random() * (max - min)) + min;\n};\nvar Snake = /** @class */ (function (_super) {\n    __extends(Snake, _super);\n    function Snake(screenWriter, inputEvents, opts) {\n        if (opts === void 0) { opts = {}; }\n        var _this = _super.call(this, screenWriter, inputEvents) || this;\n        _this.screenContent = [];\n        /** array of row arrays */\n        _this.board = [];\n        /** console columns */\n        _this.columns = 0;\n        _this.customColumns = false;\n        /** console rows */\n        _this.rows = 0;\n        _this.customRows = false;\n        /** start of the game */\n        _this.startTime = Date.now();\n        _this.endScreenBgColor = "red";\n        _this.endScreenColor = "white";\n        /** number of eaten fruits */\n        _this.fruitsEaten = 0;\n        /** current direction of the snake */\n        _this.dir = "right";\n        _this.phase = "init";\n        // Elements to be positioned on the board\n        _this.snakeHead = [1, 1];\n        _this.snakeBody = [];\n        _this.fruitPosition = [0, 0];\n        /** array of all possible position tuples... MEMORY WASTE */\n        _this.fieldsAvailabe = [];\n        /** store last setTimeout call */\n        _this.currTimeout = setTimeout(function () { }, 0);\n        _this.updateInterval = opts.updateInterval || 100;\n        _this.snakeHeadColor = opts.snakeHeadColor || "red";\n        _this.snakeBodyColor = opts.snakeBodyColor || "blue";\n        _this.emptyColor = opts.emptyColor || "black";\n        _this.fruitColor = opts.fruitColor || "green";\n        _this.fillChar = opts.fillChar || " ";\n        if (opts.columns) {\n            _this.columns = opts.columns;\n            _this.customColumns = true;\n        }\n        if (opts.rows) {\n            _this.rows = opts.rows;\n            _this.customColumns = true;\n        }\n        // whole setup wrapped in another function to easily restart\n        _this.init();\n        return _this;\n    }\n    //================================================================\n    //======================= INITIAL SETUP ==========================\n    //================================================================\n    /** initial setup of the game */\n    Snake.prototype.init = function () {\n        this.phase = "init";\n        // set some starting values\n        this.setStartingValues();\n        // check the size of the terminal\n        this.setBoardSize();\n        // SO INEFFICIENT... THIS SHOULD BE CHANGED\n        // we\'re storing all possible position tuples\n        // so it would be to pick available position for the fruit...\n        for (var row = 0; row < this.rows; row++)\n            for (var column = 0; column < this.columns; column++)\n                this.fieldsAvailabe.push([row, column]);\n        // place first fruit\n        this.placeFruit();\n        // record starting time of the game\n        this.startTime = Date.now();\n        // start the loop\n        this.phase = "game";\n        this.start();\n    };\n    Snake.prototype.setBoardSize = function () {\n        this.columns = this.customColumns\n            ? this.columns\n            : this.screenWriter.columns;\n        this.rows = this.customRows ? this.rows : this.screenWriter.rows;\n    };\n    Snake.prototype.onKeyPress = function (keyPress) {\n        switch (this.phase) {\n            case "init":\n                return;\n            case "game":\n                this.handleGameInput(keyPress);\n                return;\n            case "end":\n                this.handleEndScreenInput(keyPress);\n                return;\n        }\n    };\n    Snake.prototype.handleGameInput = function (_a) {\n        var name = _a.name, pressed = _a.pressed;\n        if (name === "keyup" || pressed === "w") {\n            this.updateDir("up");\n            return;\n        }\n        if (name === "keydown" || pressed === "s") {\n            this.updateDir("down");\n            return;\n        }\n        if (name === "keyright" || pressed === "d") {\n            this.updateDir("right");\n            return;\n        }\n        if (name === "keyleft" || pressed === "a") {\n            this.updateDir("left");\n            return;\n        }\n    };\n    Snake.prototype.handleEndScreenInput = function (_a) {\n        var pressed = _a.pressed;\n        if (pressed === "r") {\n            this.reset();\n            return;\n        }\n        if (pressed === "q") {\n            this.screenWriter.clearScreen();\n            process.exit(0);\n        }\n    };\n    Snake.prototype.onSIGINT = function () {\n        this.screenWriter.clearScreen();\n        process.exit(1);\n    };\n    Snake.prototype.onScreenResize = function () {\n        this.reset();\n    };\n    /** All default, non-option values should go here  */\n    Snake.prototype.setStartingValues = function () {\n        this.dir = "right";\n        this.snakeHead = [1, 1];\n        this.snakeBody = [];\n        this.fruitsEaten = 0;\n        this.screenContent = [];\n        clearTimeout(this.currTimeout);\n    };\n    /** Function that is called on each refresh of the game */\n    Snake.prototype.start = function () {\n        var _this = this;\n        // first let\'s update snake\'s postion\n        this.updateSnakePosition();\n        // next update snake and fruit position on the board\n        this.updateBoard();\n        // if the game has actually ended, stop here\n        if (this.phase !== "game")\n            return;\n        // print/update the board\n        this.print();\n        // schedule next refresh of the game\n        this.currTimeout = setTimeout(function () { return _this.start(); }, this.updateInterval);\n    };\n    Snake.prototype.reset = function () {\n        this.init();\n    };\n    Snake.prototype.createEmptyBoard = function () {\n        var _this = this;\n        this.board = Array(this.rows)\n            .fill(null)\n            .map(function () { return Array(_this.columns).fill(_this.emptyColor); });\n    };\n    //================================================================\n    //========================= GAME OVER ============================\n    //================================================================\n    Snake.prototype.gameOver = function () {\n        var _this = this;\n        // this will stop setting another setTimeout\n        this.phase = "end";\n        // get chalk function to color the text\n        var color = chalk_1.default[colors_1.getForegroundColor(this.endScreenColor)][colors_1.getBackgroundColor(this.endScreenBgColor)];\n        // end screen messages\n        var messages = [\n            // score\n            "Your score: " + this.fruitsEaten,\n            // play time\n            "Play time: " + humanize_duration_1.default(Date.now() - this.startTime),\n            // user options\n            \'Press "r" to play again or "q" to exit.\',\n        ].map(function (line) {\n            return color(_this.screenWriter.centerString(line, _this.columns, _this.fillChar));\n        });\n        // how many lines should be below and above the end screen messages\n        // so they are centered vertically\n        var emptyLinesCount = (this.rows - messages.length) / 2;\n        // filler, empty line\n        var emptyLine = color(this.fillChar.repeat(this.columns));\n        this.screenContent = __spreadArrays(Array(Math.floor(emptyLinesCount)).fill(emptyLine), messages, Array(Math.ceil(emptyLinesCount)).fill(emptyLine));\n        this.print();\n    };\n    //================================================================\n    //===================== UPDATE FUNCTIONS =========================\n    //================================================================\n    /**\n     * Updates snake\'s direction\n     * @param dir\n     */\n    Snake.prototype.updateDir = function (dir) {\n        switch (dir) {\n            case "up":\n                if (this.dir === "down")\n                    return;\n                this.dir = dir;\n                break;\n            case "down":\n                if (this.dir === "up")\n                    return;\n                this.dir = dir;\n                break;\n            case "right":\n                if (this.dir === "left")\n                    return;\n                this.dir = dir;\n                break;\n            case "left":\n                if (this.dir === "right")\n                    return;\n                this.dir = dir;\n                break;\n        }\n    };\n    /** function to update positions of all elements on the board */\n    Snake.prototype.updateBoard = function () {\n        var _a;\n        // first we create an empty board\n        // not sure if it\'s the best approach\n        this.createEmptyBoard();\n        // update fruit position\n        var _b = this.fruitPosition, row = _b[0], col = _b[1];\n        this.board[row][col] = this.fruitColor;\n        // update snake head position\n        _a = this.snakeHead, row = _a[0], col = _a[1];\n        this.board[row][col] = this.snakeHeadColor;\n        // update snake body position\n        for (var _i = 0, _c = this.snakeBody; _i < _c.length; _i++) {\n            var _d = _c[_i], row_1 = _d[0], col_1 = _d[1];\n            this.board[row_1][col_1] = this.snakeBodyColor;\n        }\n        this.updateScreenContent();\n    };\n    /** INEFFICIENT */\n    Snake.prototype.placeFruit = function () {\n        var _this = this;\n        // a lot of overhead\n        // first filter an array of all possible positions on the board\n        var snake = __spreadArrays([this.snakeHead], this.snakeBody);\n        var available = this.fieldsAvailabe.filter(function (pos) {\n            for (var _i = 0, snake_1 = snake; _i < snake_1.length; _i++) {\n                var bodyPart = snake_1[_i];\n                if (_this.checkColision(pos, bodyPart))\n                    return false;\n            }\n            return true;\n        });\n        // if no positions available, end the game\n        if (available.length === 0) {\n            this.gameOver();\n            return;\n        }\n        // pick random position for the fruit\n        this.fruitPosition = available[getRandomInt(0, available.length)];\n    };\n    /** helper function to check if two positions are the same */\n    Snake.prototype.checkColision = function (pos1, pos2) {\n        if (pos1[0] === pos2[0] && pos1[1] === pos2[1])\n            return true;\n        return false;\n    };\n    /** helper function to check if snake\'s head collide with any body part */\n    Snake.prototype.checkSnakeBodyColision = function () {\n        for (var _i = 0, _a = this.snakeBody; _i < _a.length; _i++) {\n            var bodyPart = _a[_i];\n            if (this.checkColision(this.snakeHead, bodyPart))\n                this.gameOver();\n        }\n    };\n    /** function to update the whole snake\'s position */\n    Snake.prototype.updateSnakePosition = function () {\n        this.updateBodyPosition();\n        this.updateHeadPosition();\n        this.checkSnakeBodyColision();\n    };\n    /** function to update snake\'s head position */\n    Snake.prototype.updateHeadPosition = function () {\n        var _a = this.snakeHead, row = _a[0], col = _a[1];\n        switch (this.dir) {\n            case "up":\n                row--;\n                break;\n            case "down":\n                row++;\n                break;\n            case "right":\n                col++;\n                break;\n            case "left":\n                col--;\n                break;\n        }\n        // check if out of bounds\n        if (col >= this.columns || col < 0 || row >= this.rows || row < 0) {\n            this.gameOver();\n            return;\n        }\n        this.snakeHead = [row, col];\n    };\n    /** function to update snake\'s body position */\n    Snake.prototype.updateBodyPosition = function () {\n        if (this.checkColision(this.snakeHead, this.fruitPosition)) {\n            this.fruitsEaten++;\n            this.snakeBody = __spreadArrays([this.snakeHead], this.snakeBody);\n            this.placeFruit();\n            return;\n        }\n        if (this.snakeBody.length === 0)\n            return;\n        this.snakeBody = __spreadArrays([\n            this.snakeHead\n        ], this.snakeBody.slice(0, this.snakeBody.length - 1));\n    };\n    /** Updates screenContent based on the content of the board */\n    Snake.prototype.updateScreenContent = function () {\n        var _this = this;\n        this.screenContent = this.board.map(function (row) {\n            return row\n                .map(function (field) {\n                var bgColor = colors_1.getBackgroundColor(field);\n                return chalk_1.default[bgColor](_this.fillChar);\n            })\n                .join("");\n        });\n    };\n    return Snake;\n}(AbstractGame_1.Game));\nexports.Snake = Snake;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvR2FtZXMvU25ha2UvaW5kZXgudHM/MjY1NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHVEQUEwQjtBQUMxQixtRUFBaUQ7QUFDakQsNkNBQXVDO0FBR3ZDLHNDQUE2RTtBQUU3RTs7OztHQUlHO0FBQ0gsSUFBTSxZQUFZLEdBQUcsVUFBQyxHQUFXLEVBQUUsR0FBVztJQUM1QyxXQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUc7QUFBN0MsQ0FBNkMsQ0FBQztBQWtCaEQ7SUFBMkIseUJBQUk7SUFnRDdCLGVBQ0UsWUFBbUMsRUFDbkMsV0FBaUMsRUFDakMsSUFBb0I7UUFBcEIsZ0NBQW9CO1FBSHRCLFlBS0Usa0JBQU0sWUFBWSxFQUFFLFdBQVcsQ0FBQyxTQW1CakM7UUF2RUQsbUJBQWEsR0FBYSxFQUFFLENBQUM7UUFLN0IsMEJBQTBCO1FBQ2xCLFdBQUssR0FBYyxFQUFFLENBQUM7UUFFOUIsc0JBQXNCO1FBQ2QsYUFBTyxHQUFXLENBQUMsQ0FBQztRQUNwQixtQkFBYSxHQUFZLEtBQUssQ0FBQztRQUN2QyxtQkFBbUI7UUFDWCxVQUFJLEdBQVcsQ0FBQyxDQUFDO1FBQ2pCLGdCQUFVLEdBQVksS0FBSyxDQUFDO1FBSXBDLHdCQUF3QjtRQUNoQixlQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBT3ZCLHNCQUFnQixHQUFVLEtBQUssQ0FBQztRQUNoQyxvQkFBYyxHQUFVLE9BQU8sQ0FBQztRQUV4Qyw2QkFBNkI7UUFDckIsaUJBQVcsR0FBRyxDQUFDLENBQUM7UUFFeEIscUNBQXFDO1FBQzdCLFNBQUcsR0FBYyxPQUFPLENBQUM7UUFFekIsV0FBSyxHQUE0QixNQUFNLENBQUM7UUFFaEQseUNBQXlDO1FBQ2pDLGVBQVMsR0FBYSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUM3QixlQUFTLEdBQWUsRUFBRSxDQUFDO1FBQzNCLG1CQUFhLEdBQWEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFekMsNERBQTREO1FBQ3BELG9CQUFjLEdBQWUsRUFBRSxDQUFDO1FBRXhDLGlDQUFpQztRQUN6QixpQkFBVyxHQUFtQixVQUFVLENBQUMsY0FBTyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFTNUQsS0FBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUMsY0FBYyxJQUFJLEdBQUcsQ0FBQztRQUNqRCxLQUFJLENBQUMsY0FBYyxHQUFHLElBQUksQ0FBQyxjQUFjLElBQUksS0FBSyxDQUFDO1FBQ25ELEtBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLGNBQWMsSUFBSSxNQUFNLENBQUM7UUFDcEQsS0FBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxJQUFJLE9BQU8sQ0FBQztRQUM3QyxLQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLElBQUksT0FBTyxDQUFDO1FBQzdDLEtBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsSUFBSSxHQUFHLENBQUM7UUFDckMsSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ2hCLEtBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztZQUM1QixLQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQztTQUMzQjtRQUNELElBQUksSUFBSSxDQUFDLElBQUksRUFBRTtZQUNiLEtBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQztZQUN0QixLQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQztTQUMzQjtRQUVELDREQUE0RDtRQUM1RCxLQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7O0lBQ2QsQ0FBQztJQUVELGtFQUFrRTtJQUNsRSxrRUFBa0U7SUFDbEUsa0VBQWtFO0lBRWxFLGdDQUFnQztJQUNoQyxvQkFBSSxHQUFKO1FBQ0UsSUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUM7UUFFcEIsMkJBQTJCO1FBQzNCLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBRXpCLGlDQUFpQztRQUNqQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFFcEIsMkNBQTJDO1FBQzNDLDZDQUE2QztRQUM3Qyw2REFBNkQ7UUFDN0QsS0FBSyxJQUFJLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLEVBQUUsR0FBRyxFQUFFO1lBQ3RDLEtBQUssSUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUFFLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRTtnQkFDbEQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztRQUU1QyxvQkFBb0I7UUFDcEIsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO1FBRWxCLG1DQUFtQztRQUNuQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUU1QixpQkFBaUI7UUFDakIsSUFBSSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUM7UUFDcEIsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ2YsQ0FBQztJQUVELDRCQUFZLEdBQVo7UUFDRSxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhO1lBQy9CLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTztZQUNkLENBQUMsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLE9BQU8sQ0FBQztRQUM5QixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDO0lBQ25FLENBQUM7SUFFRCwwQkFBVSxHQUFWLFVBQVcsUUFBa0I7UUFDM0IsUUFBUSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ2xCLEtBQUssTUFBTTtnQkFDVCxPQUFPO1lBQ1QsS0FBSyxNQUFNO2dCQUNULElBQUksQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLENBQUM7Z0JBQy9CLE9BQU87WUFDVCxLQUFLLEtBQUs7Z0JBQ1IsSUFBSSxDQUFDLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUNwQyxPQUFPO1NBQ1Y7SUFDSCxDQUFDO0lBRUQsK0JBQWUsR0FBZixVQUFnQixFQUEyQjtZQUF6QixJQUFJLFlBQUUsT0FBTztRQUM3QixJQUFJLElBQUksS0FBSyxPQUFPLElBQUksT0FBTyxLQUFLLEdBQUcsRUFBRTtZQUN2QyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3JCLE9BQU87U0FDUjtRQUVELElBQUksSUFBSSxLQUFLLFNBQVMsSUFBSSxPQUFPLEtBQUssR0FBRyxFQUFFO1lBQ3pDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDdkIsT0FBTztTQUNSO1FBRUQsSUFBSSxJQUFJLEtBQUssVUFBVSxJQUFJLE9BQU8sS0FBSyxHQUFHLEVBQUU7WUFDMUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN4QixPQUFPO1NBQ1I7UUFFRCxJQUFJLElBQUksS0FBSyxTQUFTLElBQUksT0FBTyxLQUFLLEdBQUcsRUFBRTtZQUN6QyxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ3ZCLE9BQU87U0FDUjtJQUNILENBQUM7SUFFRCxvQ0FBb0IsR0FBcEIsVUFBcUIsRUFBcUI7WUFBbkIsT0FBTztRQUM1QixJQUFJLE9BQU8sS0FBSyxHQUFHLEVBQUU7WUFDbkIsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ2IsT0FBTztTQUNSO1FBRUQsSUFBSSxPQUFPLEtBQUssR0FBRyxFQUFFO1lBQ25CLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDaEMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNqQjtJQUNILENBQUM7SUFFRCx3QkFBUSxHQUFSO1FBQ0UsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNoQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xCLENBQUM7SUFFRCw4QkFBYyxHQUFkO1FBQ0UsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ2YsQ0FBQztJQUVELHFEQUFxRDtJQUNyRCxpQ0FBaUIsR0FBakI7UUFDRSxJQUFJLENBQUMsR0FBRyxHQUFHLE9BQU8sQ0FBQztRQUNuQixJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO1FBQ3BCLElBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDO1FBQ3JCLElBQUksQ0FBQyxhQUFhLEdBQUcsRUFBRSxDQUFDO1FBQ3hCLFlBQVksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVELDBEQUEwRDtJQUMxRCxxQkFBSyxHQUFMO1FBQUEsaUJBZUM7UUFkQyxxQ0FBcUM7UUFDckMsSUFBSSxDQUFDLG1CQUFtQixFQUFFLENBQUM7UUFFM0Isb0RBQW9EO1FBQ3BELElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUVuQiw0Q0FBNEM7UUFDNUMsSUFBSSxJQUFJLENBQUMsS0FBSyxLQUFLLE1BQU07WUFBRSxPQUFPO1FBRWxDLHlCQUF5QjtRQUN6QixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7UUFFYixvQ0FBb0M7UUFDcEMsSUFBSSxDQUFDLFdBQVcsR0FBRyxVQUFVLENBQUMsY0FBTSxZQUFJLENBQUMsS0FBSyxFQUFFLEVBQVosQ0FBWSxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUN6RSxDQUFDO0lBRUQscUJBQUssR0FBTDtRQUNFLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNkLENBQUM7SUFFRCxnQ0FBZ0IsR0FBaEI7UUFBQSxpQkFJQztRQUhDLElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7YUFDMUIsSUFBSSxDQUFDLElBQUksQ0FBQzthQUNWLEdBQUcsQ0FBQyxjQUFNLFlBQUssQ0FBQyxLQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLEtBQUksQ0FBQyxVQUFVLENBQUMsRUFBekMsQ0FBeUMsQ0FBQyxDQUFDO0lBQzFELENBQUM7SUFFRCxrRUFBa0U7SUFDbEUsa0VBQWtFO0lBQ2xFLGtFQUFrRTtJQUVsRSx3QkFBUSxHQUFSO1FBQUEsaUJBb0NDO1FBbkNDLDRDQUE0QztRQUM1QyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUVuQix1Q0FBdUM7UUFDdkMsSUFBTSxLQUFLLEdBQ1QsZUFBSyxDQUFDLDJCQUFrQixDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUM1QywyQkFBa0IsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FDMUMsQ0FBQztRQUVKLHNCQUFzQjtRQUN0QixJQUFNLFFBQVEsR0FBRztZQUNmLFFBQVE7WUFDUixpQkFBZSxJQUFJLENBQUMsV0FBYTtZQUNqQyxZQUFZO1lBQ1osZ0JBQWMsMkJBQWdCLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUc7WUFDN0QsZUFBZTtZQUNmLHlDQUF5QztTQUMxQyxDQUFDLEdBQUcsQ0FBQyxVQUFDLElBQUk7WUFDVCxZQUFLLENBQUMsS0FBSSxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLEtBQUksQ0FBQyxPQUFPLEVBQUUsS0FBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQXhFLENBQXdFLENBQ3pFLENBQUM7UUFFRixtRUFBbUU7UUFDbkUsa0NBQWtDO1FBQ2xDLElBQU0sZUFBZSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRTFELHFCQUFxQjtRQUNyQixJQUFNLFNBQVMsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFFNUQsSUFBSSxDQUFDLGFBQWEsa0JBQ2IsS0FBSyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQ2xELFFBQVEsRUFDUixLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FDckQsQ0FBQztRQUVGLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNmLENBQUM7SUFFRCxrRUFBa0U7SUFDbEUsa0VBQWtFO0lBQ2xFLGtFQUFrRTtJQUVsRTs7O09BR0c7SUFDSCx5QkFBUyxHQUFULFVBQVUsR0FBYztRQUN0QixRQUFRLEdBQUcsRUFBRTtZQUNYLEtBQUssSUFBSTtnQkFDUCxJQUFJLElBQUksQ0FBQyxHQUFHLEtBQUssTUFBTTtvQkFBRSxPQUFPO2dCQUNoQyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztnQkFDZixNQUFNO1lBQ1IsS0FBSyxNQUFNO2dCQUNULElBQUksSUFBSSxDQUFDLEdBQUcsS0FBSyxJQUFJO29CQUFFLE9BQU87Z0JBQzlCLElBQUksQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDO2dCQUNmLE1BQU07WUFDUixLQUFLLE9BQU87Z0JBQ1YsSUFBSSxJQUFJLENBQUMsR0FBRyxLQUFLLE1BQU07b0JBQUUsT0FBTztnQkFDaEMsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7Z0JBQ2YsTUFBTTtZQUNSLEtBQUssTUFBTTtnQkFDVCxJQUFJLElBQUksQ0FBQyxHQUFHLEtBQUssT0FBTztvQkFBRSxPQUFPO2dCQUNqQyxJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztnQkFDZixNQUFNO1NBQ1Q7SUFDSCxDQUFDO0lBRUQsZ0VBQWdFO0lBQ2hFLDJCQUFXLEdBQVg7O1FBQ0UsaUNBQWlDO1FBQ2pDLHFDQUFxQztRQUNyQyxJQUFJLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQztRQUV4Qix3QkFBd0I7UUFDcEIsU0FBYSxJQUFJLENBQUMsYUFBYSxFQUE5QixHQUFHLFVBQUUsR0FBRyxRQUFzQixDQUFDO1FBQ3BDLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztRQUV2Qyw2QkFBNkI7UUFDN0IsS0FBYSxJQUFJLENBQUMsU0FBUyxFQUExQixHQUFHLFVBQUUsR0FBRyxTQUFtQjtRQUM1QixJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUM7UUFFM0MsNkJBQTZCO1FBQzdCLEtBQXVCLFVBQWMsRUFBZCxTQUFJLENBQUMsU0FBUyxFQUFkLGNBQWMsRUFBZCxJQUFjO1lBQTVCLGVBQVUsRUFBVCxLQUFHLFVBQUUsS0FBRztZQUNoQixJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUcsQ0FBQyxDQUFDLEtBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUM7U0FBQTtRQUU3QyxJQUFJLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLDBCQUFVLEdBQVY7UUFBQSxpQkFrQkM7UUFqQkMsb0JBQW9CO1FBQ3BCLCtEQUErRDtRQUMvRCxJQUFNLEtBQUssbUJBQUksSUFBSSxDQUFDLFNBQVMsR0FBSyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDbEQsSUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsVUFBQyxHQUFHO1lBQy9DLEtBQXVCLFVBQUssRUFBTCxlQUFLLEVBQUwsbUJBQUssRUFBTCxJQUFLO2dCQUF2QixJQUFNLFFBQVE7Z0JBQ2pCLElBQUksS0FBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDO29CQUFFLE9BQU8sS0FBSyxDQUFDO2FBQUE7WUFDdEQsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDLENBQUMsQ0FBQztRQUVILDBDQUEwQztRQUMxQyxJQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQzFCLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNoQixPQUFPO1NBQ1I7UUFFRCxxQ0FBcUM7UUFDckMsSUFBSSxDQUFDLGFBQWEsR0FBRyxTQUFTLENBQUMsWUFBWSxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNwRSxDQUFDO0lBRUQsNkRBQTZEO0lBQzdELDZCQUFhLEdBQWIsVUFBYyxJQUFjLEVBQUUsSUFBYztRQUMxQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLENBQUM7WUFBRSxPQUFPLElBQUksQ0FBQztRQUM1RCxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFFRCwwRUFBMEU7SUFDMUUsc0NBQXNCLEdBQXRCO1FBQ0UsS0FBdUIsVUFBYyxFQUFkLFNBQUksQ0FBQyxTQUFTLEVBQWQsY0FBYyxFQUFkLElBQWM7WUFBaEMsSUFBTSxRQUFRO1lBQ2pCLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFFBQVEsQ0FBQztnQkFBRSxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUM7U0FBQTtJQUN0RSxDQUFDO0lBRUQsb0RBQW9EO0lBQ3BELG1DQUFtQixHQUFuQjtRQUNFLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQzFCLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO0lBQ2hDLENBQUM7SUFFRCwrQ0FBK0M7SUFDL0Msa0NBQWtCLEdBQWxCO1FBQ00sU0FBYSxJQUFJLENBQUMsU0FBUyxFQUExQixHQUFHLFVBQUUsR0FBRyxRQUFrQixDQUFDO1FBQ2hDLFFBQVEsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNoQixLQUFLLElBQUk7Z0JBQ1AsR0FBRyxFQUFFLENBQUM7Z0JBQ04sTUFBTTtZQUNSLEtBQUssTUFBTTtnQkFDVCxHQUFHLEVBQUUsQ0FBQztnQkFDTixNQUFNO1lBQ1IsS0FBSyxPQUFPO2dCQUNWLEdBQUcsRUFBRSxDQUFDO2dCQUNOLE1BQU07WUFDUixLQUFLLE1BQU07Z0JBQ1QsR0FBRyxFQUFFLENBQUM7Z0JBQ04sTUFBTTtTQUNUO1FBRUQseUJBQXlCO1FBQ3pCLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxPQUFPLElBQUksR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxHQUFHLEdBQUcsQ0FBQyxFQUFFO1lBQ2pFLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNoQixPQUFPO1NBQ1I7UUFFRCxJQUFJLENBQUMsU0FBUyxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRCwrQ0FBK0M7SUFDL0Msa0NBQWtCLEdBQWxCO1FBQ0UsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxFQUFFO1lBQzFELElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNuQixJQUFJLENBQUMsU0FBUyxtQkFBSSxJQUFJLENBQUMsU0FBUyxHQUFLLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztZQUNyRCxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7WUFDbEIsT0FBTztTQUNSO1FBRUQsSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLE1BQU0sS0FBSyxDQUFDO1lBQUUsT0FBTztRQUV4QyxJQUFJLENBQUMsU0FBUztZQUNaLElBQUksQ0FBQyxTQUFTO1dBQ1gsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUN0RCxDQUFDO0lBQ0osQ0FBQztJQUVELDhEQUE4RDtJQUM5RCxtQ0FBbUIsR0FBbkI7UUFBQSxpQkFTQztRQVJDLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsVUFBQyxHQUFHO1lBQ3RDLFVBQUc7aUJBQ0EsR0FBRyxDQUFDLFVBQUMsS0FBSztnQkFDVCxJQUFNLE9BQU8sR0FBRywyQkFBa0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDMUMsT0FBTyxlQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsS0FBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3ZDLENBQUMsQ0FBQztpQkFDRCxJQUFJLENBQUMsRUFBRSxDQUFDO1FBTFgsQ0FLVyxDQUNaLENBQUM7SUFDSixDQUFDO0lBQ0gsWUFBQztBQUFELENBQUMsQ0ExWTBCLG1CQUFJLEdBMFk5QjtBQTFZWSxzQkFBSyIsImZpbGUiOiI0NS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjaGFsayBmcm9tIFwiY2hhbGtcIjtcbmltcG9ydCBodW1hbml6ZUR1cmF0aW9uIGZyb20gXCJodW1hbml6ZS1kdXJhdGlvblwiO1xuaW1wb3J0IHsgR2FtZSB9IGZyb20gXCIuLi9BYnN0cmFjdEdhbWVcIjtcbmltcG9ydCB7IElucHV0RXZlbnRzSW50ZXJmYWNlLCBLZXlQcmVzcyB9IGZyb20gXCIuLi8uLi9JbnB1dEV2ZW50c1wiO1xuaW1wb3J0IHsgU2NyZWVuV3JpdGVySW50ZXJmYWNlIH0gZnJvbSBcIi4uLy4uL1NjcmVlbldyaXRlclwiO1xuaW1wb3J0IHsgQ29sb3IsIGdldEJhY2tncm91bmRDb2xvciwgZ2V0Rm9yZWdyb3VuZENvbG9yIH0gZnJvbSBcIi4uLy4uL2NvbG9yc1wiO1xuXG4vKipcbiAqIEdldCBhIHJhbmRvbSBpbnRcbiAqIEBwYXJhbSBtaW4gaW50ZWdlclxuICogQHBhcmFtIG1heCBpbnRlZ2VyIChub3QgaW5jbHVzaXZlKVxuICovXG5jb25zdCBnZXRSYW5kb21JbnQgPSAobWluOiBudW1iZXIsIG1heDogbnVtYmVyKSA9PlxuICBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSkgKyBtaW47XG5cbi8qKiBVbmlvbiB0eXBlIGZvciBwb3NzaWJsZSBkaXJlY3Rpb25zICovXG50eXBlIERpcmVjdGlvbiA9IFwidXBcIiB8IFwiZG93blwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCI7XG5cbi8qKiBQb3NpdGlvbiBvZiBhbnkgZWxlbWVudDogW3JvdywgY29sdW1uXSAqL1xudHlwZSBQb3NpdGlvbiA9IFtudW1iZXIsIG51bWJlcl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgU25ha2VPcHRzIHtcbiAgdXBkYXRlSW50ZXJ2YWw/OiBudW1iZXI7XG4gIHNuYWtlSGVhZENvbG9yPzogQ29sb3I7XG4gIHNuYWtlQm9keUNvbG9yPzogQ29sb3I7XG4gIGVtcHR5Q29sb3I/OiBDb2xvcjtcbiAgZnJ1aXRDb2xvcj86IENvbG9yO1xuICBmaWxsQ2hhcj86IHN0cmluZztcbiAgY29sdW1ucz86IG51bWJlcjtcbiAgcm93cz86IG51bWJlcjtcbn1cbmV4cG9ydCBjbGFzcyBTbmFrZSBleHRlbmRzIEdhbWUge1xuICBzY3JlZW5Db250ZW50OiBzdHJpbmdbXSA9IFtdO1xuXG4gIC8qKiBjaGFyYWN0ZXIgdG8gYmUgdXNlZCBmb3IgZWFjaCBlbGVtZW50IG9uIHRoZSBib2FyZCAqL1xuICBwcml2YXRlIGZpbGxDaGFyOiBzdHJpbmc7XG5cbiAgLyoqIGFycmF5IG9mIHJvdyBhcnJheXMgKi9cbiAgcHJpdmF0ZSBib2FyZDogQ29sb3JbXVtdID0gW107XG5cbiAgLyoqIGNvbnNvbGUgY29sdW1ucyAqL1xuICBwcml2YXRlIGNvbHVtbnM6IG51bWJlciA9IDA7XG4gIHByaXZhdGUgY3VzdG9tQ29sdW1uczogYm9vbGVhbiA9IGZhbHNlO1xuICAvKiogY29uc29sZSByb3dzICovXG4gIHByaXZhdGUgcm93czogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBjdXN0b21Sb3dzOiBib29sZWFuID0gZmFsc2U7XG5cbiAgcHJpdmF0ZSB1cGRhdGVJbnRlcnZhbDogbnVtYmVyO1xuXG4gIC8qKiBzdGFydCBvZiB0aGUgZ2FtZSAqL1xuICBwcml2YXRlIHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgLy8gY29sb3JzXG4gIHByaXZhdGUgc25ha2VIZWFkQ29sb3I6IENvbG9yO1xuICBwcml2YXRlIHNuYWtlQm9keUNvbG9yOiBDb2xvcjtcbiAgcHJpdmF0ZSBlbXB0eUNvbG9yOiBDb2xvcjtcbiAgcHJpdmF0ZSBmcnVpdENvbG9yOiBDb2xvcjtcbiAgcHJpdmF0ZSBlbmRTY3JlZW5CZ0NvbG9yOiBDb2xvciA9IFwicmVkXCI7XG4gIHByaXZhdGUgZW5kU2NyZWVuQ29sb3I6IENvbG9yID0gXCJ3aGl0ZVwiO1xuXG4gIC8qKiBudW1iZXIgb2YgZWF0ZW4gZnJ1aXRzICovXG4gIHByaXZhdGUgZnJ1aXRzRWF0ZW4gPSAwO1xuXG4gIC8qKiBjdXJyZW50IGRpcmVjdGlvbiBvZiB0aGUgc25ha2UgKi9cbiAgcHJpdmF0ZSBkaXI6IERpcmVjdGlvbiA9IFwicmlnaHRcIjtcblxuICBwcml2YXRlIHBoYXNlOiBcImdhbWVcIiB8IFwiZW5kXCIgfCBcImluaXRcIiA9IFwiaW5pdFwiO1xuXG4gIC8vIEVsZW1lbnRzIHRvIGJlIHBvc2l0aW9uZWQgb24gdGhlIGJvYXJkXG4gIHByaXZhdGUgc25ha2VIZWFkOiBQb3NpdGlvbiA9IFsxLCAxXTtcbiAgcHJpdmF0ZSBzbmFrZUJvZHk6IFBvc2l0aW9uW10gPSBbXTtcbiAgcHJpdmF0ZSBmcnVpdFBvc2l0aW9uOiBQb3NpdGlvbiA9IFswLCAwXTtcblxuICAvKiogYXJyYXkgb2YgYWxsIHBvc3NpYmxlIHBvc2l0aW9uIHR1cGxlcy4uLiBNRU1PUlkgV0FTVEUgKi9cbiAgcHJpdmF0ZSBmaWVsZHNBdmFpbGFiZTogUG9zaXRpb25bXSA9IFtdO1xuXG4gIC8qKiBzdG9yZSBsYXN0IHNldFRpbWVvdXQgY2FsbCAqL1xuICBwcml2YXRlIGN1cnJUaW1lb3V0OiBOb2RlSlMuVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge30sIDApO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHNjcmVlbldyaXRlcjogU2NyZWVuV3JpdGVySW50ZXJmYWNlLFxuICAgIGlucHV0RXZlbnRzOiBJbnB1dEV2ZW50c0ludGVyZmFjZSxcbiAgICBvcHRzOiBTbmFrZU9wdHMgPSB7fVxuICApIHtcbiAgICBzdXBlcihzY3JlZW5Xcml0ZXIsIGlucHV0RXZlbnRzKTtcblxuICAgIHRoaXMudXBkYXRlSW50ZXJ2YWwgPSBvcHRzLnVwZGF0ZUludGVydmFsIHx8IDEwMDtcbiAgICB0aGlzLnNuYWtlSGVhZENvbG9yID0gb3B0cy5zbmFrZUhlYWRDb2xvciB8fCBcInJlZFwiO1xuICAgIHRoaXMuc25ha2VCb2R5Q29sb3IgPSBvcHRzLnNuYWtlQm9keUNvbG9yIHx8IFwiYmx1ZVwiO1xuICAgIHRoaXMuZW1wdHlDb2xvciA9IG9wdHMuZW1wdHlDb2xvciB8fCBcImJsYWNrXCI7XG4gICAgdGhpcy5mcnVpdENvbG9yID0gb3B0cy5mcnVpdENvbG9yIHx8IFwiZ3JlZW5cIjtcbiAgICB0aGlzLmZpbGxDaGFyID0gb3B0cy5maWxsQ2hhciB8fCBcIiBcIjtcbiAgICBpZiAob3B0cy5jb2x1bW5zKSB7XG4gICAgICB0aGlzLmNvbHVtbnMgPSBvcHRzLmNvbHVtbnM7XG4gICAgICB0aGlzLmN1c3RvbUNvbHVtbnMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0cy5yb3dzKSB7XG4gICAgICB0aGlzLnJvd3MgPSBvcHRzLnJvd3M7XG4gICAgICB0aGlzLmN1c3RvbUNvbHVtbnMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIHdob2xlIHNldHVwIHdyYXBwZWQgaW4gYW5vdGhlciBmdW5jdGlvbiB0byBlYXNpbHkgcmVzdGFydFxuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT0gSU5JVElBTCBTRVRVUCA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvKiogaW5pdGlhbCBzZXR1cCBvZiB0aGUgZ2FtZSAqL1xuICBpbml0KCkge1xuICAgIHRoaXMucGhhc2UgPSBcImluaXRcIjtcblxuICAgIC8vIHNldCBzb21lIHN0YXJ0aW5nIHZhbHVlc1xuICAgIHRoaXMuc2V0U3RhcnRpbmdWYWx1ZXMoKTtcblxuICAgIC8vIGNoZWNrIHRoZSBzaXplIG9mIHRoZSB0ZXJtaW5hbFxuICAgIHRoaXMuc2V0Qm9hcmRTaXplKCk7XG5cbiAgICAvLyBTTyBJTkVGRklDSUVOVC4uLiBUSElTIFNIT1VMRCBCRSBDSEFOR0VEXG4gICAgLy8gd2UncmUgc3RvcmluZyBhbGwgcG9zc2libGUgcG9zaXRpb24gdHVwbGVzXG4gICAgLy8gc28gaXQgd291bGQgYmUgdG8gcGljayBhdmFpbGFibGUgcG9zaXRpb24gZm9yIHRoZSBmcnVpdC4uLlxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMucm93czsgcm93KyspXG4gICAgICBmb3IgKGxldCBjb2x1bW4gPSAwOyBjb2x1bW4gPCB0aGlzLmNvbHVtbnM7IGNvbHVtbisrKVxuICAgICAgICB0aGlzLmZpZWxkc0F2YWlsYWJlLnB1c2goW3JvdywgY29sdW1uXSk7XG5cbiAgICAvLyBwbGFjZSBmaXJzdCBmcnVpdFxuICAgIHRoaXMucGxhY2VGcnVpdCgpO1xuXG4gICAgLy8gcmVjb3JkIHN0YXJ0aW5nIHRpbWUgb2YgdGhlIGdhbWVcbiAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgICAvLyBzdGFydCB0aGUgbG9vcFxuICAgIHRoaXMucGhhc2UgPSBcImdhbWVcIjtcbiAgICB0aGlzLnN0YXJ0KCk7XG4gIH1cblxuICBzZXRCb2FyZFNpemUoKSB7XG4gICAgdGhpcy5jb2x1bW5zID0gdGhpcy5jdXN0b21Db2x1bW5zXG4gICAgICA/IHRoaXMuY29sdW1uc1xuICAgICAgOiB0aGlzLnNjcmVlbldyaXRlci5jb2x1bW5zO1xuICAgIHRoaXMucm93cyA9IHRoaXMuY3VzdG9tUm93cyA/IHRoaXMucm93cyA6IHRoaXMuc2NyZWVuV3JpdGVyLnJvd3M7XG4gIH1cblxuICBvbktleVByZXNzKGtleVByZXNzOiBLZXlQcmVzcykge1xuICAgIHN3aXRjaCAodGhpcy5waGFzZSkge1xuICAgICAgY2FzZSBcImluaXRcIjpcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBcImdhbWVcIjpcbiAgICAgICAgdGhpcy5oYW5kbGVHYW1lSW5wdXQoa2V5UHJlc3MpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgIHRoaXMuaGFuZGxlRW5kU2NyZWVuSW5wdXQoa2V5UHJlc3MpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlR2FtZUlucHV0KHsgbmFtZSwgcHJlc3NlZCB9OiBLZXlQcmVzcykge1xuICAgIGlmIChuYW1lID09PSBcImtleXVwXCIgfHwgcHJlc3NlZCA9PT0gXCJ3XCIpIHtcbiAgICAgIHRoaXMudXBkYXRlRGlyKFwidXBcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IFwia2V5ZG93blwiIHx8IHByZXNzZWQgPT09IFwic1wiKSB7XG4gICAgICB0aGlzLnVwZGF0ZURpcihcImRvd25cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgPT09IFwia2V5cmlnaHRcIiB8fCBwcmVzc2VkID09PSBcImRcIikge1xuICAgICAgdGhpcy51cGRhdGVEaXIoXCJyaWdodFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gXCJrZXlsZWZ0XCIgfHwgcHJlc3NlZCA9PT0gXCJhXCIpIHtcbiAgICAgIHRoaXMudXBkYXRlRGlyKFwibGVmdFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVFbmRTY3JlZW5JbnB1dCh7IHByZXNzZWQgfTogS2V5UHJlc3MpIHtcbiAgICBpZiAocHJlc3NlZCA9PT0gXCJyXCIpIHtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJlc3NlZCA9PT0gXCJxXCIpIHtcbiAgICAgIHRoaXMuc2NyZWVuV3JpdGVyLmNsZWFyU2NyZWVuKCk7XG4gICAgICBwcm9jZXNzLmV4aXQoMCk7XG4gICAgfVxuICB9XG5cbiAgb25TSUdJTlQoKSB7XG4gICAgdGhpcy5zY3JlZW5Xcml0ZXIuY2xlYXJTY3JlZW4oKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH1cblxuICBvblNjcmVlblJlc2l6ZSgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICAvKiogQWxsIGRlZmF1bHQsIG5vbi1vcHRpb24gdmFsdWVzIHNob3VsZCBnbyBoZXJlICAqL1xuICBzZXRTdGFydGluZ1ZhbHVlcygpIHtcbiAgICB0aGlzLmRpciA9IFwicmlnaHRcIjtcbiAgICB0aGlzLnNuYWtlSGVhZCA9IFsxLCAxXTtcbiAgICB0aGlzLnNuYWtlQm9keSA9IFtdO1xuICAgIHRoaXMuZnJ1aXRzRWF0ZW4gPSAwO1xuICAgIHRoaXMuc2NyZWVuQ29udGVudCA9IFtdO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmN1cnJUaW1lb3V0KTtcbiAgfVxuXG4gIC8qKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiBlYWNoIHJlZnJlc2ggb2YgdGhlIGdhbWUgKi9cbiAgc3RhcnQoKSB7XG4gICAgLy8gZmlyc3QgbGV0J3MgdXBkYXRlIHNuYWtlJ3MgcG9zdGlvblxuICAgIHRoaXMudXBkYXRlU25ha2VQb3NpdGlvbigpO1xuXG4gICAgLy8gbmV4dCB1cGRhdGUgc25ha2UgYW5kIGZydWl0IHBvc2l0aW9uIG9uIHRoZSBib2FyZFxuICAgIHRoaXMudXBkYXRlQm9hcmQoKTtcblxuICAgIC8vIGlmIHRoZSBnYW1lIGhhcyBhY3R1YWxseSBlbmRlZCwgc3RvcCBoZXJlXG4gICAgaWYgKHRoaXMucGhhc2UgIT09IFwiZ2FtZVwiKSByZXR1cm47XG5cbiAgICAvLyBwcmludC91cGRhdGUgdGhlIGJvYXJkXG4gICAgdGhpcy5wcmludCgpO1xuXG4gICAgLy8gc2NoZWR1bGUgbmV4dCByZWZyZXNoIG9mIHRoZSBnYW1lXG4gICAgdGhpcy5jdXJyVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdGFydCgpLCB0aGlzLnVwZGF0ZUludGVydmFsKTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgY3JlYXRlRW1wdHlCb2FyZCgpIHtcbiAgICB0aGlzLmJvYXJkID0gQXJyYXkodGhpcy5yb3dzKVxuICAgICAgLmZpbGwobnVsbClcbiAgICAgIC5tYXAoKCkgPT4gQXJyYXkodGhpcy5jb2x1bW5zKS5maWxsKHRoaXMuZW1wdHlDb2xvcikpO1xuICB9XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PSBHQU1FIE9WRVIgPT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICBnYW1lT3ZlcigpIHtcbiAgICAvLyB0aGlzIHdpbGwgc3RvcCBzZXR0aW5nIGFub3RoZXIgc2V0VGltZW91dFxuICAgIHRoaXMucGhhc2UgPSBcImVuZFwiO1xuXG4gICAgLy8gZ2V0IGNoYWxrIGZ1bmN0aW9uIHRvIGNvbG9yIHRoZSB0ZXh0XG4gICAgY29uc3QgY29sb3IgPVxuICAgICAgY2hhbGtbZ2V0Rm9yZWdyb3VuZENvbG9yKHRoaXMuZW5kU2NyZWVuQ29sb3IpXVtcbiAgICAgICAgZ2V0QmFja2dyb3VuZENvbG9yKHRoaXMuZW5kU2NyZWVuQmdDb2xvcilcbiAgICAgIF07XG5cbiAgICAvLyBlbmQgc2NyZWVuIG1lc3NhZ2VzXG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXG4gICAgICAvLyBzY29yZVxuICAgICAgYFlvdXIgc2NvcmU6ICR7dGhpcy5mcnVpdHNFYXRlbn1gLFxuICAgICAgLy8gcGxheSB0aW1lXG4gICAgICBgUGxheSB0aW1lOiAke2h1bWFuaXplRHVyYXRpb24oRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lKX1gLFxuICAgICAgLy8gdXNlciBvcHRpb25zXG4gICAgICAnUHJlc3MgXCJyXCIgdG8gcGxheSBhZ2FpbiBvciBcInFcIiB0byBleGl0LicsXG4gICAgXS5tYXAoKGxpbmUpID0+XG4gICAgICBjb2xvcih0aGlzLnNjcmVlbldyaXRlci5jZW50ZXJTdHJpbmcobGluZSwgdGhpcy5jb2x1bW5zLCB0aGlzLmZpbGxDaGFyKSlcbiAgICApO1xuXG4gICAgLy8gaG93IG1hbnkgbGluZXMgc2hvdWxkIGJlIGJlbG93IGFuZCBhYm92ZSB0aGUgZW5kIHNjcmVlbiBtZXNzYWdlc1xuICAgIC8vIHNvIHRoZXkgYXJlIGNlbnRlcmVkIHZlcnRpY2FsbHlcbiAgICBjb25zdCBlbXB0eUxpbmVzQ291bnQgPSAodGhpcy5yb3dzIC0gbWVzc2FnZXMubGVuZ3RoKSAvIDI7XG5cbiAgICAvLyBmaWxsZXIsIGVtcHR5IGxpbmVcbiAgICBjb25zdCBlbXB0eUxpbmUgPSBjb2xvcih0aGlzLmZpbGxDaGFyLnJlcGVhdCh0aGlzLmNvbHVtbnMpKTtcblxuICAgIHRoaXMuc2NyZWVuQ29udGVudCA9IFtcbiAgICAgIC4uLkFycmF5KE1hdGguZmxvb3IoZW1wdHlMaW5lc0NvdW50KSkuZmlsbChlbXB0eUxpbmUpLFxuICAgICAgLi4ubWVzc2FnZXMsXG4gICAgICAuLi5BcnJheShNYXRoLmNlaWwoZW1wdHlMaW5lc0NvdW50KSkuZmlsbChlbXB0eUxpbmUpLFxuICAgIF07XG5cbiAgICB0aGlzLnByaW50KCk7XG4gIH1cblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy89PT09PT09PT09PT09PT09PT09PT0gVVBEQVRFIEZVTkNUSU9OUyA9PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHNuYWtlJ3MgZGlyZWN0aW9uXG4gICAqIEBwYXJhbSBkaXJcbiAgICovXG4gIHVwZGF0ZURpcihkaXI6IERpcmVjdGlvbikge1xuICAgIHN3aXRjaCAoZGlyKSB7XG4gICAgICBjYXNlIFwidXBcIjpcbiAgICAgICAgaWYgKHRoaXMuZGlyID09PSBcImRvd25cIikgcmV0dXJuO1xuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZG93blwiOlxuICAgICAgICBpZiAodGhpcy5kaXIgPT09IFwidXBcIikgcmV0dXJuO1xuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgaWYgKHRoaXMuZGlyID09PSBcImxlZnRcIikgcmV0dXJuO1xuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICBpZiAodGhpcy5kaXIgPT09IFwicmlnaHRcIikgcmV0dXJuO1xuICAgICAgICB0aGlzLmRpciA9IGRpcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLyoqIGZ1bmN0aW9uIHRvIHVwZGF0ZSBwb3NpdGlvbnMgb2YgYWxsIGVsZW1lbnRzIG9uIHRoZSBib2FyZCAqL1xuICB1cGRhdGVCb2FyZCgpIHtcbiAgICAvLyBmaXJzdCB3ZSBjcmVhdGUgYW4gZW1wdHkgYm9hcmRcbiAgICAvLyBub3Qgc3VyZSBpZiBpdCdzIHRoZSBiZXN0IGFwcHJvYWNoXG4gICAgdGhpcy5jcmVhdGVFbXB0eUJvYXJkKCk7XG5cbiAgICAvLyB1cGRhdGUgZnJ1aXQgcG9zaXRpb25cbiAgICBsZXQgW3JvdywgY29sXSA9IHRoaXMuZnJ1aXRQb3NpdGlvbjtcbiAgICB0aGlzLmJvYXJkW3Jvd11bY29sXSA9IHRoaXMuZnJ1aXRDb2xvcjtcblxuICAgIC8vIHVwZGF0ZSBzbmFrZSBoZWFkIHBvc2l0aW9uXG4gICAgW3JvdywgY29sXSA9IHRoaXMuc25ha2VIZWFkO1xuICAgIHRoaXMuYm9hcmRbcm93XVtjb2xdID0gdGhpcy5zbmFrZUhlYWRDb2xvcjtcblxuICAgIC8vIHVwZGF0ZSBzbmFrZSBib2R5IHBvc2l0aW9uXG4gICAgZm9yIChsZXQgW3JvdywgY29sXSBvZiB0aGlzLnNuYWtlQm9keSlcbiAgICAgIHRoaXMuYm9hcmRbcm93XVtjb2xdID0gdGhpcy5zbmFrZUJvZHlDb2xvcjtcblxuICAgIHRoaXMudXBkYXRlU2NyZWVuQ29udGVudCgpO1xuICB9XG5cbiAgLyoqIElORUZGSUNJRU5UICovXG4gIHBsYWNlRnJ1aXQoKSB7XG4gICAgLy8gYSBsb3Qgb2Ygb3ZlcmhlYWRcbiAgICAvLyBmaXJzdCBmaWx0ZXIgYW4gYXJyYXkgb2YgYWxsIHBvc3NpYmxlIHBvc2l0aW9ucyBvbiB0aGUgYm9hcmRcbiAgICBjb25zdCBzbmFrZSA9IFt0aGlzLnNuYWtlSGVhZCwgLi4udGhpcy5zbmFrZUJvZHldO1xuICAgIGNvbnN0IGF2YWlsYWJsZSA9IHRoaXMuZmllbGRzQXZhaWxhYmUuZmlsdGVyKChwb3MpID0+IHtcbiAgICAgIGZvciAoY29uc3QgYm9keVBhcnQgb2Ygc25ha2UpXG4gICAgICAgIGlmICh0aGlzLmNoZWNrQ29saXNpb24ocG9zLCBib2R5UGFydCkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gaWYgbm8gcG9zaXRpb25zIGF2YWlsYWJsZSwgZW5kIHRoZSBnYW1lXG4gICAgaWYgKGF2YWlsYWJsZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZ2FtZU92ZXIoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBwaWNrIHJhbmRvbSBwb3NpdGlvbiBmb3IgdGhlIGZydWl0XG4gICAgdGhpcy5mcnVpdFBvc2l0aW9uID0gYXZhaWxhYmxlW2dldFJhbmRvbUludCgwLCBhdmFpbGFibGUubGVuZ3RoKV07XG4gIH1cblxuICAvKiogaGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIGlmIHR3byBwb3NpdGlvbnMgYXJlIHRoZSBzYW1lICovXG4gIGNoZWNrQ29saXNpb24ocG9zMTogUG9zaXRpb24sIHBvczI6IFBvc2l0aW9uKSB7XG4gICAgaWYgKHBvczFbMF0gPT09IHBvczJbMF0gJiYgcG9zMVsxXSA9PT0gcG9zMlsxXSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqIGhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBpZiBzbmFrZSdzIGhlYWQgY29sbGlkZSB3aXRoIGFueSBib2R5IHBhcnQgKi9cbiAgY2hlY2tTbmFrZUJvZHlDb2xpc2lvbigpIHtcbiAgICBmb3IgKGNvbnN0IGJvZHlQYXJ0IG9mIHRoaXMuc25ha2VCb2R5KVxuICAgICAgaWYgKHRoaXMuY2hlY2tDb2xpc2lvbih0aGlzLnNuYWtlSGVhZCwgYm9keVBhcnQpKSB0aGlzLmdhbWVPdmVyKCk7XG4gIH1cblxuICAvKiogZnVuY3Rpb24gdG8gdXBkYXRlIHRoZSB3aG9sZSBzbmFrZSdzIHBvc2l0aW9uICovXG4gIHVwZGF0ZVNuYWtlUG9zaXRpb24oKSB7XG4gICAgdGhpcy51cGRhdGVCb2R5UG9zaXRpb24oKTtcbiAgICB0aGlzLnVwZGF0ZUhlYWRQb3NpdGlvbigpO1xuICAgIHRoaXMuY2hlY2tTbmFrZUJvZHlDb2xpc2lvbigpO1xuICB9XG5cbiAgLyoqIGZ1bmN0aW9uIHRvIHVwZGF0ZSBzbmFrZSdzIGhlYWQgcG9zaXRpb24gKi9cbiAgdXBkYXRlSGVhZFBvc2l0aW9uKCkge1xuICAgIGxldCBbcm93LCBjb2xdID0gdGhpcy5zbmFrZUhlYWQ7XG4gICAgc3dpdGNoICh0aGlzLmRpcikge1xuICAgICAgY2FzZSBcInVwXCI6XG4gICAgICAgIHJvdy0tO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkb3duXCI6XG4gICAgICAgIHJvdysrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICBjb2wrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICBjb2wtLTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgaWYgb3V0IG9mIGJvdW5kc1xuICAgIGlmIChjb2wgPj0gdGhpcy5jb2x1bW5zIHx8IGNvbCA8IDAgfHwgcm93ID49IHRoaXMucm93cyB8fCByb3cgPCAwKSB7XG4gICAgICB0aGlzLmdhbWVPdmVyKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zbmFrZUhlYWQgPSBbcm93LCBjb2xdO1xuICB9XG5cbiAgLyoqIGZ1bmN0aW9uIHRvIHVwZGF0ZSBzbmFrZSdzIGJvZHkgcG9zaXRpb24gKi9cbiAgdXBkYXRlQm9keVBvc2l0aW9uKCkge1xuICAgIGlmICh0aGlzLmNoZWNrQ29saXNpb24odGhpcy5zbmFrZUhlYWQsIHRoaXMuZnJ1aXRQb3NpdGlvbikpIHtcbiAgICAgIHRoaXMuZnJ1aXRzRWF0ZW4rKztcbiAgICAgIHRoaXMuc25ha2VCb2R5ID0gW3RoaXMuc25ha2VIZWFkLCAuLi50aGlzLnNuYWtlQm9keV07XG4gICAgICB0aGlzLnBsYWNlRnJ1aXQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zbmFrZUJvZHkubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICB0aGlzLnNuYWtlQm9keSA9IFtcbiAgICAgIHRoaXMuc25ha2VIZWFkLFxuICAgICAgLi4udGhpcy5zbmFrZUJvZHkuc2xpY2UoMCwgdGhpcy5zbmFrZUJvZHkubGVuZ3RoIC0gMSksXG4gICAgXTtcbiAgfVxuXG4gIC8qKiBVcGRhdGVzIHNjcmVlbkNvbnRlbnQgYmFzZWQgb24gdGhlIGNvbnRlbnQgb2YgdGhlIGJvYXJkICovXG4gIHVwZGF0ZVNjcmVlbkNvbnRlbnQoKSB7XG4gICAgdGhpcy5zY3JlZW5Db250ZW50ID0gdGhpcy5ib2FyZC5tYXAoKHJvdykgPT5cbiAgICAgIHJvd1xuICAgICAgICAubWFwKChmaWVsZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGJnQ29sb3IgPSBnZXRCYWNrZ3JvdW5kQ29sb3IoZmllbGQpO1xuICAgICAgICAgIHJldHVybiBjaGFsa1tiZ0NvbG9yXSh0aGlzLmZpbGxDaGFyKTtcbiAgICAgICAgfSlcbiAgICAgICAgLmpvaW4oXCJcIilcbiAgICApO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///45\n')},function(module,exports,__webpack_require__){eval('var __WEBPACK_AMD_DEFINE_RESULT__;// HumanizeDuration.js - https://git.io/j0HgmQ\n\n/* global define, module */\n\n(function () {\n  // This has to be defined separately because of a bug: we want to alias\n  // `gr` and `el` for backwards-compatiblity. In a breaking change, we can\n  // remove `gr` entirely.\n  // See https://github.com/EvanHahn/HumanizeDuration.js/issues/143 for more.\n  var greek = {\n    y: function (c) {\n      return c === 1 ? "χρόνος" : "χρόνια";\n    },\n    mo: function (c) {\n      return c === 1 ? "μήνας" : "μήνες";\n    },\n    w: function (c) {\n      return c === 1 ? "εβδομάδα" : "εβδομάδες";\n    },\n    d: function (c) {\n      return c === 1 ? "μέρα" : "μέρες";\n    },\n    h: function (c) {\n      return c === 1 ? "ώρα" : "ώρες";\n    },\n    m: function (c) {\n      return c === 1 ? "λεπτό" : "λεπτά";\n    },\n    s: function (c) {\n      return c === 1 ? "δευτερόλεπτο" : "δευτερόλεπτα";\n    },\n    ms: function (c) {\n      return c === 1\n        ? "χιλιοστό του δευτερολέπτου"\n        : "χιλιοστά του δευτερολέπτου";\n    },\n    decimal: ",",\n  };\n\n  var LANGUAGES = {\n    ar: {\n      y: function (c) {\n        return c === 1 ? "سنة" : "سنوات";\n      },\n      mo: function (c) {\n        return c === 1 ? "شهر" : "أشهر";\n      },\n      w: function (c) {\n        return c === 1 ? "أسبوع" : "أسابيع";\n      },\n      d: function (c) {\n        return c === 1 ? "يوم" : "أيام";\n      },\n      h: function (c) {\n        return c === 1 ? "ساعة" : "ساعات";\n      },\n      m: function (c) {\n        return c > 2 && c < 11 ? "دقائق" : "دقيقة";\n      },\n      s: function (c) {\n        return c === 1 ? "ثانية" : "ثواني";\n      },\n      ms: function (c) {\n        return c === 1 ? "جزء من الثانية" : "أجزاء من الثانية";\n      },\n      decimal: ",",\n    },\n    bg: {\n      y: function (c) {\n        return ["години", "година", "години"][getSlavicForm(c)];\n      },\n      mo: function (c) {\n        return ["месеца", "месец", "месеца"][getSlavicForm(c)];\n      },\n      w: function (c) {\n        return ["седмици", "седмица", "седмици"][getSlavicForm(c)];\n      },\n      d: function (c) {\n        return ["дни", "ден", "дни"][getSlavicForm(c)];\n      },\n      h: function (c) {\n        return ["часа", "час", "часа"][getSlavicForm(c)];\n      },\n      m: function (c) {\n        return ["минути", "минута", "минути"][getSlavicForm(c)];\n      },\n      s: function (c) {\n        return ["секунди", "секунда", "секунди"][getSlavicForm(c)];\n      },\n      ms: function (c) {\n        return ["милисекунди", "милисекунда", "милисекунди"][getSlavicForm(c)];\n      },\n      decimal: ",",\n    },\n    ca: {\n      y: function (c) {\n        return "any" + (c === 1 ? "" : "s");\n      },\n      mo: function (c) {\n        return "mes" + (c === 1 ? "" : "os");\n      },\n      w: function (c) {\n        return "setman" + (c === 1 ? "a" : "es");\n      },\n      d: function (c) {\n        return "di" + (c === 1 ? "a" : "es");\n      },\n      h: function (c) {\n        return "hor" + (c === 1 ? "a" : "es");\n      },\n      m: function (c) {\n        return "minut" + (c === 1 ? "" : "s");\n      },\n      s: function (c) {\n        return "segon" + (c === 1 ? "" : "s");\n      },\n      ms: function (c) {\n        return "milisegon" + (c === 1 ? "" : "s");\n      },\n      decimal: ",",\n    },\n    cs: {\n      y: function (c) {\n        return ["rok", "roku", "roky", "let"][getCzechOrSlovakForm(c)];\n      },\n      mo: function (c) {\n        return ["měsíc", "měsíce", "měsíce", "měsíců"][getCzechOrSlovakForm(c)];\n      },\n      w: function (c) {\n        return ["týden", "týdne", "týdny", "týdnů"][getCzechOrSlovakForm(c)];\n      },\n      d: function (c) {\n        return ["den", "dne", "dny", "dní"][getCzechOrSlovakForm(c)];\n      },\n      h: function (c) {\n        return ["hodina", "hodiny", "hodiny", "hodin"][getCzechOrSlovakForm(c)];\n      },\n      m: function (c) {\n        return ["minuta", "minuty", "minuty", "minut"][getCzechOrSlovakForm(c)];\n      },\n      s: function (c) {\n        return ["sekunda", "sekundy", "sekundy", "sekund"][\n          getCzechOrSlovakForm(c)\n        ];\n      },\n      ms: function (c) {\n        return ["milisekunda", "milisekundy", "milisekundy", "milisekund"][\n          getCzechOrSlovakForm(c)\n        ];\n      },\n      decimal: ",",\n    },\n    da: {\n      y: "år",\n      mo: function (c) {\n        return "måned" + (c === 1 ? "" : "er");\n      },\n      w: function (c) {\n        return "uge" + (c === 1 ? "" : "r");\n      },\n      d: function (c) {\n        return "dag" + (c === 1 ? "" : "e");\n      },\n      h: function (c) {\n        return "time" + (c === 1 ? "" : "r");\n      },\n      m: function (c) {\n        return "minut" + (c === 1 ? "" : "ter");\n      },\n      s: function (c) {\n        return "sekund" + (c === 1 ? "" : "er");\n      },\n      ms: function (c) {\n        return "millisekund" + (c === 1 ? "" : "er");\n      },\n      decimal: ",",\n    },\n    de: {\n      y: function (c) {\n        return "Jahr" + (c === 1 ? "" : "e");\n      },\n      mo: function (c) {\n        return "Monat" + (c === 1 ? "" : "e");\n      },\n      w: function (c) {\n        return "Woche" + (c === 1 ? "" : "n");\n      },\n      d: function (c) {\n        return "Tag" + (c === 1 ? "" : "e");\n      },\n      h: function (c) {\n        return "Stunde" + (c === 1 ? "" : "n");\n      },\n      m: function (c) {\n        return "Minute" + (c === 1 ? "" : "n");\n      },\n      s: function (c) {\n        return "Sekunde" + (c === 1 ? "" : "n");\n      },\n      ms: function (c) {\n        return "Millisekunde" + (c === 1 ? "" : "n");\n      },\n      decimal: ",",\n    },\n    el: greek,\n    en: {\n      y: function (c) {\n        return "year" + (c === 1 ? "" : "s");\n      },\n      mo: function (c) {\n        return "month" + (c === 1 ? "" : "s");\n      },\n      w: function (c) {\n        return "week" + (c === 1 ? "" : "s");\n      },\n      d: function (c) {\n        return "day" + (c === 1 ? "" : "s");\n      },\n      h: function (c) {\n        return "hour" + (c === 1 ? "" : "s");\n      },\n      m: function (c) {\n        return "minute" + (c === 1 ? "" : "s");\n      },\n      s: function (c) {\n        return "second" + (c === 1 ? "" : "s");\n      },\n      ms: function (c) {\n        return "millisecond" + (c === 1 ? "" : "s");\n      },\n      decimal: ".",\n    },\n    es: {\n      y: function (c) {\n        return "año" + (c === 1 ? "" : "s");\n      },\n      mo: function (c) {\n        return "mes" + (c === 1 ? "" : "es");\n      },\n      w: function (c) {\n        return "semana" + (c === 1 ? "" : "s");\n      },\n      d: function (c) {\n        return "día" + (c === 1 ? "" : "s");\n      },\n      h: function (c) {\n        return "hora" + (c === 1 ? "" : "s");\n      },\n      m: function (c) {\n        return "minuto" + (c === 1 ? "" : "s");\n      },\n      s: function (c) {\n        return "segundo" + (c === 1 ? "" : "s");\n      },\n      ms: function (c) {\n        return "milisegundo" + (c === 1 ? "" : "s");\n      },\n      decimal: ",",\n    },\n    et: {\n      y: function (c) {\n        return "aasta" + (c === 1 ? "" : "t");\n      },\n      mo: function (c) {\n        return "kuu" + (c === 1 ? "" : "d");\n      },\n      w: function (c) {\n        return "nädal" + (c === 1 ? "" : "at");\n      },\n      d: function (c) {\n        return "päev" + (c === 1 ? "" : "a");\n      },\n      h: function (c) {\n        return "tund" + (c === 1 ? "" : "i");\n      },\n      m: function (c) {\n        return "minut" + (c === 1 ? "" : "it");\n      },\n      s: function (c) {\n        return "sekund" + (c === 1 ? "" : "it");\n      },\n      ms: function (c) {\n        return "millisekund" + (c === 1 ? "" : "it");\n      },\n      decimal: ",",\n    },\n    fa: {\n      y: "سال",\n      mo: "ماه",\n      w: "هفته",\n      d: "روز",\n      h: "ساعت",\n      m: "دقیقه",\n      s: "ثانیه",\n      ms: "میلی ثانیه",\n      decimal: ".",\n    },\n    fi: {\n      y: function (c) {\n        return c === 1 ? "vuosi" : "vuotta";\n      },\n      mo: function (c) {\n        return c === 1 ? "kuukausi" : "kuukautta";\n      },\n      w: function (c) {\n        return "viikko" + (c === 1 ? "" : "a");\n      },\n      d: function (c) {\n        return "päivä" + (c === 1 ? "" : "ä");\n      },\n      h: function (c) {\n        return "tunti" + (c === 1 ? "" : "a");\n      },\n      m: function (c) {\n        return "minuutti" + (c === 1 ? "" : "a");\n      },\n      s: function (c) {\n        return "sekunti" + (c === 1 ? "" : "a");\n      },\n      ms: function (c) {\n        return "millisekunti" + (c === 1 ? "" : "a");\n      },\n      decimal: ",",\n    },\n    fo: {\n      y: "ár",\n      mo: function (c) {\n        return c === 1 ? "mánaður" : "mánaðir";\n      },\n      w: function (c) {\n        return c === 1 ? "vika" : "vikur";\n      },\n      d: function (c) {\n        return c === 1 ? "dagur" : "dagar";\n      },\n      h: function (c) {\n        return c === 1 ? "tími" : "tímar";\n      },\n      m: function (c) {\n        return c === 1 ? "minuttur" : "minuttir";\n      },\n      s: "sekund",\n      ms: "millisekund",\n      decimal: ",",\n    },\n    fr: {\n      y: function (c) {\n        return "an" + (c >= 2 ? "s" : "");\n      },\n      mo: "mois",\n      w: function (c) {\n        return "semaine" + (c >= 2 ? "s" : "");\n      },\n      d: function (c) {\n        return "jour" + (c >= 2 ? "s" : "");\n      },\n      h: function (c) {\n        return "heure" + (c >= 2 ? "s" : "");\n      },\n      m: function (c) {\n        return "minute" + (c >= 2 ? "s" : "");\n      },\n      s: function (c) {\n        return "seconde" + (c >= 2 ? "s" : "");\n      },\n      ms: function (c) {\n        return "milliseconde" + (c >= 2 ? "s" : "");\n      },\n      decimal: ",",\n    },\n    gr: greek,\n    he: {\n      y: function (c) {\n        return c === 1 ? "שנה" : "שנים";\n      },\n      mo: function (c) {\n        return c === 1 ? "חודש" : "חודשים";\n      },\n      w: function (c) {\n        return c === 1 ? "שבוע" : "שבועות";\n      },\n      d: function (c) {\n        return c === 1 ? "יום" : "ימים";\n      },\n      h: function (c) {\n        return c === 1 ? "שעה" : "שעות";\n      },\n      m: function (c) {\n        return c === 1 ? "דקה" : "דקות";\n      },\n      s: function (c) {\n        return c === 1 ? "שניה" : "שניות";\n      },\n      ms: function (c) {\n        return c === 1 ? "מילישנייה" : "מילישניות";\n      },\n      decimal: ".",\n    },\n    hr: {\n      y: function (c) {\n        if (c % 10 === 2 || c % 10 === 3 || c % 10 === 4) {\n          return "godine";\n        }\n        return "godina";\n      },\n      mo: function (c) {\n        if (c === 1) {\n          return "mjesec";\n        } else if (c === 2 || c === 3 || c === 4) {\n          return "mjeseca";\n        }\n        return "mjeseci";\n      },\n      w: function (c) {\n        if (c % 10 === 1 && c !== 11) {\n          return "tjedan";\n        }\n        return "tjedna";\n      },\n      d: function (c) {\n        return c === 1 ? "dan" : "dana";\n      },\n      h: function (c) {\n        if (c === 1) {\n          return "sat";\n        } else if (c === 2 || c === 3 || c === 4) {\n          return "sata";\n        }\n        return "sati";\n      },\n      m: function (c) {\n        var mod10 = c % 10;\n        if ((mod10 === 2 || mod10 === 3 || mod10 === 4) && (c < 10 || c > 14)) {\n          return "minute";\n        }\n        return "minuta";\n      },\n      s: function (c) {\n        if (\n          c === 10 ||\n          c === 11 ||\n          c === 12 ||\n          c === 13 ||\n          c === 14 ||\n          c === 16 ||\n          c === 17 ||\n          c === 18 ||\n          c === 19 ||\n          c % 10 === 5\n        ) {\n          return "sekundi";\n        } else if (c % 10 === 1) {\n          return "sekunda";\n        } else if (c % 10 === 2 || c % 10 === 3 || c % 10 === 4) {\n          return "sekunde";\n        }\n        return "sekundi";\n      },\n      ms: function (c) {\n        if (c === 1) {\n          return "milisekunda";\n        } else if (c % 10 === 2 || c % 10 === 3 || c % 10 === 4) {\n          return "milisekunde";\n        }\n        return "milisekundi";\n      },\n      decimal: ",",\n    },\n    hu: {\n      y: "év",\n      mo: "hónap",\n      w: "hét",\n      d: "nap",\n      h: "óra",\n      m: "perc",\n      s: "másodperc",\n      ms: "ezredmásodperc",\n      decimal: ",",\n    },\n    id: {\n      y: "tahun",\n      mo: "bulan",\n      w: "minggu",\n      d: "hari",\n      h: "jam",\n      m: "menit",\n      s: "detik",\n      ms: "milidetik",\n      decimal: ".",\n    },\n    is: {\n      y: "ár",\n      mo: function (c) {\n        return "mánuð" + (c === 1 ? "ur" : "ir");\n      },\n      w: function (c) {\n        return "vik" + (c === 1 ? "a" : "ur");\n      },\n      d: function (c) {\n        return "dag" + (c === 1 ? "ur" : "ar");\n      },\n      h: function (c) {\n        return "klukkutím" + (c === 1 ? "i" : "ar");\n      },\n      m: function (c) {\n        return "mínút" + (c === 1 ? "a" : "ur");\n      },\n      s: function (c) {\n        return "sekúnd" + (c === 1 ? "a" : "ur");\n      },\n      ms: function (c) {\n        return "millisekúnd" + (c === 1 ? "a" : "ur");\n      },\n      decimal: ".",\n    },\n    it: {\n      y: function (c) {\n        return "ann" + (c === 1 ? "o" : "i");\n      },\n      mo: function (c) {\n        return "mes" + (c === 1 ? "e" : "i");\n      },\n      w: function (c) {\n        return "settiman" + (c === 1 ? "a" : "e");\n      },\n      d: function (c) {\n        return "giorn" + (c === 1 ? "o" : "i");\n      },\n      h: function (c) {\n        return "or" + (c === 1 ? "a" : "e");\n      },\n      m: function (c) {\n        return "minut" + (c === 1 ? "o" : "i");\n      },\n      s: function (c) {\n        return "second" + (c === 1 ? "o" : "i");\n      },\n      ms: function (c) {\n        return "millisecond" + (c === 1 ? "o" : "i");\n      },\n      decimal: ",",\n    },\n    ja: {\n      y: "年",\n      mo: "月",\n      w: "週",\n      d: "日",\n      h: "時間",\n      m: "分",\n      s: "秒",\n      ms: "ミリ秒",\n      decimal: ".",\n    },\n    ko: {\n      y: "년",\n      mo: "개월",\n      w: "주일",\n      d: "일",\n      h: "시간",\n      m: "분",\n      s: "초",\n      ms: "밀리 초",\n      decimal: ".",\n    },\n    lo: {\n      y: "ປີ",\n      mo: "ເດືອນ",\n      w: "ອາທິດ",\n      d: "ມື້",\n      h: "ຊົ່ວໂມງ",\n      m: "ນາທີ",\n      s: "ວິນາທີ",\n      ms: "ມິນລິວິນາທີ",\n      decimal: ",",\n    },\n    lt: {\n      y: function (c) {\n        return c % 10 === 0 || (c % 100 >= 10 && c % 100 <= 20)\n          ? "metų"\n          : "metai";\n      },\n      mo: function (c) {\n        return ["mėnuo", "mėnesiai", "mėnesių"][getLithuanianForm(c)];\n      },\n      w: function (c) {\n        return ["savaitė", "savaitės", "savaičių"][getLithuanianForm(c)];\n      },\n      d: function (c) {\n        return ["diena", "dienos", "dienų"][getLithuanianForm(c)];\n      },\n      h: function (c) {\n        return ["valanda", "valandos", "valandų"][getLithuanianForm(c)];\n      },\n      m: function (c) {\n        return ["minutė", "minutės", "minučių"][getLithuanianForm(c)];\n      },\n      s: function (c) {\n        return ["sekundė", "sekundės", "sekundžių"][getLithuanianForm(c)];\n      },\n      ms: function (c) {\n        return ["milisekundė", "milisekundės", "milisekundžių"][\n          getLithuanianForm(c)\n        ];\n      },\n      decimal: ",",\n    },\n    lv: {\n      y: function (c) {\n        return getLatvianForm(c) ? "gads" : "gadi";\n      },\n      mo: function (c) {\n        return getLatvianForm(c) ? "mēnesis" : "mēneši";\n      },\n      w: function (c) {\n        return getLatvianForm(c) ? "nedēļa" : "nedēļas";\n      },\n      d: function (c) {\n        return getLatvianForm(c) ? "diena" : "dienas";\n      },\n      h: function (c) {\n        return getLatvianForm(c) ? "stunda" : "stundas";\n      },\n      m: function (c) {\n        return getLatvianForm(c) ? "minūte" : "minūtes";\n      },\n      s: function (c) {\n        return getLatvianForm(c) ? "sekunde" : "sekundes";\n      },\n      ms: function (c) {\n        return getLatvianForm(c) ? "milisekunde" : "milisekundes";\n      },\n      decimal: ",",\n    },\n    ms: {\n      y: "tahun",\n      mo: "bulan",\n      w: "minggu",\n      d: "hari",\n      h: "jam",\n      m: "minit",\n      s: "saat",\n      ms: "milisaat",\n      decimal: ".",\n    },\n    nl: {\n      y: "jaar",\n      mo: function (c) {\n        return c === 1 ? "maand" : "maanden";\n      },\n      w: function (c) {\n        return c === 1 ? "week" : "weken";\n      },\n      d: function (c) {\n        return c === 1 ? "dag" : "dagen";\n      },\n      h: "uur",\n      m: function (c) {\n        return c === 1 ? "minuut" : "minuten";\n      },\n      s: function (c) {\n        return c === 1 ? "seconde" : "seconden";\n      },\n      ms: function (c) {\n        return c === 1 ? "milliseconde" : "milliseconden";\n      },\n      decimal: ",",\n    },\n    no: {\n      y: "år",\n      mo: function (c) {\n        return "måned" + (c === 1 ? "" : "er");\n      },\n      w: function (c) {\n        return "uke" + (c === 1 ? "" : "r");\n      },\n      d: function (c) {\n        return "dag" + (c === 1 ? "" : "er");\n      },\n      h: function (c) {\n        return "time" + (c === 1 ? "" : "r");\n      },\n      m: function (c) {\n        return "minutt" + (c === 1 ? "" : "er");\n      },\n      s: function (c) {\n        return "sekund" + (c === 1 ? "" : "er");\n      },\n      ms: function (c) {\n        return "millisekund" + (c === 1 ? "" : "er");\n      },\n      decimal: ",",\n    },\n    pl: {\n      y: function (c) {\n        return ["rok", "roku", "lata", "lat"][getPolishForm(c)];\n      },\n      mo: function (c) {\n        return ["miesiąc", "miesiąca", "miesiące", "miesięcy"][\n          getPolishForm(c)\n        ];\n      },\n      w: function (c) {\n        return ["tydzień", "tygodnia", "tygodnie", "tygodni"][getPolishForm(c)];\n      },\n      d: function (c) {\n        return ["dzień", "dnia", "dni", "dni"][getPolishForm(c)];\n      },\n      h: function (c) {\n        return ["godzina", "godziny", "godziny", "godzin"][getPolishForm(c)];\n      },\n      m: function (c) {\n        return ["minuta", "minuty", "minuty", "minut"][getPolishForm(c)];\n      },\n      s: function (c) {\n        return ["sekunda", "sekundy", "sekundy", "sekund"][getPolishForm(c)];\n      },\n      ms: function (c) {\n        return ["milisekunda", "milisekundy", "milisekundy", "milisekund"][\n          getPolishForm(c)\n        ];\n      },\n      decimal: ",",\n    },\n    pt: {\n      y: function (c) {\n        return "ano" + (c === 1 ? "" : "s");\n      },\n      mo: function (c) {\n        return c === 1 ? "mês" : "meses";\n      },\n      w: function (c) {\n        return "semana" + (c === 1 ? "" : "s");\n      },\n      d: function (c) {\n        return "dia" + (c === 1 ? "" : "s");\n      },\n      h: function (c) {\n        return "hora" + (c === 1 ? "" : "s");\n      },\n      m: function (c) {\n        return "minuto" + (c === 1 ? "" : "s");\n      },\n      s: function (c) {\n        return "segundo" + (c === 1 ? "" : "s");\n      },\n      ms: function (c) {\n        return "milissegundo" + (c === 1 ? "" : "s");\n      },\n      decimal: ",",\n    },\n    ro: {\n      y: function (c) {\n        return c === 1 ? "an" : "ani";\n      },\n      mo: function (c) {\n        return c === 1 ? "lună" : "luni";\n      },\n      w: function (c) {\n        return c === 1 ? "săptămână" : "săptămâni";\n      },\n      d: function (c) {\n        return c === 1 ? "zi" : "zile";\n      },\n      h: function (c) {\n        return c === 1 ? "oră" : "ore";\n      },\n      m: function (c) {\n        return c === 1 ? "minut" : "minute";\n      },\n      s: function (c) {\n        return c === 1 ? "secundă" : "secunde";\n      },\n      ms: function (c) {\n        return c === 1 ? "milisecundă" : "milisecunde";\n      },\n      decimal: ",",\n    },\n    ru: {\n      y: function (c) {\n        return ["лет", "год", "года"][getSlavicForm(c)];\n      },\n      mo: function (c) {\n        return ["месяцев", "месяц", "месяца"][getSlavicForm(c)];\n      },\n      w: function (c) {\n        return ["недель", "неделя", "недели"][getSlavicForm(c)];\n      },\n      d: function (c) {\n        return ["дней", "день", "дня"][getSlavicForm(c)];\n      },\n      h: function (c) {\n        return ["часов", "час", "часа"][getSlavicForm(c)];\n      },\n      m: function (c) {\n        return ["минут", "минута", "минуты"][getSlavicForm(c)];\n      },\n      s: function (c) {\n        return ["секунд", "секунда", "секунды"][getSlavicForm(c)];\n      },\n      ms: function (c) {\n        return ["миллисекунд", "миллисекунда", "миллисекунды"][\n          getSlavicForm(c)\n        ];\n      },\n      decimal: ",",\n    },\n    uk: {\n      y: function (c) {\n        return ["років", "рік", "роки"][getSlavicForm(c)];\n      },\n      mo: function (c) {\n        return ["місяців", "місяць", "місяці"][getSlavicForm(c)];\n      },\n      w: function (c) {\n        return ["тижнів", "тиждень", "тижні"][getSlavicForm(c)];\n      },\n      d: function (c) {\n        return ["днів", "день", "дні"][getSlavicForm(c)];\n      },\n      h: function (c) {\n        return ["годин", "година", "години"][getSlavicForm(c)];\n      },\n      m: function (c) {\n        return ["хвилин", "хвилина", "хвилини"][getSlavicForm(c)];\n      },\n      s: function (c) {\n        return ["секунд", "секунда", "секунди"][getSlavicForm(c)];\n      },\n      ms: function (c) {\n        return ["мілісекунд", "мілісекунда", "мілісекунди"][getSlavicForm(c)];\n      },\n      decimal: ",",\n    },\n    ur: {\n      y: "سال",\n      mo: function (c) {\n        return c === 1 ? "مہینہ" : "مہینے";\n      },\n      w: function (c) {\n        return c === 1 ? "ہفتہ" : "ہفتے";\n      },\n      d: "دن",\n      h: function (c) {\n        return c === 1 ? "گھنٹہ" : "گھنٹے";\n      },\n      m: "منٹ",\n      s: "سیکنڈ",\n      ms: "ملی سیکنڈ",\n      decimal: ".",\n    },\n    sk: {\n      y: function (c) {\n        return ["rok", "roky", "roky", "rokov"][getCzechOrSlovakForm(c)];\n      },\n      mo: function (c) {\n        return ["mesiac", "mesiace", "mesiace", "mesiacov"][\n          getCzechOrSlovakForm(c)\n        ];\n      },\n      w: function (c) {\n        return ["týždeň", "týždne", "týždne", "týždňov"][\n          getCzechOrSlovakForm(c)\n        ];\n      },\n      d: function (c) {\n        return ["deň", "dni", "dni", "dní"][getCzechOrSlovakForm(c)];\n      },\n      h: function (c) {\n        return ["hodina", "hodiny", "hodiny", "hodín"][getCzechOrSlovakForm(c)];\n      },\n      m: function (c) {\n        return ["minúta", "minúty", "minúty", "minút"][getCzechOrSlovakForm(c)];\n      },\n      s: function (c) {\n        return ["sekunda", "sekundy", "sekundy", "sekúnd"][\n          getCzechOrSlovakForm(c)\n        ];\n      },\n      ms: function (c) {\n        return ["milisekunda", "milisekundy", "milisekundy", "milisekúnd"][\n          getCzechOrSlovakForm(c)\n        ];\n      },\n      decimal: ",",\n    },\n    sv: {\n      y: "år",\n      mo: function (c) {\n        return "månad" + (c === 1 ? "" : "er");\n      },\n      w: function (c) {\n        return "veck" + (c === 1 ? "a" : "or");\n      },\n      d: function (c) {\n        return "dag" + (c === 1 ? "" : "ar");\n      },\n      h: function (c) {\n        return "timm" + (c === 1 ? "e" : "ar");\n      },\n      m: function (c) {\n        return "minut" + (c === 1 ? "" : "er");\n      },\n      s: function (c) {\n        return "sekund" + (c === 1 ? "" : "er");\n      },\n      ms: function (c) {\n        return "millisekund" + (c === 1 ? "" : "er");\n      },\n      decimal: ",",\n    },\n    sw: {\n      y: function (c) {\n        return c === 1 ? "mwaka" : "miaka";\n      },\n      mo: function (c) {\n        return c === 1 ? "mwezi" : "miezi";\n      },\n      w: "wiki",\n      d: function (c) {\n        return c === 1 ? "siku" : "masiku";\n      },\n      h: function (c) {\n        return c === 1 ? "saa" : "masaa";\n      },\n      m: "dakika",\n      s: "sekunde",\n      ms: "milisekunde",\n      decimal: ".",\n    },\n    tr: {\n      y: "yıl",\n      mo: "ay",\n      w: "hafta",\n      d: "gün",\n      h: "saat",\n      m: "dakika",\n      s: "saniye",\n      ms: "milisaniye",\n      decimal: ",",\n    },\n    th: {\n      y: "ปี",\n      mo: "เดือน",\n      w: "อาทิตย์",\n      d: "วัน",\n      h: "ชั่วโมง",\n      m: "นาที",\n      s: "วินาที",\n      ms: "มิลลิวินาที",\n      decimal: ".",\n    },\n    vi: {\n      y: "năm",\n      mo: "tháng",\n      w: "tuần",\n      d: "ngày",\n      h: "giờ",\n      m: "phút",\n      s: "giây",\n      ms: "mili giây",\n      decimal: ",",\n    },\n    zh_CN: {\n      y: "年",\n      mo: "个月",\n      w: "周",\n      d: "天",\n      h: "小时",\n      m: "分钟",\n      s: "秒",\n      ms: "毫秒",\n      decimal: ".",\n    },\n    zh_TW: {\n      y: "年",\n      mo: "個月",\n      w: "周",\n      d: "天",\n      h: "小時",\n      m: "分鐘",\n      s: "秒",\n      ms: "毫秒",\n      decimal: ".",\n    },\n  };\n\n  // You can create a humanizer, which returns a function with default\n  // parameters.\n  function humanizer(passedOptions) {\n    var result = function humanizer(ms, humanizerOptions) {\n      var options = extend({}, result, humanizerOptions || {});\n      return doHumanization(ms, options);\n    };\n\n    return extend(\n      result,\n      {\n        language: "en",\n        delimiter: ", ",\n        spacer: " ",\n        conjunction: "",\n        serialComma: true,\n        units: ["y", "mo", "w", "d", "h", "m", "s"],\n        languages: {},\n        round: false,\n        unitMeasures: {\n          y: 31557600000,\n          mo: 2629800000,\n          w: 604800000,\n          d: 86400000,\n          h: 3600000,\n          m: 60000,\n          s: 1000,\n          ms: 1,\n        },\n      },\n      passedOptions\n    );\n  }\n\n  // The main function is just a wrapper around a default humanizer.\n  var humanizeDuration = humanizer({});\n\n  // Build dictionary from options\n  function getDictionary(options) {\n    var languagesFromOptions = [options.language];\n\n    if (has(options, "fallbacks")) {\n      if (isArray(options.fallbacks) && options.fallbacks.length) {\n        languagesFromOptions = languagesFromOptions.concat(options.fallbacks);\n      } else {\n        throw new Error("fallbacks must be an array with at least one element");\n      }\n    }\n\n    for (var i = 0; i < languagesFromOptions.length; i++) {\n      var languageToTry = languagesFromOptions[i];\n      if (has(options.languages, languageToTry)) {\n        return options.languages[languageToTry];\n      } else if (has(LANGUAGES, languageToTry)) {\n        return LANGUAGES[languageToTry];\n      }\n    }\n\n    throw new Error("No language found.");\n  }\n\n  // doHumanization does the bulk of the work.\n  function doHumanization(ms, options) {\n    var i, len, piece;\n\n    // Make sure we have a positive number.\n    // Has the nice sideffect of turning Number objects into primitives.\n    ms = Math.abs(ms);\n\n    var dictionary = getDictionary(options);\n    var pieces = [];\n\n    // Start at the top and keep removing units, bit by bit.\n    var unitName, unitMS, unitCount;\n    for (i = 0, len = options.units.length; i < len; i++) {\n      unitName = options.units[i];\n      unitMS = options.unitMeasures[unitName];\n\n      // What\'s the number of full units we can fit?\n      if (i + 1 === len) {\n        if (has(options, "maxDecimalPoints")) {\n          // We need to use this expValue to avoid rounding functionality of toFixed call\n          var expValue = Math.pow(10, options.maxDecimalPoints);\n          var unitCountFloat = ms / unitMS;\n          unitCount = parseFloat(\n            (Math.floor(expValue * unitCountFloat) / expValue).toFixed(\n              options.maxDecimalPoints\n            )\n          );\n        } else {\n          unitCount = ms / unitMS;\n        }\n      } else {\n        unitCount = Math.floor(ms / unitMS);\n      }\n\n      // Add the string.\n      pieces.push({\n        unitCount: unitCount,\n        unitName: unitName,\n      });\n\n      // Remove what we just figured out.\n      ms -= unitCount * unitMS;\n    }\n\n    var firstOccupiedUnitIndex = 0;\n    for (i = 0; i < pieces.length; i++) {\n      if (pieces[i].unitCount) {\n        firstOccupiedUnitIndex = i;\n        break;\n      }\n    }\n\n    if (options.round) {\n      var ratioToLargerUnit, previousPiece;\n      for (i = pieces.length - 1; i >= 0; i--) {\n        piece = pieces[i];\n        piece.unitCount = Math.round(piece.unitCount);\n\n        if (i === 0) {\n          break;\n        }\n\n        previousPiece = pieces[i - 1];\n\n        ratioToLargerUnit =\n          options.unitMeasures[previousPiece.unitName] /\n          options.unitMeasures[piece.unitName];\n        if (\n          piece.unitCount % ratioToLargerUnit === 0 ||\n          (options.largest && options.largest - 1 < i - firstOccupiedUnitIndex)\n        ) {\n          previousPiece.unitCount += piece.unitCount / ratioToLargerUnit;\n          piece.unitCount = 0;\n        }\n      }\n    }\n\n    var result = [];\n    for (i = 0, pieces.length; i < len; i++) {\n      piece = pieces[i];\n      if (piece.unitCount) {\n        result.push(\n          render(piece.unitCount, piece.unitName, dictionary, options)\n        );\n      }\n\n      if (result.length === options.largest) {\n        break;\n      }\n    }\n\n    if (result.length) {\n      if (!options.conjunction || result.length === 1) {\n        return result.join(options.delimiter);\n      } else if (result.length === 2) {\n        return result.join(options.conjunction);\n      } else if (result.length > 2) {\n        return (\n          result.slice(0, -1).join(options.delimiter) +\n          (options.serialComma ? "," : "") +\n          options.conjunction +\n          result.slice(-1)\n        );\n      }\n    } else {\n      return render(\n        0,\n        options.units[options.units.length - 1],\n        dictionary,\n        options\n      );\n    }\n  }\n\n  function render(count, type, dictionary, options) {\n    var decimal;\n    if (has(options, "decimal")) {\n      decimal = options.decimal;\n    } else if (has(dictionary, "decimal")) {\n      decimal = dictionary.decimal;\n    } else {\n      decimal = ".";\n    }\n\n    var countStr = count.toString().replace(".", decimal);\n\n    var dictionaryValue = dictionary[type];\n    var word;\n    if (typeof dictionaryValue === "function") {\n      word = dictionaryValue(count);\n    } else {\n      word = dictionaryValue;\n    }\n\n    return countStr + options.spacer + word;\n  }\n\n  function extend(destination) {\n    var source;\n    for (var i = 1; i < arguments.length; i++) {\n      source = arguments[i];\n      for (var prop in source) {\n        if (has(source, prop)) {\n          destination[prop] = source[prop];\n        }\n      }\n    }\n    return destination;\n  }\n\n  // Internal helper function for Polish language.\n  function getPolishForm(c) {\n    if (c === 1) {\n      return 0;\n    } else if (Math.floor(c) !== c) {\n      return 1;\n    } else if (c % 10 >= 2 && c % 10 <= 4 && !(c % 100 > 10 && c % 100 < 20)) {\n      return 2;\n    } else {\n      return 3;\n    }\n  }\n\n  // Internal helper function for Russian and Ukranian languages.\n  function getSlavicForm(c) {\n    if (Math.floor(c) !== c) {\n      return 2;\n    } else if (\n      (c % 100 >= 5 && c % 100 <= 20) ||\n      (c % 10 >= 5 && c % 10 <= 9) ||\n      c % 10 === 0\n    ) {\n      return 0;\n    } else if (c % 10 === 1) {\n      return 1;\n    } else if (c > 1) {\n      return 2;\n    } else {\n      return 0;\n    }\n  }\n\n  // Internal helper function for Slovak language.\n  function getCzechOrSlovakForm(c) {\n    if (c === 1) {\n      return 0;\n    } else if (Math.floor(c) !== c) {\n      return 1;\n    } else if (c % 10 >= 2 && c % 10 <= 4 && c % 100 < 10) {\n      return 2;\n    } else {\n      return 3;\n    }\n  }\n\n  // Internal helper function for Lithuanian language.\n  function getLithuanianForm(c) {\n    if (c === 1 || (c % 10 === 1 && c % 100 > 20)) {\n      return 0;\n    } else if (\n      Math.floor(c) !== c ||\n      (c % 10 >= 2 && c % 100 > 20) ||\n      (c % 10 >= 2 && c % 100 < 10)\n    ) {\n      return 1;\n    } else {\n      return 2;\n    }\n  }\n\n  // Internal helper function for Latvian language.\n  function getLatvianForm(c) {\n    return c % 10 === 1 && c % 100 !== 11;\n  }\n\n  // We need to make sure we support browsers that don\'t have\n  // `Array.isArray`, so we define a fallback here.\n  var isArray =\n    Array.isArray ||\n    function (arg) {\n      return Object.prototype.toString.call(arg) === "[object Array]";\n    };\n\n  function has(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n  }\n\n  humanizeDuration.getSupportedLanguages = function getSupportedLanguages() {\n    var result = [];\n    for (var language in LANGUAGES) {\n      if (has(LANGUAGES, language) && language !== "gr") {\n        result.push(language);\n      }\n    }\n    return result;\n  };\n\n  humanizeDuration.humanizer = humanizer;\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return humanizeDuration;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(); // eslint-disable-line semi\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHVtYW5pemUtZHVyYXRpb24vaHVtYW5pemUtZHVyYXRpb24uanM/OGYxNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixnQ0FBZ0M7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlDQUFpQztBQUNwRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLG1CQUFtQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsU0FBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxNQUFNLElBQTBDO0FBQ2hELElBQUksbUNBQU87QUFDWDtBQUNBLEtBQUs7QUFBQSxvR0FBQztBQUNOLEdBQUcsTUFBTSxFQUlOO0FBQ0gsQ0FBQyxJQUFJIiwiZmlsZSI6IjQ2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSHVtYW5pemVEdXJhdGlvbi5qcyAtIGh0dHBzOi8vZ2l0LmlvL2owSGdtUVxuXG4vKiBnbG9iYWwgZGVmaW5lLCBtb2R1bGUgKi9cblxuKGZ1bmN0aW9uICgpIHtcbiAgLy8gVGhpcyBoYXMgdG8gYmUgZGVmaW5lZCBzZXBhcmF0ZWx5IGJlY2F1c2Ugb2YgYSBidWc6IHdlIHdhbnQgdG8gYWxpYXNcbiAgLy8gYGdyYCBhbmQgYGVsYCBmb3IgYmFja3dhcmRzLWNvbXBhdGlibGl0eS4gSW4gYSBicmVha2luZyBjaGFuZ2UsIHdlIGNhblxuICAvLyByZW1vdmUgYGdyYCBlbnRpcmVseS5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9FdmFuSGFobi9IdW1hbml6ZUR1cmF0aW9uLmpzL2lzc3Vlcy8xNDMgZm9yIG1vcmUuXG4gIHZhciBncmVlayA9IHtcbiAgICB5OiBmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMgPT09IDEgPyBcIs+Hz4HPjM69zr/PglwiIDogXCLPh8+Bz4zOvc65zrFcIjtcbiAgICB9LFxuICAgIG1vOiBmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMgPT09IDEgPyBcIs68zq7Ovc6xz4JcIiA6IFwizrzOrs69zrXPglwiO1xuICAgIH0sXG4gICAgdzogZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjID09PSAxID8gXCLOtc6yzrTOv868zqzOtM6xXCIgOiBcIs61zrLOtM6/zrzOrM60zrXPglwiO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjID09PSAxID8gXCLOvM6tz4HOsVwiIDogXCLOvM6tz4HOtc+CXCI7XG4gICAgfSxcbiAgICBoOiBmdW5jdGlvbiAoYykge1xuICAgICAgcmV0dXJuIGMgPT09IDEgPyBcIs+Oz4HOsVwiIDogXCLPjs+BzrXPglwiO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gKGMpIHtcbiAgICAgIHJldHVybiBjID09PSAxID8gXCLOu861z4DPhM+MXCIgOiBcIs67zrXPgM+EzqxcIjtcbiAgICB9LFxuICAgIHM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYyA9PT0gMSA/IFwizrTOtc+Fz4TOtc+Bz4zOu861z4DPhM6/XCIgOiBcIs60zrXPhc+EzrXPgc+MzrvOtc+Az4TOsVwiO1xuICAgIH0sXG4gICAgbXM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYyA9PT0gMVxuICAgICAgICA/IFwiz4fOuc67zrnOv8+Dz4TPjCDPhM6/z4UgzrTOtc+Fz4TOtc+Bzr/Ou86tz4DPhM6/z4VcIlxuICAgICAgICA6IFwiz4fOuc67zrnOv8+Dz4TOrCDPhM6/z4UgzrTOtc+Fz4TOtc+Bzr/Ou86tz4DPhM6/z4VcIjtcbiAgICB9LFxuICAgIGRlY2ltYWw6IFwiLFwiLFxuICB9O1xuXG4gIHZhciBMQU5HVUFHRVMgPSB7XG4gICAgYXI6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAxID8gXCLYs9mG2KlcIiA6IFwi2LPZhtmI2KfYqlwiO1xuICAgICAgfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gMSA/IFwi2LTZh9ixXCIgOiBcItij2LTZh9ixXCI7XG4gICAgICB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IDEgPyBcItij2LPYqNmI2LlcIiA6IFwi2KPYs9in2KjZiti5XCI7XG4gICAgICB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IDEgPyBcItmK2YjZhVwiIDogXCLYo9mK2KfZhVwiO1xuICAgICAgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAxID8gXCLYs9in2LnYqVwiIDogXCLYs9in2LnYp9iqXCI7XG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPiAyICYmIGMgPCAxMSA/IFwi2K/Zgtin2KbZglwiIDogXCLYr9mC2YrZgtipXCI7XG4gICAgICB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IDEgPyBcItir2KfZhtmK2KlcIiA6IFwi2KvZiNin2YbZilwiO1xuICAgICAgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gMSA/IFwi2KzYstihINmF2YYg2KfZhNir2KfZhtmK2KlcIiA6IFwi2KPYrNiy2KfYoSDZhdmGINin2YTYq9in2YbZitipXCI7XG4gICAgICB9LFxuICAgICAgZGVjaW1hbDogXCIsXCIsXG4gICAgfSxcbiAgICBiZzoge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcItCz0L7QtNC40L3QuFwiLCBcItCz0L7QtNC40L3QsFwiLCBcItCz0L7QtNC40L3QuFwiXVtnZXRTbGF2aWNGb3JtKGMpXTtcbiAgICAgIH0sXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcItC80LXRgdC10YbQsFwiLCBcItC80LXRgdC10YZcIiwgXCLQvNC10YHQtdGG0LBcIl1bZ2V0U2xhdmljRm9ybShjKV07XG4gICAgICB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcItGB0LXQtNC80LjRhtC4XCIsIFwi0YHQtdC00LzQuNGG0LBcIiwgXCLRgdC10LTQvNC40YbQuFwiXVtnZXRTbGF2aWNGb3JtKGMpXTtcbiAgICAgIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gW1wi0LTQvdC4XCIsIFwi0LTQtdC9XCIsIFwi0LTQvdC4XCJdW2dldFNsYXZpY0Zvcm0oYyldO1xuICAgICAgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBbXCLRh9Cw0YHQsFwiLCBcItGH0LDRgVwiLCBcItGH0LDRgdCwXCJdW2dldFNsYXZpY0Zvcm0oYyldO1xuICAgICAgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBbXCLQvNC40L3Rg9GC0LhcIiwgXCLQvNC40L3Rg9GC0LBcIiwgXCLQvNC40L3Rg9GC0LhcIl1bZ2V0U2xhdmljRm9ybShjKV07XG4gICAgICB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcItGB0LXQutGD0L3QtNC4XCIsIFwi0YHQtdC60YPQvdC00LBcIiwgXCLRgdC10LrRg9C90LTQuFwiXVtnZXRTbGF2aWNGb3JtKGMpXTtcbiAgICAgIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcItC80LjQu9C40YHQtdC60YPQvdC00LhcIiwgXCLQvNC40LvQuNGB0LXQutGD0L3QtNCwXCIsIFwi0LzQuNC70LjRgdC10LrRg9C90LTQuFwiXVtnZXRTbGF2aWNGb3JtKGMpXTtcbiAgICAgIH0sXG4gICAgICBkZWNpbWFsOiBcIixcIixcbiAgICB9LFxuICAgIGNhOiB7XG4gICAgICB5OiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJhbnlcIiArIChjID09PSAxID8gXCJcIiA6IFwic1wiKTtcbiAgICAgIH0sXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwibWVzXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcIm9zXCIpO1xuICAgICAgfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcInNldG1hblwiICsgKGMgPT09IDEgPyBcImFcIiA6IFwiZXNcIik7XG4gICAgICB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwiZGlcIiArIChjID09PSAxID8gXCJhXCIgOiBcImVzXCIpO1xuICAgICAgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcImhvclwiICsgKGMgPT09IDEgPyBcImFcIiA6IFwiZXNcIik7XG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwibWludXRcIiArIChjID09PSAxID8gXCJcIiA6IFwic1wiKTtcbiAgICAgIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJzZWdvblwiICsgKGMgPT09IDEgPyBcIlwiIDogXCJzXCIpO1xuICAgICAgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJtaWxpc2Vnb25cIiArIChjID09PSAxID8gXCJcIiA6IFwic1wiKTtcbiAgICAgIH0sXG4gICAgICBkZWNpbWFsOiBcIixcIixcbiAgICB9LFxuICAgIGNzOiB7XG4gICAgICB5OiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gW1wicm9rXCIsIFwicm9rdVwiLCBcInJva3lcIiwgXCJsZXRcIl1bZ2V0Q3plY2hPclNsb3Zha0Zvcm0oYyldO1xuICAgICAgfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gW1wibcSbc8OtY1wiLCBcIm3Em3PDrWNlXCIsIFwibcSbc8OtY2VcIiwgXCJtxJtzw61jxa9cIl1bZ2V0Q3plY2hPclNsb3Zha0Zvcm0oYyldO1xuICAgICAgfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBbXCJ0w71kZW5cIiwgXCJ0w71kbmVcIiwgXCJ0w71kbnlcIiwgXCJ0w71kbsWvXCJdW2dldEN6ZWNoT3JTbG92YWtGb3JtKGMpXTtcbiAgICAgIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gW1wiZGVuXCIsIFwiZG5lXCIsIFwiZG55XCIsIFwiZG7DrVwiXVtnZXRDemVjaE9yU2xvdmFrRm9ybShjKV07XG4gICAgICB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcImhvZGluYVwiLCBcImhvZGlueVwiLCBcImhvZGlueVwiLCBcImhvZGluXCJdW2dldEN6ZWNoT3JTbG92YWtGb3JtKGMpXTtcbiAgICAgIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gW1wibWludXRhXCIsIFwibWludXR5XCIsIFwibWludXR5XCIsIFwibWludXRcIl1bZ2V0Q3plY2hPclNsb3Zha0Zvcm0oYyldO1xuICAgICAgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBbXCJzZWt1bmRhXCIsIFwic2VrdW5keVwiLCBcInNla3VuZHlcIiwgXCJzZWt1bmRcIl1bXG4gICAgICAgICAgZ2V0Q3plY2hPclNsb3Zha0Zvcm0oYylcbiAgICAgICAgXTtcbiAgICAgIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcIm1pbGlzZWt1bmRhXCIsIFwibWlsaXNla3VuZHlcIiwgXCJtaWxpc2VrdW5keVwiLCBcIm1pbGlzZWt1bmRcIl1bXG4gICAgICAgICAgZ2V0Q3plY2hPclNsb3Zha0Zvcm0oYylcbiAgICAgICAgXTtcbiAgICAgIH0sXG4gICAgICBkZWNpbWFsOiBcIixcIixcbiAgICB9LFxuICAgIGRhOiB7XG4gICAgICB5OiBcIsOlclwiLFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcIm3DpW5lZFwiICsgKGMgPT09IDEgPyBcIlwiIDogXCJlclwiKTtcbiAgICAgIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJ1Z2VcIiArIChjID09PSAxID8gXCJcIiA6IFwiclwiKTtcbiAgICAgIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJkYWdcIiArIChjID09PSAxID8gXCJcIiA6IFwiZVwiKTtcbiAgICAgIH0sXG4gICAgICBoOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJ0aW1lXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcInJcIik7XG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwibWludXRcIiArIChjID09PSAxID8gXCJcIiA6IFwidGVyXCIpO1xuICAgICAgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcInNla3VuZFwiICsgKGMgPT09IDEgPyBcIlwiIDogXCJlclwiKTtcbiAgICAgIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwibWlsbGlzZWt1bmRcIiArIChjID09PSAxID8gXCJcIiA6IFwiZXJcIik7XG4gICAgICB9LFxuICAgICAgZGVjaW1hbDogXCIsXCIsXG4gICAgfSxcbiAgICBkZToge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwiSmFoclwiICsgKGMgPT09IDEgPyBcIlwiIDogXCJlXCIpO1xuICAgICAgfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJNb25hdFwiICsgKGMgPT09IDEgPyBcIlwiIDogXCJlXCIpO1xuICAgICAgfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcIldvY2hlXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcIm5cIik7XG4gICAgICB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwiVGFnXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcImVcIik7XG4gICAgICB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwiU3R1bmRlXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcIm5cIik7XG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwiTWludXRlXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcIm5cIik7XG4gICAgICB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwiU2VrdW5kZVwiICsgKGMgPT09IDEgPyBcIlwiIDogXCJuXCIpO1xuICAgICAgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJNaWxsaXNla3VuZGVcIiArIChjID09PSAxID8gXCJcIiA6IFwiblwiKTtcbiAgICAgIH0sXG4gICAgICBkZWNpbWFsOiBcIixcIixcbiAgICB9LFxuICAgIGVsOiBncmVlayxcbiAgICBlbjoge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwieWVhclwiICsgKGMgPT09IDEgPyBcIlwiIDogXCJzXCIpO1xuICAgICAgfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJtb250aFwiICsgKGMgPT09IDEgPyBcIlwiIDogXCJzXCIpO1xuICAgICAgfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcIndlZWtcIiArIChjID09PSAxID8gXCJcIiA6IFwic1wiKTtcbiAgICAgIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJkYXlcIiArIChjID09PSAxID8gXCJcIiA6IFwic1wiKTtcbiAgICAgIH0sXG4gICAgICBoOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJob3VyXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcInNcIik7XG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwibWludXRlXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcInNcIik7XG4gICAgICB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwic2Vjb25kXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcInNcIik7XG4gICAgICB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcIm1pbGxpc2Vjb25kXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcInNcIik7XG4gICAgICB9LFxuICAgICAgZGVjaW1hbDogXCIuXCIsXG4gICAgfSxcbiAgICBlczoge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwiYcOxb1wiICsgKGMgPT09IDEgPyBcIlwiIDogXCJzXCIpO1xuICAgICAgfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJtZXNcIiArIChjID09PSAxID8gXCJcIiA6IFwiZXNcIik7XG4gICAgICB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwic2VtYW5hXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcInNcIik7XG4gICAgICB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwiZMOtYVwiICsgKGMgPT09IDEgPyBcIlwiIDogXCJzXCIpO1xuICAgICAgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcImhvcmFcIiArIChjID09PSAxID8gXCJcIiA6IFwic1wiKTtcbiAgICAgIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJtaW51dG9cIiArIChjID09PSAxID8gXCJcIiA6IFwic1wiKTtcbiAgICAgIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJzZWd1bmRvXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcInNcIik7XG4gICAgICB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcIm1pbGlzZWd1bmRvXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcInNcIik7XG4gICAgICB9LFxuICAgICAgZGVjaW1hbDogXCIsXCIsXG4gICAgfSxcbiAgICBldDoge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwiYWFzdGFcIiArIChjID09PSAxID8gXCJcIiA6IFwidFwiKTtcbiAgICAgIH0sXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwia3V1XCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcImRcIik7XG4gICAgICB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwibsOkZGFsXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcImF0XCIpO1xuICAgICAgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcInDDpGV2XCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcImFcIik7XG4gICAgICB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwidHVuZFwiICsgKGMgPT09IDEgPyBcIlwiIDogXCJpXCIpO1xuICAgICAgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcIm1pbnV0XCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcIml0XCIpO1xuICAgICAgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcInNla3VuZFwiICsgKGMgPT09IDEgPyBcIlwiIDogXCJpdFwiKTtcbiAgICAgIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwibWlsbGlzZWt1bmRcIiArIChjID09PSAxID8gXCJcIiA6IFwiaXRcIik7XG4gICAgICB9LFxuICAgICAgZGVjaW1hbDogXCIsXCIsXG4gICAgfSxcbiAgICBmYToge1xuICAgICAgeTogXCLYs9in2YRcIixcbiAgICAgIG1vOiBcItmF2KfZh1wiLFxuICAgICAgdzogXCLZh9mB2KrZh1wiLFxuICAgICAgZDogXCLYsdmI2LJcIixcbiAgICAgIGg6IFwi2LPYp9i52KpcIixcbiAgICAgIG06IFwi2K/ZgtuM2YLZh1wiLFxuICAgICAgczogXCLYq9in2YbbjNmHXCIsXG4gICAgICBtczogXCLZhduM2YTbjCDYq9in2YbbjNmHXCIsXG4gICAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB9LFxuICAgIGZpOiB7XG4gICAgICB5OiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gMSA/IFwidnVvc2lcIiA6IFwidnVvdHRhXCI7XG4gICAgICB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAxID8gXCJrdXVrYXVzaVwiIDogXCJrdXVrYXV0dGFcIjtcbiAgICAgIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJ2aWlra29cIiArIChjID09PSAxID8gXCJcIiA6IFwiYVwiKTtcbiAgICAgIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJww6RpdsOkXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcIsOkXCIpO1xuICAgICAgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcInR1bnRpXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcImFcIik7XG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwibWludXV0dGlcIiArIChjID09PSAxID8gXCJcIiA6IFwiYVwiKTtcbiAgICAgIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJzZWt1bnRpXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcImFcIik7XG4gICAgICB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcIm1pbGxpc2VrdW50aVwiICsgKGMgPT09IDEgPyBcIlwiIDogXCJhXCIpO1xuICAgICAgfSxcbiAgICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIH0sXG4gICAgZm86IHtcbiAgICAgIHk6IFwiw6FyXCIsXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IDEgPyBcIm3DoW5hw7B1clwiIDogXCJtw6FuYcOwaXJcIjtcbiAgICAgIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gMSA/IFwidmlrYVwiIDogXCJ2aWt1clwiO1xuICAgICAgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAxID8gXCJkYWd1clwiIDogXCJkYWdhclwiO1xuICAgICAgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAxID8gXCJ0w61taVwiIDogXCJ0w61tYXJcIjtcbiAgICAgIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gMSA/IFwibWludXR0dXJcIiA6IFwibWludXR0aXJcIjtcbiAgICAgIH0sXG4gICAgICBzOiBcInNla3VuZFwiLFxuICAgICAgbXM6IFwibWlsbGlzZWt1bmRcIixcbiAgICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIH0sXG4gICAgZnI6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcImFuXCIgKyAoYyA+PSAyID8gXCJzXCIgOiBcIlwiKTtcbiAgICAgIH0sXG4gICAgICBtbzogXCJtb2lzXCIsXG4gICAgICB3OiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJzZW1haW5lXCIgKyAoYyA+PSAyID8gXCJzXCIgOiBcIlwiKTtcbiAgICAgIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJqb3VyXCIgKyAoYyA+PSAyID8gXCJzXCIgOiBcIlwiKTtcbiAgICAgIH0sXG4gICAgICBoOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJoZXVyZVwiICsgKGMgPj0gMiA/IFwic1wiIDogXCJcIik7XG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwibWludXRlXCIgKyAoYyA+PSAyID8gXCJzXCIgOiBcIlwiKTtcbiAgICAgIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJzZWNvbmRlXCIgKyAoYyA+PSAyID8gXCJzXCIgOiBcIlwiKTtcbiAgICAgIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwibWlsbGlzZWNvbmRlXCIgKyAoYyA+PSAyID8gXCJzXCIgOiBcIlwiKTtcbiAgICAgIH0sXG4gICAgICBkZWNpbWFsOiBcIixcIixcbiAgICB9LFxuICAgIGdyOiBncmVlayxcbiAgICBoZToge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IDEgPyBcItep16DXlFwiIDogXCLXqdeg15nXnVwiO1xuICAgICAgfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gMSA/IFwi15fXldeT16lcIiA6IFwi15fXldeT16nXmdedXCI7XG4gICAgICB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IDEgPyBcItep15HXldeiXCIgOiBcItep15HXldei15XXqlwiO1xuICAgICAgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAxID8gXCLXmdeV151cIiA6IFwi15nXnteZ151cIjtcbiAgICAgIH0sXG4gICAgICBoOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gMSA/IFwi16nXoteUXCIgOiBcItep16LXldeqXCI7XG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IDEgPyBcIteT16fXlFwiIDogXCLXk9en15XXqlwiO1xuICAgICAgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAxID8gXCLXqdeg15nXlFwiIDogXCLXqdeg15nXldeqXCI7XG4gICAgICB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAxID8gXCLXnteZ15zXmdep16DXmdeZ15RcIiA6IFwi157Xmdec15nXqdeg15nXldeqXCI7XG4gICAgICB9LFxuICAgICAgZGVjaW1hbDogXCIuXCIsXG4gICAgfSxcbiAgICBocjoge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMgJSAxMCA9PT0gMiB8fCBjICUgMTAgPT09IDMgfHwgYyAlIDEwID09PSA0KSB7XG4gICAgICAgICAgcmV0dXJuIFwiZ29kaW5lXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiZ29kaW5hXCI7XG4gICAgICB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIFwibWplc2VjXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoYyA9PT0gMiB8fCBjID09PSAzIHx8IGMgPT09IDQpIHtcbiAgICAgICAgICByZXR1cm4gXCJtamVzZWNhXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwibWplc2VjaVwiO1xuICAgICAgfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjICUgMTAgPT09IDEgJiYgYyAhPT0gMTEpIHtcbiAgICAgICAgICByZXR1cm4gXCJ0amVkYW5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJ0amVkbmFcIjtcbiAgICAgIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gMSA/IFwiZGFuXCIgOiBcImRhbmFcIjtcbiAgICAgIH0sXG4gICAgICBoOiBmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYyA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBcInNhdFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGMgPT09IDIgfHwgYyA9PT0gMyB8fCBjID09PSA0KSB7XG4gICAgICAgICAgcmV0dXJuIFwic2F0YVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcInNhdGlcIjtcbiAgICAgIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykge1xuICAgICAgICB2YXIgbW9kMTAgPSBjICUgMTA7XG4gICAgICAgIGlmICgobW9kMTAgPT09IDIgfHwgbW9kMTAgPT09IDMgfHwgbW9kMTAgPT09IDQpICYmIChjIDwgMTAgfHwgYyA+IDE0KSkge1xuICAgICAgICAgIHJldHVybiBcIm1pbnV0ZVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIm1pbnV0YVwiO1xuICAgICAgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjID09PSAxMCB8fFxuICAgICAgICAgIGMgPT09IDExIHx8XG4gICAgICAgICAgYyA9PT0gMTIgfHxcbiAgICAgICAgICBjID09PSAxMyB8fFxuICAgICAgICAgIGMgPT09IDE0IHx8XG4gICAgICAgICAgYyA9PT0gMTYgfHxcbiAgICAgICAgICBjID09PSAxNyB8fFxuICAgICAgICAgIGMgPT09IDE4IHx8XG4gICAgICAgICAgYyA9PT0gMTkgfHxcbiAgICAgICAgICBjICUgMTAgPT09IDVcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIFwic2VrdW5kaVwiO1xuICAgICAgICB9IGVsc2UgaWYgKGMgJSAxMCA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBcInNla3VuZGFcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjICUgMTAgPT09IDIgfHwgYyAlIDEwID09PSAzIHx8IGMgJSAxMCA9PT0gNCkge1xuICAgICAgICAgIHJldHVybiBcInNla3VuZGVcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJzZWt1bmRpXCI7XG4gICAgICB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIFwibWlsaXNla3VuZGFcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjICUgMTAgPT09IDIgfHwgYyAlIDEwID09PSAzIHx8IGMgJSAxMCA9PT0gNCkge1xuICAgICAgICAgIHJldHVybiBcIm1pbGlzZWt1bmRlXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwibWlsaXNla3VuZGlcIjtcbiAgICAgIH0sXG4gICAgICBkZWNpbWFsOiBcIixcIixcbiAgICB9LFxuICAgIGh1OiB7XG4gICAgICB5OiBcIsOpdlwiLFxuICAgICAgbW86IFwiaMOzbmFwXCIsXG4gICAgICB3OiBcImjDqXRcIixcbiAgICAgIGQ6IFwibmFwXCIsXG4gICAgICBoOiBcIsOzcmFcIixcbiAgICAgIG06IFwicGVyY1wiLFxuICAgICAgczogXCJtw6Fzb2RwZXJjXCIsXG4gICAgICBtczogXCJlenJlZG3DoXNvZHBlcmNcIixcbiAgICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIH0sXG4gICAgaWQ6IHtcbiAgICAgIHk6IFwidGFodW5cIixcbiAgICAgIG1vOiBcImJ1bGFuXCIsXG4gICAgICB3OiBcIm1pbmdndVwiLFxuICAgICAgZDogXCJoYXJpXCIsXG4gICAgICBoOiBcImphbVwiLFxuICAgICAgbTogXCJtZW5pdFwiLFxuICAgICAgczogXCJkZXRpa1wiLFxuICAgICAgbXM6IFwibWlsaWRldGlrXCIsXG4gICAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB9LFxuICAgIGlzOiB7XG4gICAgICB5OiBcIsOhclwiLFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcIm3DoW51w7BcIiArIChjID09PSAxID8gXCJ1clwiIDogXCJpclwiKTtcbiAgICAgIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJ2aWtcIiArIChjID09PSAxID8gXCJhXCIgOiBcInVyXCIpO1xuICAgICAgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcImRhZ1wiICsgKGMgPT09IDEgPyBcInVyXCIgOiBcImFyXCIpO1xuICAgICAgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcImtsdWtrdXTDrW1cIiArIChjID09PSAxID8gXCJpXCIgOiBcImFyXCIpO1xuICAgICAgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcIm3DrW7DunRcIiArIChjID09PSAxID8gXCJhXCIgOiBcInVyXCIpO1xuICAgICAgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcInNla8O6bmRcIiArIChjID09PSAxID8gXCJhXCIgOiBcInVyXCIpO1xuICAgICAgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJtaWxsaXNla8O6bmRcIiArIChjID09PSAxID8gXCJhXCIgOiBcInVyXCIpO1xuICAgICAgfSxcbiAgICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIH0sXG4gICAgaXQ6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcImFublwiICsgKGMgPT09IDEgPyBcIm9cIiA6IFwiaVwiKTtcbiAgICAgIH0sXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwibWVzXCIgKyAoYyA9PT0gMSA/IFwiZVwiIDogXCJpXCIpO1xuICAgICAgfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcInNldHRpbWFuXCIgKyAoYyA9PT0gMSA/IFwiYVwiIDogXCJlXCIpO1xuICAgICAgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcImdpb3JuXCIgKyAoYyA9PT0gMSA/IFwib1wiIDogXCJpXCIpO1xuICAgICAgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcIm9yXCIgKyAoYyA9PT0gMSA/IFwiYVwiIDogXCJlXCIpO1xuICAgICAgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcIm1pbnV0XCIgKyAoYyA9PT0gMSA/IFwib1wiIDogXCJpXCIpO1xuICAgICAgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcInNlY29uZFwiICsgKGMgPT09IDEgPyBcIm9cIiA6IFwiaVwiKTtcbiAgICAgIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwibWlsbGlzZWNvbmRcIiArIChjID09PSAxID8gXCJvXCIgOiBcImlcIik7XG4gICAgICB9LFxuICAgICAgZGVjaW1hbDogXCIsXCIsXG4gICAgfSxcbiAgICBqYToge1xuICAgICAgeTogXCLlubRcIixcbiAgICAgIG1vOiBcIuaciFwiLFxuICAgICAgdzogXCLpgLFcIixcbiAgICAgIGQ6IFwi5pelXCIsXG4gICAgICBoOiBcIuaZgumWk1wiLFxuICAgICAgbTogXCLliIZcIixcbiAgICAgIHM6IFwi56eSXCIsXG4gICAgICBtczogXCLjg5/jg6rnp5JcIixcbiAgICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIH0sXG4gICAga286IHtcbiAgICAgIHk6IFwi64WEXCIsXG4gICAgICBtbzogXCLqsJzsm5RcIixcbiAgICAgIHc6IFwi7KO87J28XCIsXG4gICAgICBkOiBcIuydvFwiLFxuICAgICAgaDogXCLsi5zqsIRcIixcbiAgICAgIG06IFwi67aEXCIsXG4gICAgICBzOiBcIuy0iFwiLFxuICAgICAgbXM6IFwi67CA66asIOy0iFwiLFxuICAgICAgZGVjaW1hbDogXCIuXCIsXG4gICAgfSxcbiAgICBsbzoge1xuICAgICAgeTogXCLgupvgurVcIixcbiAgICAgIG1vOiBcIuC7gOC6lOC6t+C6reC6mVwiLFxuICAgICAgdzogXCLguq3gurLgupfgurTgupRcIixcbiAgICAgIGQ6IFwi4Lqh4Lq34LuJXCIsXG4gICAgICBoOiBcIuC6iuC6u+C7iOC6p+C7guC6oeC6h1wiLFxuICAgICAgbTogXCLgupngurLgupfgurVcIixcbiAgICAgIHM6IFwi4Lqn4Lq04LqZ4Lqy4LqX4Lq1XCIsXG4gICAgICBtczogXCLguqHgurTgupnguqXgurTguqfgurTgupngurLgupfgurVcIixcbiAgICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIH0sXG4gICAgbHQ6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjICUgMTAgPT09IDAgfHwgKGMgJSAxMDAgPj0gMTAgJiYgYyAlIDEwMCA8PSAyMClcbiAgICAgICAgICA/IFwibWV0xbNcIlxuICAgICAgICAgIDogXCJtZXRhaVwiO1xuICAgICAgfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gW1wibcSXbnVvXCIsIFwibcSXbmVzaWFpXCIsIFwibcSXbmVzacWzXCJdW2dldExpdGh1YW5pYW5Gb3JtKGMpXTtcbiAgICAgIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gW1wic2F2YWl0xJdcIiwgXCJzYXZhaXTEl3NcIiwgXCJzYXZhacSNacWzXCJdW2dldExpdGh1YW5pYW5Gb3JtKGMpXTtcbiAgICAgIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gW1wiZGllbmFcIiwgXCJkaWVub3NcIiwgXCJkaWVuxbNcIl1bZ2V0TGl0aHVhbmlhbkZvcm0oYyldO1xuICAgICAgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBbXCJ2YWxhbmRhXCIsIFwidmFsYW5kb3NcIiwgXCJ2YWxhbmTFs1wiXVtnZXRMaXRodWFuaWFuRm9ybShjKV07XG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcIm1pbnV0xJdcIiwgXCJtaW51dMSXc1wiLCBcIm1pbnXEjWnFs1wiXVtnZXRMaXRodWFuaWFuRm9ybShjKV07XG4gICAgICB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcInNla3VuZMSXXCIsIFwic2VrdW5kxJdzXCIsIFwic2VrdW5kxb5pxbNcIl1bZ2V0TGl0aHVhbmlhbkZvcm0oYyldO1xuICAgICAgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gW1wibWlsaXNla3VuZMSXXCIsIFwibWlsaXNla3VuZMSXc1wiLCBcIm1pbGlzZWt1bmTFvmnFs1wiXVtcbiAgICAgICAgICBnZXRMaXRodWFuaWFuRm9ybShjKVxuICAgICAgICBdO1xuICAgICAgfSxcbiAgICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIH0sXG4gICAgbHY6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBnZXRMYXR2aWFuRm9ybShjKSA/IFwiZ2Fkc1wiIDogXCJnYWRpXCI7XG4gICAgICB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBnZXRMYXR2aWFuRm9ybShjKSA/IFwibcSTbmVzaXNcIiA6IFwibcSTbmXFoWlcIjtcbiAgICAgIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gZ2V0TGF0dmlhbkZvcm0oYykgPyBcIm5lZMSTxLxhXCIgOiBcIm5lZMSTxLxhc1wiO1xuICAgICAgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBnZXRMYXR2aWFuRm9ybShjKSA/IFwiZGllbmFcIiA6IFwiZGllbmFzXCI7XG4gICAgICB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGdldExhdHZpYW5Gb3JtKGMpID8gXCJzdHVuZGFcIiA6IFwic3R1bmRhc1wiO1xuICAgICAgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBnZXRMYXR2aWFuRm9ybShjKSA/IFwibWluxat0ZVwiIDogXCJtaW7Fq3Rlc1wiO1xuICAgICAgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBnZXRMYXR2aWFuRm9ybShjKSA/IFwic2VrdW5kZVwiIDogXCJzZWt1bmRlc1wiO1xuICAgICAgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gZ2V0TGF0dmlhbkZvcm0oYykgPyBcIm1pbGlzZWt1bmRlXCIgOiBcIm1pbGlzZWt1bmRlc1wiO1xuICAgICAgfSxcbiAgICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIH0sXG4gICAgbXM6IHtcbiAgICAgIHk6IFwidGFodW5cIixcbiAgICAgIG1vOiBcImJ1bGFuXCIsXG4gICAgICB3OiBcIm1pbmdndVwiLFxuICAgICAgZDogXCJoYXJpXCIsXG4gICAgICBoOiBcImphbVwiLFxuICAgICAgbTogXCJtaW5pdFwiLFxuICAgICAgczogXCJzYWF0XCIsXG4gICAgICBtczogXCJtaWxpc2FhdFwiLFxuICAgICAgZGVjaW1hbDogXCIuXCIsXG4gICAgfSxcbiAgICBubDoge1xuICAgICAgeTogXCJqYWFyXCIsXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IDEgPyBcIm1hYW5kXCIgOiBcIm1hYW5kZW5cIjtcbiAgICAgIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gMSA/IFwid2Vla1wiIDogXCJ3ZWtlblwiO1xuICAgICAgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAxID8gXCJkYWdcIiA6IFwiZGFnZW5cIjtcbiAgICAgIH0sXG4gICAgICBoOiBcInV1clwiLFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IDEgPyBcIm1pbnV1dFwiIDogXCJtaW51dGVuXCI7XG4gICAgICB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IDEgPyBcInNlY29uZGVcIiA6IFwic2Vjb25kZW5cIjtcbiAgICAgIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IDEgPyBcIm1pbGxpc2Vjb25kZVwiIDogXCJtaWxsaXNlY29uZGVuXCI7XG4gICAgICB9LFxuICAgICAgZGVjaW1hbDogXCIsXCIsXG4gICAgfSxcbiAgICBubzoge1xuICAgICAgeTogXCLDpXJcIixcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJtw6VuZWRcIiArIChjID09PSAxID8gXCJcIiA6IFwiZXJcIik7XG4gICAgICB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwidWtlXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcInJcIik7XG4gICAgICB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwiZGFnXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcImVyXCIpO1xuICAgICAgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcInRpbWVcIiArIChjID09PSAxID8gXCJcIiA6IFwiclwiKTtcbiAgICAgIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJtaW51dHRcIiArIChjID09PSAxID8gXCJcIiA6IFwiZXJcIik7XG4gICAgICB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwic2VrdW5kXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcImVyXCIpO1xuICAgICAgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJtaWxsaXNla3VuZFwiICsgKGMgPT09IDEgPyBcIlwiIDogXCJlclwiKTtcbiAgICAgIH0sXG4gICAgICBkZWNpbWFsOiBcIixcIixcbiAgICB9LFxuICAgIHBsOiB7XG4gICAgICB5OiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gW1wicm9rXCIsIFwicm9rdVwiLCBcImxhdGFcIiwgXCJsYXRcIl1bZ2V0UG9saXNoRm9ybShjKV07XG4gICAgICB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBbXCJtaWVzacSFY1wiLCBcIm1pZXNpxIVjYVwiLCBcIm1pZXNpxIVjZVwiLCBcIm1pZXNpxJljeVwiXVtcbiAgICAgICAgICBnZXRQb2xpc2hGb3JtKGMpXG4gICAgICAgIF07XG4gICAgICB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcInR5ZHppZcWEXCIsIFwidHlnb2RuaWFcIiwgXCJ0eWdvZG5pZVwiLCBcInR5Z29kbmlcIl1bZ2V0UG9saXNoRm9ybShjKV07XG4gICAgICB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcImR6aWXFhFwiLCBcImRuaWFcIiwgXCJkbmlcIiwgXCJkbmlcIl1bZ2V0UG9saXNoRm9ybShjKV07XG4gICAgICB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcImdvZHppbmFcIiwgXCJnb2R6aW55XCIsIFwiZ29kemlueVwiLCBcImdvZHppblwiXVtnZXRQb2xpc2hGb3JtKGMpXTtcbiAgICAgIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gW1wibWludXRhXCIsIFwibWludXR5XCIsIFwibWludXR5XCIsIFwibWludXRcIl1bZ2V0UG9saXNoRm9ybShjKV07XG4gICAgICB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcInNla3VuZGFcIiwgXCJzZWt1bmR5XCIsIFwic2VrdW5keVwiLCBcInNla3VuZFwiXVtnZXRQb2xpc2hGb3JtKGMpXTtcbiAgICAgIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcIm1pbGlzZWt1bmRhXCIsIFwibWlsaXNla3VuZHlcIiwgXCJtaWxpc2VrdW5keVwiLCBcIm1pbGlzZWt1bmRcIl1bXG4gICAgICAgICAgZ2V0UG9saXNoRm9ybShjKVxuICAgICAgICBdO1xuICAgICAgfSxcbiAgICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIH0sXG4gICAgcHQ6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcImFub1wiICsgKGMgPT09IDEgPyBcIlwiIDogXCJzXCIpO1xuICAgICAgfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gMSA/IFwibcOqc1wiIDogXCJtZXNlc1wiO1xuICAgICAgfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcInNlbWFuYVwiICsgKGMgPT09IDEgPyBcIlwiIDogXCJzXCIpO1xuICAgICAgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcImRpYVwiICsgKGMgPT09IDEgPyBcIlwiIDogXCJzXCIpO1xuICAgICAgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcImhvcmFcIiArIChjID09PSAxID8gXCJcIiA6IFwic1wiKTtcbiAgICAgIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJtaW51dG9cIiArIChjID09PSAxID8gXCJcIiA6IFwic1wiKTtcbiAgICAgIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJzZWd1bmRvXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcInNcIik7XG4gICAgICB9LFxuICAgICAgbXM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcIm1pbGlzc2VndW5kb1wiICsgKGMgPT09IDEgPyBcIlwiIDogXCJzXCIpO1xuICAgICAgfSxcbiAgICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIH0sXG4gICAgcm86IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAxID8gXCJhblwiIDogXCJhbmlcIjtcbiAgICAgIH0sXG4gICAgICBtbzogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IDEgPyBcImx1bsSDXCIgOiBcImx1bmlcIjtcbiAgICAgIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gMSA/IFwic8SDcHTEg23Dom7Eg1wiIDogXCJzxINwdMSDbcOibmlcIjtcbiAgICAgIH0sXG4gICAgICBkOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gMSA/IFwiemlcIiA6IFwiemlsZVwiO1xuICAgICAgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAxID8gXCJvcsSDXCIgOiBcIm9yZVwiO1xuICAgICAgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAxID8gXCJtaW51dFwiIDogXCJtaW51dGVcIjtcbiAgICAgIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gMSA/IFwic2VjdW5kxINcIiA6IFwic2VjdW5kZVwiO1xuICAgICAgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gMSA/IFwibWlsaXNlY3VuZMSDXCIgOiBcIm1pbGlzZWN1bmRlXCI7XG4gICAgICB9LFxuICAgICAgZGVjaW1hbDogXCIsXCIsXG4gICAgfSxcbiAgICBydToge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcItC70LXRglwiLCBcItCz0L7QtFwiLCBcItCz0L7QtNCwXCJdW2dldFNsYXZpY0Zvcm0oYyldO1xuICAgICAgfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gW1wi0LzQtdGB0Y/RhtC10LJcIiwgXCLQvNC10YHRj9GGXCIsIFwi0LzQtdGB0Y/RhtCwXCJdW2dldFNsYXZpY0Zvcm0oYyldO1xuICAgICAgfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBbXCLQvdC10LTQtdC70YxcIiwgXCLQvdC10LTQtdC70Y9cIiwgXCLQvdC10LTQtdC70LhcIl1bZ2V0U2xhdmljRm9ybShjKV07XG4gICAgICB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcItC00L3QtdC5XCIsIFwi0LTQtdC90YxcIiwgXCLQtNC90Y9cIl1bZ2V0U2xhdmljRm9ybShjKV07XG4gICAgICB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcItGH0LDRgdC+0LJcIiwgXCLRh9Cw0YFcIiwgXCLRh9Cw0YHQsFwiXVtnZXRTbGF2aWNGb3JtKGMpXTtcbiAgICAgIH0sXG4gICAgICBtOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gW1wi0LzQuNC90YPRglwiLCBcItC80LjQvdGD0YLQsFwiLCBcItC80LjQvdGD0YLRi1wiXVtnZXRTbGF2aWNGb3JtKGMpXTtcbiAgICAgIH0sXG4gICAgICBzOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gW1wi0YHQtdC60YPQvdC0XCIsIFwi0YHQtdC60YPQvdC00LBcIiwgXCLRgdC10LrRg9C90LTRi1wiXVtnZXRTbGF2aWNGb3JtKGMpXTtcbiAgICAgIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcItC80LjQu9C70LjRgdC10LrRg9C90LRcIiwgXCLQvNC40LvQu9C40YHQtdC60YPQvdC00LBcIiwgXCLQvNC40LvQu9C40YHQtdC60YPQvdC00YtcIl1bXG4gICAgICAgICAgZ2V0U2xhdmljRm9ybShjKVxuICAgICAgICBdO1xuICAgICAgfSxcbiAgICAgIGRlY2ltYWw6IFwiLFwiLFxuICAgIH0sXG4gICAgdWs6IHtcbiAgICAgIHk6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBbXCLRgNC+0LrRltCyXCIsIFwi0YDRltC6XCIsIFwi0YDQvtC60LhcIl1bZ2V0U2xhdmljRm9ybShjKV07XG4gICAgICB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBbXCLQvNGW0YHRj9GG0ZbQslwiLCBcItC80ZbRgdGP0YbRjFwiLCBcItC80ZbRgdGP0YbRllwiXVtnZXRTbGF2aWNGb3JtKGMpXTtcbiAgICAgIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gW1wi0YLQuNC20L3RltCyXCIsIFwi0YLQuNC20LTQtdC90YxcIiwgXCLRgtC40LbQvdGWXCJdW2dldFNsYXZpY0Zvcm0oYyldO1xuICAgICAgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBbXCLQtNC90ZbQslwiLCBcItC00LXQvdGMXCIsIFwi0LTQvdGWXCJdW2dldFNsYXZpY0Zvcm0oYyldO1xuICAgICAgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBbXCLQs9C+0LTQuNC9XCIsIFwi0LPQvtC00LjQvdCwXCIsIFwi0LPQvtC00LjQvdC4XCJdW2dldFNsYXZpY0Zvcm0oYyldO1xuICAgICAgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBbXCLRhdCy0LjQu9C40L1cIiwgXCLRhdCy0LjQu9C40L3QsFwiLCBcItGF0LLQuNC70LjQvdC4XCJdW2dldFNsYXZpY0Zvcm0oYyldO1xuICAgICAgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBbXCLRgdC10LrRg9C90LRcIiwgXCLRgdC10LrRg9C90LTQsFwiLCBcItGB0LXQutGD0L3QtNC4XCJdW2dldFNsYXZpY0Zvcm0oYyldO1xuICAgICAgfSxcbiAgICAgIG1zOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gW1wi0LzRltC70ZbRgdC10LrRg9C90LRcIiwgXCLQvNGW0LvRltGB0LXQutGD0L3QtNCwXCIsIFwi0LzRltC70ZbRgdC10LrRg9C90LTQuFwiXVtnZXRTbGF2aWNGb3JtKGMpXTtcbiAgICAgIH0sXG4gICAgICBkZWNpbWFsOiBcIixcIixcbiAgICB9LFxuICAgIHVyOiB7XG4gICAgICB5OiBcItiz2KfZhFwiLFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAxID8gXCLZhduB24zZhtuBXCIgOiBcItmF24HbjNmG25JcIjtcbiAgICAgIH0sXG4gICAgICB3OiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYyA9PT0gMSA/IFwi24HZgdiq24FcIiA6IFwi24HZgdiq25JcIjtcbiAgICAgIH0sXG4gICAgICBkOiBcItiv2YZcIixcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAxID8gXCLar9q+2YbZuduBXCIgOiBcItqv2r7Zhtm525JcIjtcbiAgICAgIH0sXG4gICAgICBtOiBcItmF2YbZuVwiLFxuICAgICAgczogXCLYs9uM2qnZhtqIXCIsXG4gICAgICBtczogXCLZhdmE24wg2LPbjNqp2YbaiFwiLFxuICAgICAgZGVjaW1hbDogXCIuXCIsXG4gICAgfSxcbiAgICBzazoge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcInJva1wiLCBcInJva3lcIiwgXCJyb2t5XCIsIFwicm9rb3ZcIl1bZ2V0Q3plY2hPclNsb3Zha0Zvcm0oYyldO1xuICAgICAgfSxcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gW1wibWVzaWFjXCIsIFwibWVzaWFjZVwiLCBcIm1lc2lhY2VcIiwgXCJtZXNpYWNvdlwiXVtcbiAgICAgICAgICBnZXRDemVjaE9yU2xvdmFrRm9ybShjKVxuICAgICAgICBdO1xuICAgICAgfSxcbiAgICAgIHc6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBbXCJ0w73FvmRlxYhcIiwgXCJ0w73FvmRuZVwiLCBcInTDvcW+ZG5lXCIsIFwidMO9xb5kxYhvdlwiXVtcbiAgICAgICAgICBnZXRDemVjaE9yU2xvdmFrRm9ybShjKVxuICAgICAgICBdO1xuICAgICAgfSxcbiAgICAgIGQ6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBbXCJkZcWIXCIsIFwiZG5pXCIsIFwiZG5pXCIsIFwiZG7DrVwiXVtnZXRDemVjaE9yU2xvdmFrRm9ybShjKV07XG4gICAgICB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcImhvZGluYVwiLCBcImhvZGlueVwiLCBcImhvZGlueVwiLCBcImhvZMOtblwiXVtnZXRDemVjaE9yU2xvdmFrRm9ybShjKV07XG4gICAgICB9LFxuICAgICAgbTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcIm1pbsO6dGFcIiwgXCJtaW7DunR5XCIsIFwibWluw7p0eVwiLCBcIm1pbsO6dFwiXVtnZXRDemVjaE9yU2xvdmFrRm9ybShjKV07XG4gICAgICB9LFxuICAgICAgczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcInNla3VuZGFcIiwgXCJzZWt1bmR5XCIsIFwic2VrdW5keVwiLCBcInNla8O6bmRcIl1bXG4gICAgICAgICAgZ2V0Q3plY2hPclNsb3Zha0Zvcm0oYylcbiAgICAgICAgXTtcbiAgICAgIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFtcIm1pbGlzZWt1bmRhXCIsIFwibWlsaXNla3VuZHlcIiwgXCJtaWxpc2VrdW5keVwiLCBcIm1pbGlzZWvDum5kXCJdW1xuICAgICAgICAgIGdldEN6ZWNoT3JTbG92YWtGb3JtKGMpXG4gICAgICAgIF07XG4gICAgICB9LFxuICAgICAgZGVjaW1hbDogXCIsXCIsXG4gICAgfSxcbiAgICBzdjoge1xuICAgICAgeTogXCLDpXJcIixcbiAgICAgIG1vOiBmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gXCJtw6VuYWRcIiArIChjID09PSAxID8gXCJcIiA6IFwiZXJcIik7XG4gICAgICB9LFxuICAgICAgdzogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwidmVja1wiICsgKGMgPT09IDEgPyBcImFcIiA6IFwib3JcIik7XG4gICAgICB9LFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwiZGFnXCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcImFyXCIpO1xuICAgICAgfSxcbiAgICAgIGg6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcInRpbW1cIiArIChjID09PSAxID8gXCJlXCIgOiBcImFyXCIpO1xuICAgICAgfSxcbiAgICAgIG06IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcIm1pbnV0XCIgKyAoYyA9PT0gMSA/IFwiXCIgOiBcImVyXCIpO1xuICAgICAgfSxcbiAgICAgIHM6IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBcInNla3VuZFwiICsgKGMgPT09IDEgPyBcIlwiIDogXCJlclwiKTtcbiAgICAgIH0sXG4gICAgICBtczogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIFwibWlsbGlzZWt1bmRcIiArIChjID09PSAxID8gXCJcIiA6IFwiZXJcIik7XG4gICAgICB9LFxuICAgICAgZGVjaW1hbDogXCIsXCIsXG4gICAgfSxcbiAgICBzdzoge1xuICAgICAgeTogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IDEgPyBcIm13YWthXCIgOiBcIm1pYWthXCI7XG4gICAgICB9LFxuICAgICAgbW86IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIHJldHVybiBjID09PSAxID8gXCJtd2V6aVwiIDogXCJtaWV6aVwiO1xuICAgICAgfSxcbiAgICAgIHc6IFwid2lraVwiLFxuICAgICAgZDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IDEgPyBcInNpa3VcIiA6IFwibWFzaWt1XCI7XG4gICAgICB9LFxuICAgICAgaDogZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgcmV0dXJuIGMgPT09IDEgPyBcInNhYVwiIDogXCJtYXNhYVwiO1xuICAgICAgfSxcbiAgICAgIG06IFwiZGFraWthXCIsXG4gICAgICBzOiBcInNla3VuZGVcIixcbiAgICAgIG1zOiBcIm1pbGlzZWt1bmRlXCIsXG4gICAgICBkZWNpbWFsOiBcIi5cIixcbiAgICB9LFxuICAgIHRyOiB7XG4gICAgICB5OiBcInnEsWxcIixcbiAgICAgIG1vOiBcImF5XCIsXG4gICAgICB3OiBcImhhZnRhXCIsXG4gICAgICBkOiBcImfDvG5cIixcbiAgICAgIGg6IFwic2FhdFwiLFxuICAgICAgbTogXCJkYWtpa2FcIixcbiAgICAgIHM6IFwic2FuaXllXCIsXG4gICAgICBtczogXCJtaWxpc2FuaXllXCIsXG4gICAgICBkZWNpbWFsOiBcIixcIixcbiAgICB9LFxuICAgIHRoOiB7XG4gICAgICB5OiBcIuC4m+C4tVwiLFxuICAgICAgbW86IFwi4LmA4LiU4Li34Lit4LiZXCIsXG4gICAgICB3OiBcIuC4reC4suC4l+C4tOC4leC4ouC5jFwiLFxuICAgICAgZDogXCLguKfguLHguJlcIixcbiAgICAgIGg6IFwi4LiK4Lix4LmI4Lin4LmC4Lih4LiHXCIsXG4gICAgICBtOiBcIuC4meC4suC4l+C4tVwiLFxuICAgICAgczogXCLguKfguLTguJnguLLguJfguLVcIixcbiAgICAgIG1zOiBcIuC4oeC4tOC4peC4peC4tOC4p+C4tOC4meC4suC4l+C4tVwiLFxuICAgICAgZGVjaW1hbDogXCIuXCIsXG4gICAgfSxcbiAgICB2aToge1xuICAgICAgeTogXCJuxINtXCIsXG4gICAgICBtbzogXCJ0aMOhbmdcIixcbiAgICAgIHc6IFwidHXhuqduXCIsXG4gICAgICBkOiBcIm5nw6B5XCIsXG4gICAgICBoOiBcImdp4budXCIsXG4gICAgICBtOiBcInBow7p0XCIsXG4gICAgICBzOiBcImdpw6J5XCIsXG4gICAgICBtczogXCJtaWxpIGdpw6J5XCIsXG4gICAgICBkZWNpbWFsOiBcIixcIixcbiAgICB9LFxuICAgIHpoX0NOOiB7XG4gICAgICB5OiBcIuW5tFwiLFxuICAgICAgbW86IFwi5Liq5pyIXCIsXG4gICAgICB3OiBcIuWRqFwiLFxuICAgICAgZDogXCLlpKlcIixcbiAgICAgIGg6IFwi5bCP5pe2XCIsXG4gICAgICBtOiBcIuWIhumSn1wiLFxuICAgICAgczogXCLnp5JcIixcbiAgICAgIG1zOiBcIuavq+enklwiLFxuICAgICAgZGVjaW1hbDogXCIuXCIsXG4gICAgfSxcbiAgICB6aF9UVzoge1xuICAgICAgeTogXCLlubRcIixcbiAgICAgIG1vOiBcIuWAi+aciFwiLFxuICAgICAgdzogXCLlkahcIixcbiAgICAgIGQ6IFwi5aSpXCIsXG4gICAgICBoOiBcIuWwj+aZglwiLFxuICAgICAgbTogXCLliIbpkJhcIixcbiAgICAgIHM6IFwi56eSXCIsXG4gICAgICBtczogXCLmr6vnp5JcIixcbiAgICAgIGRlY2ltYWw6IFwiLlwiLFxuICAgIH0sXG4gIH07XG5cbiAgLy8gWW91IGNhbiBjcmVhdGUgYSBodW1hbml6ZXIsIHdoaWNoIHJldHVybnMgYSBmdW5jdGlvbiB3aXRoIGRlZmF1bHRcbiAgLy8gcGFyYW1ldGVycy5cbiAgZnVuY3Rpb24gaHVtYW5pemVyKHBhc3NlZE9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24gaHVtYW5pemVyKG1zLCBodW1hbml6ZXJPcHRpb25zKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGV4dGVuZCh7fSwgcmVzdWx0LCBodW1hbml6ZXJPcHRpb25zIHx8IHt9KTtcbiAgICAgIHJldHVybiBkb0h1bWFuaXphdGlvbihtcywgb3B0aW9ucyk7XG4gICAgfTtcblxuICAgIHJldHVybiBleHRlbmQoXG4gICAgICByZXN1bHQsXG4gICAgICB7XG4gICAgICAgIGxhbmd1YWdlOiBcImVuXCIsXG4gICAgICAgIGRlbGltaXRlcjogXCIsIFwiLFxuICAgICAgICBzcGFjZXI6IFwiIFwiLFxuICAgICAgICBjb25qdW5jdGlvbjogXCJcIixcbiAgICAgICAgc2VyaWFsQ29tbWE6IHRydWUsXG4gICAgICAgIHVuaXRzOiBbXCJ5XCIsIFwibW9cIiwgXCJ3XCIsIFwiZFwiLCBcImhcIiwgXCJtXCIsIFwic1wiXSxcbiAgICAgICAgbGFuZ3VhZ2VzOiB7fSxcbiAgICAgICAgcm91bmQ6IGZhbHNlLFxuICAgICAgICB1bml0TWVhc3VyZXM6IHtcbiAgICAgICAgICB5OiAzMTU1NzYwMDAwMCxcbiAgICAgICAgICBtbzogMjYyOTgwMDAwMCxcbiAgICAgICAgICB3OiA2MDQ4MDAwMDAsXG4gICAgICAgICAgZDogODY0MDAwMDAsXG4gICAgICAgICAgaDogMzYwMDAwMCxcbiAgICAgICAgICBtOiA2MDAwMCxcbiAgICAgICAgICBzOiAxMDAwLFxuICAgICAgICAgIG1zOiAxLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHBhc3NlZE9wdGlvbnNcbiAgICApO1xuICB9XG5cbiAgLy8gVGhlIG1haW4gZnVuY3Rpb24gaXMganVzdCBhIHdyYXBwZXIgYXJvdW5kIGEgZGVmYXVsdCBodW1hbml6ZXIuXG4gIHZhciBodW1hbml6ZUR1cmF0aW9uID0gaHVtYW5pemVyKHt9KTtcblxuICAvLyBCdWlsZCBkaWN0aW9uYXJ5IGZyb20gb3B0aW9uc1xuICBmdW5jdGlvbiBnZXREaWN0aW9uYXJ5KG9wdGlvbnMpIHtcbiAgICB2YXIgbGFuZ3VhZ2VzRnJvbU9wdGlvbnMgPSBbb3B0aW9ucy5sYW5ndWFnZV07XG5cbiAgICBpZiAoaGFzKG9wdGlvbnMsIFwiZmFsbGJhY2tzXCIpKSB7XG4gICAgICBpZiAoaXNBcnJheShvcHRpb25zLmZhbGxiYWNrcykgJiYgb3B0aW9ucy5mYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgIGxhbmd1YWdlc0Zyb21PcHRpb25zID0gbGFuZ3VhZ2VzRnJvbU9wdGlvbnMuY29uY2F0KG9wdGlvbnMuZmFsbGJhY2tzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImZhbGxiYWNrcyBtdXN0IGJlIGFuIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGVsZW1lbnRcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYW5ndWFnZXNGcm9tT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxhbmd1YWdlVG9UcnkgPSBsYW5ndWFnZXNGcm9tT3B0aW9uc1tpXTtcbiAgICAgIGlmIChoYXMob3B0aW9ucy5sYW5ndWFnZXMsIGxhbmd1YWdlVG9UcnkpKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmxhbmd1YWdlc1tsYW5ndWFnZVRvVHJ5XTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzKExBTkdVQUdFUywgbGFuZ3VhZ2VUb1RyeSkpIHtcbiAgICAgICAgcmV0dXJuIExBTkdVQUdFU1tsYW5ndWFnZVRvVHJ5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBsYW5ndWFnZSBmb3VuZC5cIik7XG4gIH1cblxuICAvLyBkb0h1bWFuaXphdGlvbiBkb2VzIHRoZSBidWxrIG9mIHRoZSB3b3JrLlxuICBmdW5jdGlvbiBkb0h1bWFuaXphdGlvbihtcywgb3B0aW9ucykge1xuICAgIHZhciBpLCBsZW4sIHBpZWNlO1xuXG4gICAgLy8gTWFrZSBzdXJlIHdlIGhhdmUgYSBwb3NpdGl2ZSBudW1iZXIuXG4gICAgLy8gSGFzIHRoZSBuaWNlIHNpZGVmZmVjdCBvZiB0dXJuaW5nIE51bWJlciBvYmplY3RzIGludG8gcHJpbWl0aXZlcy5cbiAgICBtcyA9IE1hdGguYWJzKG1zKTtcblxuICAgIHZhciBkaWN0aW9uYXJ5ID0gZ2V0RGljdGlvbmFyeShvcHRpb25zKTtcbiAgICB2YXIgcGllY2VzID0gW107XG5cbiAgICAvLyBTdGFydCBhdCB0aGUgdG9wIGFuZCBrZWVwIHJlbW92aW5nIHVuaXRzLCBiaXQgYnkgYml0LlxuICAgIHZhciB1bml0TmFtZSwgdW5pdE1TLCB1bml0Q291bnQ7XG4gICAgZm9yIChpID0gMCwgbGVuID0gb3B0aW9ucy51bml0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdW5pdE5hbWUgPSBvcHRpb25zLnVuaXRzW2ldO1xuICAgICAgdW5pdE1TID0gb3B0aW9ucy51bml0TWVhc3VyZXNbdW5pdE5hbWVdO1xuXG4gICAgICAvLyBXaGF0J3MgdGhlIG51bWJlciBvZiBmdWxsIHVuaXRzIHdlIGNhbiBmaXQ/XG4gICAgICBpZiAoaSArIDEgPT09IGxlbikge1xuICAgICAgICBpZiAoaGFzKG9wdGlvbnMsIFwibWF4RGVjaW1hbFBvaW50c1wiKSkge1xuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdXNlIHRoaXMgZXhwVmFsdWUgdG8gYXZvaWQgcm91bmRpbmcgZnVuY3Rpb25hbGl0eSBvZiB0b0ZpeGVkIGNhbGxcbiAgICAgICAgICB2YXIgZXhwVmFsdWUgPSBNYXRoLnBvdygxMCwgb3B0aW9ucy5tYXhEZWNpbWFsUG9pbnRzKTtcbiAgICAgICAgICB2YXIgdW5pdENvdW50RmxvYXQgPSBtcyAvIHVuaXRNUztcbiAgICAgICAgICB1bml0Q291bnQgPSBwYXJzZUZsb2F0KFxuICAgICAgICAgICAgKE1hdGguZmxvb3IoZXhwVmFsdWUgKiB1bml0Q291bnRGbG9hdCkgLyBleHBWYWx1ZSkudG9GaXhlZChcbiAgICAgICAgICAgICAgb3B0aW9ucy5tYXhEZWNpbWFsUG9pbnRzXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1bml0Q291bnQgPSBtcyAvIHVuaXRNUztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5pdENvdW50ID0gTWF0aC5mbG9vcihtcyAvIHVuaXRNUyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCB0aGUgc3RyaW5nLlxuICAgICAgcGllY2VzLnB1c2goe1xuICAgICAgICB1bml0Q291bnQ6IHVuaXRDb3VudCxcbiAgICAgICAgdW5pdE5hbWU6IHVuaXROYW1lLFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlbW92ZSB3aGF0IHdlIGp1c3QgZmlndXJlZCBvdXQuXG4gICAgICBtcyAtPSB1bml0Q291bnQgKiB1bml0TVM7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0T2NjdXBpZWRVbml0SW5kZXggPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBwaWVjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwaWVjZXNbaV0udW5pdENvdW50KSB7XG4gICAgICAgIGZpcnN0T2NjdXBpZWRVbml0SW5kZXggPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5yb3VuZCkge1xuICAgICAgdmFyIHJhdGlvVG9MYXJnZXJVbml0LCBwcmV2aW91c1BpZWNlO1xuICAgICAgZm9yIChpID0gcGllY2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHBpZWNlID0gcGllY2VzW2ldO1xuICAgICAgICBwaWVjZS51bml0Q291bnQgPSBNYXRoLnJvdW5kKHBpZWNlLnVuaXRDb3VudCk7XG5cbiAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzUGllY2UgPSBwaWVjZXNbaSAtIDFdO1xuXG4gICAgICAgIHJhdGlvVG9MYXJnZXJVbml0ID1cbiAgICAgICAgICBvcHRpb25zLnVuaXRNZWFzdXJlc1twcmV2aW91c1BpZWNlLnVuaXROYW1lXSAvXG4gICAgICAgICAgb3B0aW9ucy51bml0TWVhc3VyZXNbcGllY2UudW5pdE5hbWVdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcGllY2UudW5pdENvdW50ICUgcmF0aW9Ub0xhcmdlclVuaXQgPT09IDAgfHxcbiAgICAgICAgICAob3B0aW9ucy5sYXJnZXN0ICYmIG9wdGlvbnMubGFyZ2VzdCAtIDEgPCBpIC0gZmlyc3RPY2N1cGllZFVuaXRJbmRleClcbiAgICAgICAgKSB7XG4gICAgICAgICAgcHJldmlvdXNQaWVjZS51bml0Q291bnQgKz0gcGllY2UudW5pdENvdW50IC8gcmF0aW9Ub0xhcmdlclVuaXQ7XG4gICAgICAgICAgcGllY2UudW5pdENvdW50ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGkgPSAwLCBwaWVjZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHBpZWNlID0gcGllY2VzW2ldO1xuICAgICAgaWYgKHBpZWNlLnVuaXRDb3VudCkge1xuICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICByZW5kZXIocGllY2UudW5pdENvdW50LCBwaWVjZS51bml0TmFtZSwgZGljdGlvbmFyeSwgb3B0aW9ucylcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IG9wdGlvbnMubGFyZ2VzdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzdWx0Lmxlbmd0aCkge1xuICAgICAgaWYgKCFvcHRpb25zLmNvbmp1bmN0aW9uIHx8IHJlc3VsdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5qb2luKG9wdGlvbnMuZGVsaW1pdGVyKTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4ob3B0aW9ucy5jb25qdW5jdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKHJlc3VsdC5sZW5ndGggPiAyKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgcmVzdWx0LnNsaWNlKDAsIC0xKS5qb2luKG9wdGlvbnMuZGVsaW1pdGVyKSArXG4gICAgICAgICAgKG9wdGlvbnMuc2VyaWFsQ29tbWEgPyBcIixcIiA6IFwiXCIpICtcbiAgICAgICAgICBvcHRpb25zLmNvbmp1bmN0aW9uICtcbiAgICAgICAgICByZXN1bHQuc2xpY2UoLTEpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByZW5kZXIoXG4gICAgICAgIDAsXG4gICAgICAgIG9wdGlvbnMudW5pdHNbb3B0aW9ucy51bml0cy5sZW5ndGggLSAxXSxcbiAgICAgICAgZGljdGlvbmFyeSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXIoY291bnQsIHR5cGUsIGRpY3Rpb25hcnksIG9wdGlvbnMpIHtcbiAgICB2YXIgZGVjaW1hbDtcbiAgICBpZiAoaGFzKG9wdGlvbnMsIFwiZGVjaW1hbFwiKSkge1xuICAgICAgZGVjaW1hbCA9IG9wdGlvbnMuZGVjaW1hbDtcbiAgICB9IGVsc2UgaWYgKGhhcyhkaWN0aW9uYXJ5LCBcImRlY2ltYWxcIikpIHtcbiAgICAgIGRlY2ltYWwgPSBkaWN0aW9uYXJ5LmRlY2ltYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlY2ltYWwgPSBcIi5cIjtcbiAgICB9XG5cbiAgICB2YXIgY291bnRTdHIgPSBjb3VudC50b1N0cmluZygpLnJlcGxhY2UoXCIuXCIsIGRlY2ltYWwpO1xuXG4gICAgdmFyIGRpY3Rpb25hcnlWYWx1ZSA9IGRpY3Rpb25hcnlbdHlwZV07XG4gICAgdmFyIHdvcmQ7XG4gICAgaWYgKHR5cGVvZiBkaWN0aW9uYXJ5VmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgd29yZCA9IGRpY3Rpb25hcnlWYWx1ZShjb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmQgPSBkaWN0aW9uYXJ5VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvdW50U3RyICsgb3B0aW9ucy5zcGFjZXIgKyB3b3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kKGRlc3RpbmF0aW9uKSB7XG4gICAgdmFyIHNvdXJjZTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKGhhcyhzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgICAgZGVzdGluYXRpb25bcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIGZvciBQb2xpc2ggbGFuZ3VhZ2UuXG4gIGZ1bmN0aW9uIGdldFBvbGlzaEZvcm0oYykge1xuICAgIGlmIChjID09PSAxKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKE1hdGguZmxvb3IoYykgIT09IGMpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoYyAlIDEwID49IDIgJiYgYyAlIDEwIDw9IDQgJiYgIShjICUgMTAwID4gMTAgJiYgYyAlIDEwMCA8IDIwKSkge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEludGVybmFsIGhlbHBlciBmdW5jdGlvbiBmb3IgUnVzc2lhbiBhbmQgVWtyYW5pYW4gbGFuZ3VhZ2VzLlxuICBmdW5jdGlvbiBnZXRTbGF2aWNGb3JtKGMpIHtcbiAgICBpZiAoTWF0aC5mbG9vcihjKSAhPT0gYykge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIChjICUgMTAwID49IDUgJiYgYyAlIDEwMCA8PSAyMCkgfHxcbiAgICAgIChjICUgMTAgPj0gNSAmJiBjICUgMTAgPD0gOSkgfHxcbiAgICAgIGMgJSAxMCA9PT0gMFxuICAgICkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIGlmIChjICUgMTAgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoYyA+IDEpIHtcbiAgICAgIHJldHVybiAyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICAvLyBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gZm9yIFNsb3ZhayBsYW5ndWFnZS5cbiAgZnVuY3Rpb24gZ2V0Q3plY2hPclNsb3Zha0Zvcm0oYykge1xuICAgIGlmIChjID09PSAxKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKE1hdGguZmxvb3IoYykgIT09IGMpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoYyAlIDEwID49IDIgJiYgYyAlIDEwIDw9IDQgJiYgYyAlIDEwMCA8IDEwKSB7XG4gICAgICByZXR1cm4gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDM7XG4gICAgfVxuICB9XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIGZvciBMaXRodWFuaWFuIGxhbmd1YWdlLlxuICBmdW5jdGlvbiBnZXRMaXRodWFuaWFuRm9ybShjKSB7XG4gICAgaWYgKGMgPT09IDEgfHwgKGMgJSAxMCA9PT0gMSAmJiBjICUgMTAwID4gMjApKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgTWF0aC5mbG9vcihjKSAhPT0gYyB8fFxuICAgICAgKGMgJSAxMCA+PSAyICYmIGMgJSAxMDAgPiAyMCkgfHxcbiAgICAgIChjICUgMTAgPj0gMiAmJiBjICUgMTAwIDwgMTApXG4gICAgKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICB9XG5cbiAgLy8gSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIGZvciBMYXR2aWFuIGxhbmd1YWdlLlxuICBmdW5jdGlvbiBnZXRMYXR2aWFuRm9ybShjKSB7XG4gICAgcmV0dXJuIGMgJSAxMCA9PT0gMSAmJiBjICUgMTAwICE9PSAxMTtcbiAgfVxuXG4gIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHdlIHN1cHBvcnQgYnJvd3NlcnMgdGhhdCBkb24ndCBoYXZlXG4gIC8vIGBBcnJheS5pc0FycmF5YCwgc28gd2UgZGVmaW5lIGEgZmFsbGJhY2sgaGVyZS5cbiAgdmFyIGlzQXJyYXkgPVxuICAgIEFycmF5LmlzQXJyYXkgfHxcbiAgICBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICB9O1xuXG4gIGZ1bmN0aW9uIGhhcyhvYmosIGtleSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9XG5cbiAgaHVtYW5pemVEdXJhdGlvbi5nZXRTdXBwb3J0ZWRMYW5ndWFnZXMgPSBmdW5jdGlvbiBnZXRTdXBwb3J0ZWRMYW5ndWFnZXMoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGxhbmd1YWdlIGluIExBTkdVQUdFUykge1xuICAgICAgaWYgKGhhcyhMQU5HVUFHRVMsIGxhbmd1YWdlKSAmJiBsYW5ndWFnZSAhPT0gXCJnclwiKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxhbmd1YWdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBodW1hbml6ZUR1cmF0aW9uLmh1bWFuaXplciA9IGh1bWFuaXplcjtcblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGh1bWFuaXplRHVyYXRpb247XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gaHVtYW5pemVEdXJhdGlvbjtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmh1bWFuaXplRHVyYXRpb24gPSBodW1hbml6ZUR1cmF0aW9uO1xuICB9XG59KSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHNlbWlcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///46\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.Game = void 0;\nvar Game = /** @class */ (function () {\n    function Game(screenWriter, inputEvents) {\n        var _this = this;\n        this.screenWriter = screenWriter;\n        this.inputEvents = inputEvents;\n        // setup some event listeners\n        this.inputEvents.on("SIGINT", function () { return _this.onSIGINT(); });\n        this.inputEvents.on("KEYPRESS", function (pressedObj) {\n            return _this.onKeyPress(pressedObj);\n        });\n        this.screenWriter.on("resize", function (dimensions) {\n            return _this.onScreenResize(dimensions);\n        });\n    }\n    /**\n     * Prints the screenContent\n     */\n    Game.prototype.print = function () {\n        this.screenWriter.print(this.screenContent);\n    };\n    return Game;\n}());\nexports.Game = Game;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvR2FtZXMvQWJzdHJhY3RHYW1lLnRzPzNhZWYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBR0E7SUFHRSxjQUNZLFlBQW1DLEVBQ25DLFdBQWlDO1FBRjdDLGlCQVlDO1FBWFcsaUJBQVksR0FBWixZQUFZLENBQXVCO1FBQ25DLGdCQUFXLEdBQVgsV0FBVyxDQUFzQjtRQUUzQyw2QkFBNkI7UUFDN0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLGNBQU0sWUFBSSxDQUFDLFFBQVEsRUFBRSxFQUFmLENBQWUsQ0FBQyxDQUFDO1FBQ3JELElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRSxVQUFDLFVBQVU7WUFDekMsWUFBSSxDQUFDLFVBQVUsQ0FBQyxVQUFVLENBQUM7UUFBM0IsQ0FBMkIsQ0FDNUIsQ0FBQztRQUNGLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxVQUFDLFVBQVU7WUFDeEMsWUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUM7UUFBL0IsQ0FBK0IsQ0FDaEMsQ0FBQztJQUNKLENBQUM7SUFFRDs7T0FFRztJQUNPLG9CQUFLLEdBQWY7UUFDRSxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDOUMsQ0FBQztJQWtCSCxXQUFDO0FBQUQsQ0FBQztBQXhDcUIsb0JBQUkiLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTY3JlZW5Xcml0ZXJJbnRlcmZhY2UsIFNjcmVlbkRpbWVuc2lvbnMgfSBmcm9tIFwiLi4vU2NyZWVuV3JpdGVyXCI7XG5pbXBvcnQgeyBJbnB1dEV2ZW50c0ludGVyZmFjZSwgS2V5UHJlc3MgfSBmcm9tIFwiLi4vSW5wdXRFdmVudHNcIjtcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEdhbWUge1xuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgc2NyZWVuQ29udGVudDogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIHNjcmVlbldyaXRlcjogU2NyZWVuV3JpdGVySW50ZXJmYWNlLFxuICAgIHByb3RlY3RlZCBpbnB1dEV2ZW50czogSW5wdXRFdmVudHNJbnRlcmZhY2VcbiAgKSB7XG4gICAgLy8gc2V0dXAgc29tZSBldmVudCBsaXN0ZW5lcnNcbiAgICB0aGlzLmlucHV0RXZlbnRzLm9uKFwiU0lHSU5UXCIsICgpID0+IHRoaXMub25TSUdJTlQoKSk7XG4gICAgdGhpcy5pbnB1dEV2ZW50cy5vbihcIktFWVBSRVNTXCIsIChwcmVzc2VkT2JqKSA9PlxuICAgICAgdGhpcy5vbktleVByZXNzKHByZXNzZWRPYmopXG4gICAgKTtcbiAgICB0aGlzLnNjcmVlbldyaXRlci5vbihcInJlc2l6ZVwiLCAoZGltZW5zaW9ucykgPT5cbiAgICAgIHRoaXMub25TY3JlZW5SZXNpemUoZGltZW5zaW9ucylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaW50cyB0aGUgc2NyZWVuQ29udGVudFxuICAgKi9cbiAgcHJvdGVjdGVkIHByaW50KCkge1xuICAgIHRoaXMuc2NyZWVuV3JpdGVyLnByaW50KHRoaXMuc2NyZWVuQ29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gY2FsbGVkIG9uIGVhY2ggdXNlciBrZXlwcmVzc1xuICAgKiBAcGFyYW0ga2V5UHJlc3NcbiAgICovXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBvbktleVByZXNzKGtleVByZXNzOiBLZXlQcmVzcyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGNhbGxlZCB3aGVuIHNjcmVlbiByZXNpemVzXG4gICAqIEBwYXJhbSBkaW1lbnNpb25zXG4gICAqL1xuICBwcm90ZWN0ZWQgYWJzdHJhY3Qgb25TY3JlZW5SZXNpemUoZGltZW5zaW9uczogU2NyZWVuRGltZW5zaW9ucyk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB1c2VyIGNsaWNrcyBjdHJsK3pcbiAgICovXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBvblNJR0lOVCgpOiB2b2lkO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///47\n')},function(module,exports,__webpack_require__){"use strict";eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.args = void 0;\nvar yargs_1 = __importDefault(__webpack_require__(49));\nvar colors_1 = __webpack_require__(9);\nvar args = yargs_1.default\n    .parserConfiguration({\n    "duplicate-arguments-array": false,\n})\n    .command("$0 [OPTIONS]", "Play snake in your terminal.")\n    .option("s", {\n    alias: "speed",\n    demandOption: false,\n    default: 100,\n    describe: "refresh interval",\n    type: "number",\n})\n    .option("g", {\n    alias: "head-color",\n    demandOption: false,\n    default: "red",\n    describe: "snake\'s head color",\n    type: "string",\n})\n    .option("b", {\n    alias: "body-color",\n    demandOption: false,\n    default: "blue",\n    describe: "snake\'s body color",\n    type: "string",\n})\n    .option("e", {\n    alias: "empty-color",\n    demandOption: false,\n    default: "black",\n    describe: "color of an empty char",\n    type: "string",\n})\n    .option("f", {\n    alias: "fruit-color",\n    demandOption: false,\n    default: "green",\n    describe: "color of the fruit",\n    type: "string",\n})\n    .option("u", {\n    alias: "filler-char",\n    demandOption: false,\n    default: " ",\n    describe: "character to be used to build the board",\n    type: "string",\n})\n    .option("r", {\n    alias: "rows",\n    demandOption: false,\n    default: undefined,\n    describe: "number of rows",\n    type: "number",\n})\n    .option("c", {\n    alias: "columns",\n    demandOption: false,\n    default: undefined,\n    describe: "number of columns",\n    type: "number",\n})\n    .option("l", {\n    alias: "list-colors",\n    demandOption: false,\n    default: false,\n    describe: "List all possible colors",\n    type: "boolean",\n})\n    .check(function (argv) {\n    var updateInterval = argv.s, snakeHeadColor = argv.g, snakeBodyColor = argv.b, emptyColor = argv.e, fruitColor = argv.f, fillChar = argv.u, rows = argv.r, columns = argv.c;\n    if (!colors_1.availableColors.includes(snakeHeadColor) ||\n        !colors_1.availableColors.includes(snakeBodyColor) ||\n        !colors_1.availableColors.includes(emptyColor) ||\n        !colors_1.availableColors.includes(fruitColor))\n        throw new Error("invalid color name");\n    if (fillChar.length > 1 || fillChar.length === 0)\n        throw new Error("invalid fill char length");\n    if (updateInterval <= 0)\n        throw new Error("invalid update interval");\n    return true;\n})\n    .help("help")\n    .alias("h", "help")\n    .alias("v", "version").argv;\nexports.args = args;\nif (args.l) {\n    console.log("Available colors:");\n    console.log(colors_1.availableColors\n        .sort()\n        .map(function (c) { return "  " + c; })\n        .join("\\n"));\n    process.exit(2);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvR2FtZXMvU25ha2UvcGFyc2VBcmdzLnRzPzE1MTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsdURBQTBCO0FBQzFCLHNDQUErQztBQUUvQyxJQUFNLElBQUksR0FBRyxlQUFLO0tBQ2YsbUJBQW1CLENBQUM7SUFDbkIsMkJBQTJCLEVBQUUsS0FBSztDQUNuQyxDQUFDO0tBQ0QsT0FBTyxDQUFDLGNBQWMsRUFBRSw4QkFBOEIsQ0FBQztLQUN2RCxNQUFNLENBQUMsR0FBRyxFQUFFO0lBQ1gsS0FBSyxFQUFFLE9BQU87SUFDZCxZQUFZLEVBQUUsS0FBSztJQUNuQixPQUFPLEVBQUUsR0FBRztJQUNaLFFBQVEsRUFBRSxrQkFBa0I7SUFDNUIsSUFBSSxFQUFFLFFBQVE7Q0FDZixDQUFDO0tBQ0QsTUFBTSxDQUFDLEdBQUcsRUFBRTtJQUNYLEtBQUssRUFBRSxZQUFZO0lBQ25CLFlBQVksRUFBRSxLQUFLO0lBQ25CLE9BQU8sRUFBRSxLQUFLO0lBQ2QsUUFBUSxFQUFFLG9CQUFvQjtJQUM5QixJQUFJLEVBQUUsUUFBUTtDQUNmLENBQUM7S0FDRCxNQUFNLENBQUMsR0FBRyxFQUFFO0lBQ1gsS0FBSyxFQUFFLFlBQVk7SUFDbkIsWUFBWSxFQUFFLEtBQUs7SUFDbkIsT0FBTyxFQUFFLE1BQU07SUFDZixRQUFRLEVBQUUsb0JBQW9CO0lBQzlCLElBQUksRUFBRSxRQUFRO0NBQ2YsQ0FBQztLQUNELE1BQU0sQ0FBQyxHQUFHLEVBQUU7SUFDWCxLQUFLLEVBQUUsYUFBYTtJQUNwQixZQUFZLEVBQUUsS0FBSztJQUNuQixPQUFPLEVBQUUsT0FBTztJQUNoQixRQUFRLEVBQUUsd0JBQXdCO0lBQ2xDLElBQUksRUFBRSxRQUFRO0NBQ2YsQ0FBQztLQUNELE1BQU0sQ0FBQyxHQUFHLEVBQUU7SUFDWCxLQUFLLEVBQUUsYUFBYTtJQUNwQixZQUFZLEVBQUUsS0FBSztJQUNuQixPQUFPLEVBQUUsT0FBTztJQUNoQixRQUFRLEVBQUUsb0JBQW9CO0lBQzlCLElBQUksRUFBRSxRQUFRO0NBQ2YsQ0FBQztLQUNELE1BQU0sQ0FBQyxHQUFHLEVBQUU7SUFDWCxLQUFLLEVBQUUsYUFBYTtJQUNwQixZQUFZLEVBQUUsS0FBSztJQUNuQixPQUFPLEVBQUUsR0FBRztJQUNaLFFBQVEsRUFBRSx5Q0FBeUM7SUFDbkQsSUFBSSxFQUFFLFFBQVE7Q0FDZixDQUFDO0tBQ0QsTUFBTSxDQUFDLEdBQUcsRUFBRTtJQUNYLEtBQUssRUFBRSxNQUFNO0lBQ2IsWUFBWSxFQUFFLEtBQUs7SUFDbkIsT0FBTyxFQUFFLFNBQVM7SUFDbEIsUUFBUSxFQUFFLGdCQUFnQjtJQUMxQixJQUFJLEVBQUUsUUFBUTtDQUNmLENBQUM7S0FDRCxNQUFNLENBQUMsR0FBRyxFQUFFO0lBQ1gsS0FBSyxFQUFFLFNBQVM7SUFDaEIsWUFBWSxFQUFFLEtBQUs7SUFDbkIsT0FBTyxFQUFFLFNBQVM7SUFDbEIsUUFBUSxFQUFFLG1CQUFtQjtJQUM3QixJQUFJLEVBQUUsUUFBUTtDQUNmLENBQUM7S0FDRCxNQUFNLENBQUMsR0FBRyxFQUFFO0lBQ1gsS0FBSyxFQUFFLGFBQWE7SUFDcEIsWUFBWSxFQUFFLEtBQUs7SUFDbkIsT0FBTyxFQUFFLEtBQUs7SUFDZCxRQUFRLEVBQUUsMEJBQTBCO0lBQ3BDLElBQUksRUFBRSxTQUFTO0NBQ2hCLENBQUM7S0FDRCxLQUFLLENBQUMsVUFBQyxJQUFJO0lBRVIsSUFBRyxjQUFjLEdBUWYsSUFBSSxFQVJXLEVBQ2QsY0FBYyxHQU9mLElBQUksRUFQVyxFQUNkLGNBQWMsR0FNZixJQUFJLEVBTlcsRUFDZCxVQUFVLEdBS1gsSUFBSSxFQUxPLEVBQ1YsVUFBVSxHQUlYLElBQUksRUFKTyxFQUNWLFFBQVEsR0FHVCxJQUFJLEVBSEssRUFDUixJQUFJLEdBRUwsSUFBSSxFQUZDLEVBQ0osT0FBTyxHQUNSLElBQUksRUFESSxDQUNIO0lBRVQsSUFDRSxDQUFDLHdCQUFlLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQztRQUN6QyxDQUFDLHdCQUFlLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQztRQUN6QyxDQUFDLHdCQUFlLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQztRQUNyQyxDQUFDLHdCQUFlLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQztRQUVyQyxNQUFNLElBQUksS0FBSyxDQUFDLG9CQUFvQixDQUFDLENBQUM7SUFFeEMsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxRQUFRLENBQUMsTUFBTSxLQUFLLENBQUM7UUFDOUMsTUFBTSxJQUFJLEtBQUssQ0FBQywwQkFBMEIsQ0FBQyxDQUFDO0lBRTlDLElBQUksY0FBYyxJQUFJLENBQUM7UUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHlCQUF5QixDQUFDLENBQUM7SUFFcEUsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDLENBQUM7S0FDRCxJQUFJLENBQUMsTUFBTSxDQUFDO0tBQ1osS0FBSyxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUM7S0FDbEIsS0FBSyxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUM7QUFhckIsb0JBQUk7QUFYYixJQUFJLElBQUksQ0FBQyxDQUFDLEVBQUU7SUFDVixPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUM7SUFDakMsT0FBTyxDQUFDLEdBQUcsQ0FDVCx3QkFBZTtTQUNaLElBQUksRUFBRTtTQUNOLEdBQUcsQ0FBQyxVQUFDLENBQUMsSUFBSyxXQUFJLEdBQUcsQ0FBQyxFQUFSLENBQVEsQ0FBQztTQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLENBQ2QsQ0FBQztJQUNGLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDakIiLCJmaWxlIjoiNDguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeWFyZ3MgZnJvbSBcInlhcmdzXCI7XG5pbXBvcnQgeyBhdmFpbGFibGVDb2xvcnMgfSBmcm9tIFwiLi4vLi4vY29sb3JzXCI7XG5cbmNvbnN0IGFyZ3MgPSB5YXJnc1xuICAucGFyc2VyQ29uZmlndXJhdGlvbih7XG4gICAgXCJkdXBsaWNhdGUtYXJndW1lbnRzLWFycmF5XCI6IGZhbHNlLFxuICB9KVxuICAuY29tbWFuZChcIiQwIFtPUFRJT05TXVwiLCBcIlBsYXkgc25ha2UgaW4geW91ciB0ZXJtaW5hbC5cIilcbiAgLm9wdGlvbihcInNcIiwge1xuICAgIGFsaWFzOiBcInNwZWVkXCIsXG4gICAgZGVtYW5kT3B0aW9uOiBmYWxzZSxcbiAgICBkZWZhdWx0OiAxMDAsXG4gICAgZGVzY3JpYmU6IFwicmVmcmVzaCBpbnRlcnZhbFwiLFxuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gIH0pXG4gIC5vcHRpb24oXCJnXCIsIHtcbiAgICBhbGlhczogXCJoZWFkLWNvbG9yXCIsXG4gICAgZGVtYW5kT3B0aW9uOiBmYWxzZSxcbiAgICBkZWZhdWx0OiBcInJlZFwiLFxuICAgIGRlc2NyaWJlOiBcInNuYWtlJ3MgaGVhZCBjb2xvclwiLFxuICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gIH0pXG4gIC5vcHRpb24oXCJiXCIsIHtcbiAgICBhbGlhczogXCJib2R5LWNvbG9yXCIsXG4gICAgZGVtYW5kT3B0aW9uOiBmYWxzZSxcbiAgICBkZWZhdWx0OiBcImJsdWVcIixcbiAgICBkZXNjcmliZTogXCJzbmFrZSdzIGJvZHkgY29sb3JcIixcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICB9KVxuICAub3B0aW9uKFwiZVwiLCB7XG4gICAgYWxpYXM6IFwiZW1wdHktY29sb3JcIixcbiAgICBkZW1hbmRPcHRpb246IGZhbHNlLFxuICAgIGRlZmF1bHQ6IFwiYmxhY2tcIixcbiAgICBkZXNjcmliZTogXCJjb2xvciBvZiBhbiBlbXB0eSBjaGFyXCIsXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgfSlcbiAgLm9wdGlvbihcImZcIiwge1xuICAgIGFsaWFzOiBcImZydWl0LWNvbG9yXCIsXG4gICAgZGVtYW5kT3B0aW9uOiBmYWxzZSxcbiAgICBkZWZhdWx0OiBcImdyZWVuXCIsXG4gICAgZGVzY3JpYmU6IFwiY29sb3Igb2YgdGhlIGZydWl0XCIsXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgfSlcbiAgLm9wdGlvbihcInVcIiwge1xuICAgIGFsaWFzOiBcImZpbGxlci1jaGFyXCIsXG4gICAgZGVtYW5kT3B0aW9uOiBmYWxzZSxcbiAgICBkZWZhdWx0OiBcIiBcIixcbiAgICBkZXNjcmliZTogXCJjaGFyYWN0ZXIgdG8gYmUgdXNlZCB0byBidWlsZCB0aGUgYm9hcmRcIixcbiAgICB0eXBlOiBcInN0cmluZ1wiLFxuICB9KVxuICAub3B0aW9uKFwiclwiLCB7XG4gICAgYWxpYXM6IFwicm93c1wiLFxuICAgIGRlbWFuZE9wdGlvbjogZmFsc2UsXG4gICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgIGRlc2NyaWJlOiBcIm51bWJlciBvZiByb3dzXCIsXG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgfSlcbiAgLm9wdGlvbihcImNcIiwge1xuICAgIGFsaWFzOiBcImNvbHVtbnNcIixcbiAgICBkZW1hbmRPcHRpb246IGZhbHNlLFxuICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCxcbiAgICBkZXNjcmliZTogXCJudW1iZXIgb2YgY29sdW1uc1wiLFxuICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gIH0pXG4gIC5vcHRpb24oXCJsXCIsIHtcbiAgICBhbGlhczogXCJsaXN0LWNvbG9yc1wiLFxuICAgIGRlbWFuZE9wdGlvbjogZmFsc2UsXG4gICAgZGVmYXVsdDogZmFsc2UsXG4gICAgZGVzY3JpYmU6IFwiTGlzdCBhbGwgcG9zc2libGUgY29sb3JzXCIsXG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gIH0pXG4gIC5jaGVjaygoYXJndikgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIHM6IHVwZGF0ZUludGVydmFsLFxuICAgICAgZzogc25ha2VIZWFkQ29sb3IsXG4gICAgICBiOiBzbmFrZUJvZHlDb2xvcixcbiAgICAgIGU6IGVtcHR5Q29sb3IsXG4gICAgICBmOiBmcnVpdENvbG9yLFxuICAgICAgdTogZmlsbENoYXIsXG4gICAgICByOiByb3dzLFxuICAgICAgYzogY29sdW1ucyxcbiAgICB9ID0gYXJndjtcblxuICAgIGlmIChcbiAgICAgICFhdmFpbGFibGVDb2xvcnMuaW5jbHVkZXMoc25ha2VIZWFkQ29sb3IpIHx8XG4gICAgICAhYXZhaWxhYmxlQ29sb3JzLmluY2x1ZGVzKHNuYWtlQm9keUNvbG9yKSB8fFxuICAgICAgIWF2YWlsYWJsZUNvbG9ycy5pbmNsdWRlcyhlbXB0eUNvbG9yKSB8fFxuICAgICAgIWF2YWlsYWJsZUNvbG9ycy5pbmNsdWRlcyhmcnVpdENvbG9yKVxuICAgIClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY29sb3IgbmFtZVwiKTtcblxuICAgIGlmIChmaWxsQ2hhci5sZW5ndGggPiAxIHx8IGZpbGxDaGFyLmxlbmd0aCA9PT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmlsbCBjaGFyIGxlbmd0aFwiKTtcblxuICAgIGlmICh1cGRhdGVJbnRlcnZhbCA8PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHVwZGF0ZSBpbnRlcnZhbFwiKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9KVxuICAuaGVscChcImhlbHBcIilcbiAgLmFsaWFzKFwiaFwiLCBcImhlbHBcIilcbiAgLmFsaWFzKFwidlwiLCBcInZlcnNpb25cIikuYXJndjtcblxuaWYgKGFyZ3MubCkge1xuICBjb25zb2xlLmxvZyhcIkF2YWlsYWJsZSBjb2xvcnM6XCIpO1xuICBjb25zb2xlLmxvZyhcbiAgICBhdmFpbGFibGVDb2xvcnNcbiAgICAgIC5zb3J0KClcbiAgICAgIC5tYXAoKGMpID0+IFwiICBcIiArIGMpXG4gICAgICAuam9pbihcIlxcblwiKVxuICApO1xuICBwcm9jZXNzLmV4aXQoMik7XG59XG5cbmV4cG9ydCB7IGFyZ3MgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///48\n')},function(module,exports,__webpack_require__){"use strict";eval("\n// classic singleton yargs API, to use yargs\n// without running as a singleton do:\n// require('yargs/yargs')(process.argv.slice(2))\nconst yargs = __webpack_require__(50)\nconst processArgv = __webpack_require__(24)\n\nArgv(processArgv.getProcessArgvWithoutBin())\n\nmodule.exports = Argv\n\nfunction Argv (processArgs, cwd) {\n  const argv = yargs(processArgs, cwd, __webpack_require__(76))\n  singletonify(argv)\n  return argv\n}\n\n/*  Hack an instance of Argv with process.argv into Argv\n    so people can do\n    require('yargs')(['--beeble=1','-z','zizzle']).argv\n    to parse a list of args and\n    require('yargs').argv\n    to get a parsed version of process.argv.\n*/\nfunction singletonify (inst) {\n  Object.keys(inst).forEach((key) => {\n    if (key === 'argv') {\n      Argv.__defineGetter__(key, inst.__lookupGetter__(key))\n    } else if (typeof inst[key] === 'function') {\n      Argv[key] = inst[key].bind(inst)\n    } else {\n      Argv.__defineGetter__('$0', () => {\n        return inst.$0\n      })\n      Argv.__defineGetter__('parsed', () => {\n        return inst.parsed\n      })\n    }\n  })\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvaW5kZXguanM/MzllNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxFQUFTO0FBQy9CLG9CQUFvQixtQkFBTyxDQUFDLEVBQTBCOztBQUV0RDs7QUFFQTs7QUFFQTtBQUNBLHVDQUF1Qyx1QkFBTztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0giLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8vIGNsYXNzaWMgc2luZ2xldG9uIHlhcmdzIEFQSSwgdG8gdXNlIHlhcmdzXG4vLyB3aXRob3V0IHJ1bm5pbmcgYXMgYSBzaW5nbGV0b24gZG86XG4vLyByZXF1aXJlKCd5YXJncy95YXJncycpKHByb2Nlc3MuYXJndi5zbGljZSgyKSlcbmNvbnN0IHlhcmdzID0gcmVxdWlyZSgnLi95YXJncycpXG5jb25zdCBwcm9jZXNzQXJndiA9IHJlcXVpcmUoJy4vYnVpbGQvbGliL3Byb2Nlc3MtYXJndicpXG5cbkFyZ3YocHJvY2Vzc0FyZ3YuZ2V0UHJvY2Vzc0FyZ3ZXaXRob3V0QmluKCkpXG5cbm1vZHVsZS5leHBvcnRzID0gQXJndlxuXG5mdW5jdGlvbiBBcmd2IChwcm9jZXNzQXJncywgY3dkKSB7XG4gIGNvbnN0IGFyZ3YgPSB5YXJncyhwcm9jZXNzQXJncywgY3dkLCByZXF1aXJlKVxuICBzaW5nbGV0b25pZnkoYXJndilcbiAgcmV0dXJuIGFyZ3Zcbn1cblxuLyogIEhhY2sgYW4gaW5zdGFuY2Ugb2YgQXJndiB3aXRoIHByb2Nlc3MuYXJndiBpbnRvIEFyZ3ZcbiAgICBzbyBwZW9wbGUgY2FuIGRvXG4gICAgcmVxdWlyZSgneWFyZ3MnKShbJy0tYmVlYmxlPTEnLCcteicsJ3ppenpsZSddKS5hcmd2XG4gICAgdG8gcGFyc2UgYSBsaXN0IG9mIGFyZ3MgYW5kXG4gICAgcmVxdWlyZSgneWFyZ3MnKS5hcmd2XG4gICAgdG8gZ2V0IGEgcGFyc2VkIHZlcnNpb24gb2YgcHJvY2Vzcy5hcmd2LlxuKi9cbmZ1bmN0aW9uIHNpbmdsZXRvbmlmeSAoaW5zdCkge1xuICBPYmplY3Qua2V5cyhpbnN0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBpZiAoa2V5ID09PSAnYXJndicpIHtcbiAgICAgIEFyZ3YuX19kZWZpbmVHZXR0ZXJfXyhrZXksIGluc3QuX19sb29rdXBHZXR0ZXJfXyhrZXkpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3Rba2V5XSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgQXJndltrZXldID0gaW5zdFtrZXldLmJpbmQoaW5zdClcbiAgICB9IGVsc2Uge1xuICAgICAgQXJndi5fX2RlZmluZUdldHRlcl9fKCckMCcsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGluc3QuJDBcbiAgICAgIH0pXG4gICAgICBBcmd2Ll9fZGVmaW5lR2V0dGVyX18oJ3BhcnNlZCcsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGluc3QucGFyc2VkXG4gICAgICB9KVxuICAgIH1cbiAgfSlcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///49\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\n// an async function fails early in Node.js versions prior to 8.\nasync function requiresNode8OrGreater () {}\nrequiresNode8OrGreater()\n\nconst { Yargs, rebase } = __webpack_require__(19)\nconst Parser = __webpack_require__(12)\n\nexports = module.exports = Yargs\nexports.rebase = rebase\n\n// allow consumers to directly use the version of yargs-parser used by yargs\nexports.Parser = Parser\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MveWFyZ3MuanM/NjQyMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUEsT0FBTyxnQkFBZ0IsR0FBRyxtQkFBTyxDQUFDLEVBQW1CO0FBQ3JELGVBQWUsbUJBQU8sQ0FBQyxFQUFjOztBQUVyQztBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuLy8gYW4gYXN5bmMgZnVuY3Rpb24gZmFpbHMgZWFybHkgaW4gTm9kZS5qcyB2ZXJzaW9ucyBwcmlvciB0byA4LlxuYXN5bmMgZnVuY3Rpb24gcmVxdWlyZXNOb2RlOE9yR3JlYXRlciAoKSB7fVxucmVxdWlyZXNOb2RlOE9yR3JlYXRlcigpXG5cbmNvbnN0IHsgWWFyZ3MsIHJlYmFzZSB9ID0gcmVxdWlyZSgnLi9idWlsZC9saWIveWFyZ3MnKVxuY29uc3QgUGFyc2VyID0gcmVxdWlyZSgneWFyZ3MtcGFyc2VyJylcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gWWFyZ3NcbmV4cG9ydHMucmViYXNlID0gcmViYXNlXG5cbi8vIGFsbG93IGNvbnN1bWVycyB0byBkaXJlY3RseSB1c2UgdGhlIHZlcnNpb24gb2YgeWFyZ3MtcGFyc2VyIHVzZWQgYnkgeWFyZ3NcbmV4cG9ydHMuUGFyc2VyID0gUGFyc2VyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///50\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar fs = __webpack_require__(2),\n  join = __webpack_require__(0).join,\n  resolve = __webpack_require__(0).resolve,\n  dirname = __webpack_require__(0).dirname,\n  defaultOptions = {\n    extensions: ['js', 'json', 'coffee'],\n    recurse: true,\n    rename: function (name) {\n      return name;\n    },\n    visit: function (obj) {\n      return obj;\n    }\n  };\n\nfunction checkFileInclusion(path, filename, options) {\n  return (\n    // verify file has valid extension\n    (new RegExp('\\\\.(' + options.extensions.join('|') + ')$', 'i').test(filename)) &&\n\n    // if options.include is a RegExp, evaluate it and make sure the path passes\n    !(options.include && options.include instanceof RegExp && !options.include.test(path)) &&\n\n    // if options.include is a function, evaluate it and make sure the path passes\n    !(options.include && typeof options.include === 'function' && !options.include(path, filename)) &&\n\n    // if options.exclude is a RegExp, evaluate it and make sure the path doesn't pass\n    !(options.exclude && options.exclude instanceof RegExp && options.exclude.test(path)) &&\n\n    // if options.exclude is a function, evaluate it and make sure the path doesn't pass\n    !(options.exclude && typeof options.exclude === 'function' && options.exclude(path, filename))\n  );\n}\n\nfunction requireDirectory(m, path, options) {\n  var retval = {};\n\n  // path is optional\n  if (path && !options && typeof path !== 'string') {\n    options = path;\n    path = null;\n  }\n\n  // default options\n  options = options || {};\n  for (var prop in defaultOptions) {\n    if (typeof options[prop] === 'undefined') {\n      options[prop] = defaultOptions[prop];\n    }\n  }\n\n  // if no path was passed in, assume the equivelant of __dirname from caller\n  // otherwise, resolve path relative to the equivalent of __dirname\n  path = !path ? dirname(m.filename) : resolve(dirname(m.filename), path);\n\n  // get the path of each file in specified directory, append to current tree node, recurse\n  fs.readdirSync(path).forEach(function (filename) {\n    var joined = join(path, filename),\n      files,\n      key,\n      obj;\n\n    if (fs.statSync(joined).isDirectory() && options.recurse) {\n      // this node is a directory; recurse\n      files = requireDirectory(m, joined, options);\n      // exclude empty directories\n      if (Object.keys(files).length) {\n        retval[options.rename(filename, joined, filename)] = files;\n      }\n    } else {\n      if (joined !== m.filename && checkFileInclusion(joined, filename, options)) {\n        // hash node key shouldn't include file extension\n        key = filename.substring(0, filename.lastIndexOf('.'));\n        obj = m.require(joined);\n        retval[options.rename(key, joined, filename)] = options.visit(obj, joined, filename) || obj;\n      }\n    }\n  });\n\n  return retval;\n}\n\nmodule.exports = requireDirectory;\nmodule.exports.defaults = defaultOptions;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVxdWlyZS1kaXJlY3RvcnkvaW5kZXguanM/MmFhNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixTQUFTLG1CQUFPLENBQUMsQ0FBSTtBQUNyQixTQUFTLG1CQUFPLENBQUMsQ0FBTTtBQUN2QixZQUFZLG1CQUFPLENBQUMsQ0FBTTtBQUMxQixZQUFZLG1CQUFPLENBQUMsQ0FBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI1MS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGZzID0gcmVxdWlyZSgnZnMnKSxcbiAgam9pbiA9IHJlcXVpcmUoJ3BhdGgnKS5qb2luLFxuICByZXNvbHZlID0gcmVxdWlyZSgncGF0aCcpLnJlc29sdmUsXG4gIGRpcm5hbWUgPSByZXF1aXJlKCdwYXRoJykuZGlybmFtZSxcbiAgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgZXh0ZW5zaW9uczogWydqcycsICdqc29uJywgJ2NvZmZlZSddLFxuICAgIHJlY3Vyc2U6IHRydWUsXG4gICAgcmVuYW1lOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfSxcbiAgICB2aXNpdDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gIH07XG5cbmZ1bmN0aW9uIGNoZWNrRmlsZUluY2x1c2lvbihwYXRoLCBmaWxlbmFtZSwgb3B0aW9ucykge1xuICByZXR1cm4gKFxuICAgIC8vIHZlcmlmeSBmaWxlIGhhcyB2YWxpZCBleHRlbnNpb25cbiAgICAobmV3IFJlZ0V4cCgnXFxcXC4oJyArIG9wdGlvbnMuZXh0ZW5zaW9ucy5qb2luKCd8JykgKyAnKSQnLCAnaScpLnRlc3QoZmlsZW5hbWUpKSAmJlxuXG4gICAgLy8gaWYgb3B0aW9ucy5pbmNsdWRlIGlzIGEgUmVnRXhwLCBldmFsdWF0ZSBpdCBhbmQgbWFrZSBzdXJlIHRoZSBwYXRoIHBhc3Nlc1xuICAgICEob3B0aW9ucy5pbmNsdWRlICYmIG9wdGlvbnMuaW5jbHVkZSBpbnN0YW5jZW9mIFJlZ0V4cCAmJiAhb3B0aW9ucy5pbmNsdWRlLnRlc3QocGF0aCkpICYmXG5cbiAgICAvLyBpZiBvcHRpb25zLmluY2x1ZGUgaXMgYSBmdW5jdGlvbiwgZXZhbHVhdGUgaXQgYW5kIG1ha2Ugc3VyZSB0aGUgcGF0aCBwYXNzZXNcbiAgICAhKG9wdGlvbnMuaW5jbHVkZSAmJiB0eXBlb2Ygb3B0aW9ucy5pbmNsdWRlID09PSAnZnVuY3Rpb24nICYmICFvcHRpb25zLmluY2x1ZGUocGF0aCwgZmlsZW5hbWUpKSAmJlxuXG4gICAgLy8gaWYgb3B0aW9ucy5leGNsdWRlIGlzIGEgUmVnRXhwLCBldmFsdWF0ZSBpdCBhbmQgbWFrZSBzdXJlIHRoZSBwYXRoIGRvZXNuJ3QgcGFzc1xuICAgICEob3B0aW9ucy5leGNsdWRlICYmIG9wdGlvbnMuZXhjbHVkZSBpbnN0YW5jZW9mIFJlZ0V4cCAmJiBvcHRpb25zLmV4Y2x1ZGUudGVzdChwYXRoKSkgJiZcblxuICAgIC8vIGlmIG9wdGlvbnMuZXhjbHVkZSBpcyBhIGZ1bmN0aW9uLCBldmFsdWF0ZSBpdCBhbmQgbWFrZSBzdXJlIHRoZSBwYXRoIGRvZXNuJ3QgcGFzc1xuICAgICEob3B0aW9ucy5leGNsdWRlICYmIHR5cGVvZiBvcHRpb25zLmV4Y2x1ZGUgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy5leGNsdWRlKHBhdGgsIGZpbGVuYW1lKSlcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVxdWlyZURpcmVjdG9yeShtLCBwYXRoLCBvcHRpb25zKSB7XG4gIHZhciByZXR2YWwgPSB7fTtcblxuICAvLyBwYXRoIGlzIG9wdGlvbmFsXG4gIGlmIChwYXRoICYmICFvcHRpb25zICYmIHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSBwYXRoO1xuICAgIHBhdGggPSBudWxsO1xuICB9XG5cbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIGRlZmF1bHRPcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zW3Byb3BdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgb3B0aW9uc1twcm9wXSA9IGRlZmF1bHRPcHRpb25zW3Byb3BdO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIG5vIHBhdGggd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoZSBlcXVpdmVsYW50IG9mIF9fZGlybmFtZSBmcm9tIGNhbGxlclxuICAvLyBvdGhlcndpc2UsIHJlc29sdmUgcGF0aCByZWxhdGl2ZSB0byB0aGUgZXF1aXZhbGVudCBvZiBfX2Rpcm5hbWVcbiAgcGF0aCA9ICFwYXRoID8gZGlybmFtZShtLmZpbGVuYW1lKSA6IHJlc29sdmUoZGlybmFtZShtLmZpbGVuYW1lKSwgcGF0aCk7XG5cbiAgLy8gZ2V0IHRoZSBwYXRoIG9mIGVhY2ggZmlsZSBpbiBzcGVjaWZpZWQgZGlyZWN0b3J5LCBhcHBlbmQgdG8gY3VycmVudCB0cmVlIG5vZGUsIHJlY3Vyc2VcbiAgZnMucmVhZGRpclN5bmMocGF0aCkuZm9yRWFjaChmdW5jdGlvbiAoZmlsZW5hbWUpIHtcbiAgICB2YXIgam9pbmVkID0gam9pbihwYXRoLCBmaWxlbmFtZSksXG4gICAgICBmaWxlcyxcbiAgICAgIGtleSxcbiAgICAgIG9iajtcblxuICAgIGlmIChmcy5zdGF0U3luYyhqb2luZWQpLmlzRGlyZWN0b3J5KCkgJiYgb3B0aW9ucy5yZWN1cnNlKSB7XG4gICAgICAvLyB0aGlzIG5vZGUgaXMgYSBkaXJlY3Rvcnk7IHJlY3Vyc2VcbiAgICAgIGZpbGVzID0gcmVxdWlyZURpcmVjdG9yeShtLCBqb2luZWQsIG9wdGlvbnMpO1xuICAgICAgLy8gZXhjbHVkZSBlbXB0eSBkaXJlY3Rvcmllc1xuICAgICAgaWYgKE9iamVjdC5rZXlzKGZpbGVzKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dmFsW29wdGlvbnMucmVuYW1lKGZpbGVuYW1lLCBqb2luZWQsIGZpbGVuYW1lKV0gPSBmaWxlcztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGpvaW5lZCAhPT0gbS5maWxlbmFtZSAmJiBjaGVja0ZpbGVJbmNsdXNpb24oam9pbmVkLCBmaWxlbmFtZSwgb3B0aW9ucykpIHtcbiAgICAgICAgLy8gaGFzaCBub2RlIGtleSBzaG91bGRuJ3QgaW5jbHVkZSBmaWxlIGV4dGVuc2lvblxuICAgICAgICBrZXkgPSBmaWxlbmFtZS5zdWJzdHJpbmcoMCwgZmlsZW5hbWUubGFzdEluZGV4T2YoJy4nKSk7XG4gICAgICAgIG9iaiA9IG0ucmVxdWlyZShqb2luZWQpO1xuICAgICAgICByZXR2YWxbb3B0aW9ucy5yZW5hbWUoa2V5LCBqb2luZWQsIGZpbGVuYW1lKV0gPSBvcHRpb25zLnZpc2l0KG9iaiwgam9pbmVkLCBmaWxlbmFtZSkgfHwgb2JqO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJldHZhbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlRGlyZWN0b3J5O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdHMgPSBkZWZhdWx0T3B0aW9ucztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///51\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = function whichModule (exported) {\n  for (var i = 0, files = Object.keys(__webpack_require__.c), mod; i < files.length; i++) {\n    mod = __webpack_require__.c[files[i]]\n    if (mod.exports === exported) return mod\n  }\n  return null\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd2hpY2gtbW9kdWxlL2luZGV4LmpzPzZlNWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQSxzQ0FBc0MscUJBQWEsT0FBTyxrQkFBa0I7QUFDNUUsVUFBVSxxQkFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI1Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHdoaWNoTW9kdWxlIChleHBvcnRlZCkge1xuICBmb3IgKHZhciBpID0gMCwgZmlsZXMgPSBPYmplY3Qua2V5cyhyZXF1aXJlLmNhY2hlKSwgbW9kOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBtb2QgPSByZXF1aXJlLmNhY2hlW2ZpbGVzW2ldXVxuICAgIGlmIChtb2QuZXhwb3J0cyA9PT0gZXhwb3J0ZWQpIHJldHVybiBtb2RcbiAgfVxuICByZXR1cm4gbnVsbFxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///52\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nconst preserveCamelCase = string => {\n\tlet isLastCharLower = false;\n\tlet isLastCharUpper = false;\n\tlet isLastLastCharUpper = false;\n\n\tfor (let i = 0; i < string.length; i++) {\n\t\tconst character = string[i];\n\n\t\tif (isLastCharLower && /[a-zA-Z]/.test(character) && character.toUpperCase() === character) {\n\t\t\tstring = string.slice(0, i) + '-' + string.slice(i);\n\t\t\tisLastCharLower = false;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = true;\n\t\t\ti++;\n\t\t} else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(character) && character.toLowerCase() === character) {\n\t\t\tstring = string.slice(0, i - 1) + '-' + string.slice(i - 1);\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = false;\n\t\t\tisLastCharLower = true;\n\t\t} else {\n\t\t\tisLastCharLower = character.toLowerCase() === character && character.toUpperCase() !== character;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = character.toUpperCase() === character && character.toLowerCase() !== character;\n\t\t}\n\t}\n\n\treturn string;\n};\n\nconst camelCase = (input, options) => {\n\tif (!(typeof input === 'string' || Array.isArray(input))) {\n\t\tthrow new TypeError('Expected the input to be `string | string[]`');\n\t}\n\n\toptions = Object.assign({\n\t\tpascalCase: false\n\t}, options);\n\n\tconst postProcess = x => options.pascalCase ? x.charAt(0).toUpperCase() + x.slice(1) : x;\n\n\tif (Array.isArray(input)) {\n\t\tinput = input.map(x => x.trim())\n\t\t\t.filter(x => x.length)\n\t\t\t.join('-');\n\t} else {\n\t\tinput = input.trim();\n\t}\n\n\tif (input.length === 0) {\n\t\treturn '';\n\t}\n\n\tif (input.length === 1) {\n\t\treturn options.pascalCase ? input.toUpperCase() : input.toLowerCase();\n\t}\n\n\tconst hasUpperCase = input !== input.toLowerCase();\n\n\tif (hasUpperCase) {\n\t\tinput = preserveCamelCase(input);\n\t}\n\n\tinput = input\n\t\t.replace(/^[_.\\- ]+/, '')\n\t\t.toLowerCase()\n\t\t.replace(/[_.\\- ]+(\\w|$)/g, (_, p1) => p1.toUpperCase())\n\t\t.replace(/\\d+(\\w|$)/g, m => m.toUpperCase());\n\n\treturn postProcess(input);\n};\n\nmodule.exports = camelCase;\n// TODO: Remove this for the next major release\nmodule.exports.default = camelCase;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2FtZWxjYXNlL2luZGV4LmpzP2FiYzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFtQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiI1My5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgcHJlc2VydmVDYW1lbENhc2UgPSBzdHJpbmcgPT4ge1xuXHRsZXQgaXNMYXN0Q2hhckxvd2VyID0gZmFsc2U7XG5cdGxldCBpc0xhc3RDaGFyVXBwZXIgPSBmYWxzZTtcblx0bGV0IGlzTGFzdExhc3RDaGFyVXBwZXIgPSBmYWxzZTtcblxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuXHRcdGNvbnN0IGNoYXJhY3RlciA9IHN0cmluZ1tpXTtcblxuXHRcdGlmIChpc0xhc3RDaGFyTG93ZXIgJiYgL1thLXpBLVpdLy50ZXN0KGNoYXJhY3RlcikgJiYgY2hhcmFjdGVyLnRvVXBwZXJDYXNlKCkgPT09IGNoYXJhY3Rlcikge1xuXHRcdFx0c3RyaW5nID0gc3RyaW5nLnNsaWNlKDAsIGkpICsgJy0nICsgc3RyaW5nLnNsaWNlKGkpO1xuXHRcdFx0aXNMYXN0Q2hhckxvd2VyID0gZmFsc2U7XG5cdFx0XHRpc0xhc3RMYXN0Q2hhclVwcGVyID0gaXNMYXN0Q2hhclVwcGVyO1xuXHRcdFx0aXNMYXN0Q2hhclVwcGVyID0gdHJ1ZTtcblx0XHRcdGkrKztcblx0XHR9IGVsc2UgaWYgKGlzTGFzdENoYXJVcHBlciAmJiBpc0xhc3RMYXN0Q2hhclVwcGVyICYmIC9bYS16QS1aXS8udGVzdChjaGFyYWN0ZXIpICYmIGNoYXJhY3Rlci50b0xvd2VyQ2FzZSgpID09PSBjaGFyYWN0ZXIpIHtcblx0XHRcdHN0cmluZyA9IHN0cmluZy5zbGljZSgwLCBpIC0gMSkgKyAnLScgKyBzdHJpbmcuc2xpY2UoaSAtIDEpO1xuXHRcdFx0aXNMYXN0TGFzdENoYXJVcHBlciA9IGlzTGFzdENoYXJVcHBlcjtcblx0XHRcdGlzTGFzdENoYXJVcHBlciA9IGZhbHNlO1xuXHRcdFx0aXNMYXN0Q2hhckxvd2VyID0gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aXNMYXN0Q2hhckxvd2VyID0gY2hhcmFjdGVyLnRvTG93ZXJDYXNlKCkgPT09IGNoYXJhY3RlciAmJiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKSAhPT0gY2hhcmFjdGVyO1xuXHRcdFx0aXNMYXN0TGFzdENoYXJVcHBlciA9IGlzTGFzdENoYXJVcHBlcjtcblx0XHRcdGlzTGFzdENoYXJVcHBlciA9IGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpID09PSBjaGFyYWN0ZXIgJiYgY2hhcmFjdGVyLnRvTG93ZXJDYXNlKCkgIT09IGNoYXJhY3Rlcjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3RyaW5nO1xufTtcblxuY29uc3QgY2FtZWxDYXNlID0gKGlucHV0LCBvcHRpb25zKSA9PiB7XG5cdGlmICghKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgfHwgQXJyYXkuaXNBcnJheShpbnB1dCkpKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgdGhlIGlucHV0IHRvIGJlIGBzdHJpbmcgfCBzdHJpbmdbXWAnKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRwYXNjYWxDYXNlOiBmYWxzZVxuXHR9LCBvcHRpb25zKTtcblxuXHRjb25zdCBwb3N0UHJvY2VzcyA9IHggPT4gb3B0aW9ucy5wYXNjYWxDYXNlID8geC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHguc2xpY2UoMSkgOiB4O1xuXG5cdGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuXHRcdGlucHV0ID0gaW5wdXQubWFwKHggPT4geC50cmltKCkpXG5cdFx0XHQuZmlsdGVyKHggPT4geC5sZW5ndGgpXG5cdFx0XHQuam9pbignLScpO1xuXHR9IGVsc2Uge1xuXHRcdGlucHV0ID0gaW5wdXQudHJpbSgpO1xuXHR9XG5cblx0aWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXG5cdGlmIChpbnB1dC5sZW5ndGggPT09IDEpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5wYXNjYWxDYXNlID8gaW5wdXQudG9VcHBlckNhc2UoKSA6IGlucHV0LnRvTG93ZXJDYXNlKCk7XG5cdH1cblxuXHRjb25zdCBoYXNVcHBlckNhc2UgPSBpbnB1dCAhPT0gaW5wdXQudG9Mb3dlckNhc2UoKTtcblxuXHRpZiAoaGFzVXBwZXJDYXNlKSB7XG5cdFx0aW5wdXQgPSBwcmVzZXJ2ZUNhbWVsQ2FzZShpbnB1dCk7XG5cdH1cblxuXHRpbnB1dCA9IGlucHV0XG5cdFx0LnJlcGxhY2UoL15bXy5cXC0gXSsvLCAnJylcblx0XHQudG9Mb3dlckNhc2UoKVxuXHRcdC5yZXBsYWNlKC9bXy5cXC0gXSsoXFx3fCQpL2csIChfLCBwMSkgPT4gcDEudG9VcHBlckNhc2UoKSlcblx0XHQucmVwbGFjZSgvXFxkKyhcXHd8JCkvZywgbSA9PiBtLnRvVXBwZXJDYXNlKCkpO1xuXG5cdHJldHVybiBwb3N0UHJvY2VzcyhpbnB1dCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsQ2FzZTtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gY2FtZWxDYXNlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///53\n")},function(module,exports){eval("// take an un-split argv string and tokenize it.\nmodule.exports = function (argString) {\n  if (Array.isArray(argString)) {\n    return argString.map(e => typeof e !== 'string' ? e + '' : e)\n  }\n\n  argString = argString.trim()\n\n  let i = 0\n  let prevC = null\n  let c = null\n  let opening = null\n  const args = []\n\n  for (let ii = 0; ii < argString.length; ii++) {\n    prevC = c\n    c = argString.charAt(ii)\n\n    // split on spaces unless we're in quotes.\n    if (c === ' ' && !opening) {\n      if (!(prevC === ' ')) {\n        i++\n      }\n      continue\n    }\n\n    // don't split the string if we're in matching\n    // opening or closing single and double quotes.\n    if (c === opening) {\n      opening = null\n    } else if ((c === \"'\" || c === '\"') && !opening) {\n      opening = c\n    }\n\n    if (!args[i]) args[i] = ''\n    args[i] += c\n  }\n\n  return args\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MtcGFyc2VyL2xpYi90b2tlbml6ZS1hcmctc3RyaW5nLmpzP2I3MTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjU0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gdGFrZSBhbiB1bi1zcGxpdCBhcmd2IHN0cmluZyBhbmQgdG9rZW5pemUgaXQuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmdTdHJpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJnU3RyaW5nKSkge1xuICAgIHJldHVybiBhcmdTdHJpbmcubWFwKGUgPT4gdHlwZW9mIGUgIT09ICdzdHJpbmcnID8gZSArICcnIDogZSlcbiAgfVxuXG4gIGFyZ1N0cmluZyA9IGFyZ1N0cmluZy50cmltKClcblxuICBsZXQgaSA9IDBcbiAgbGV0IHByZXZDID0gbnVsbFxuICBsZXQgYyA9IG51bGxcbiAgbGV0IG9wZW5pbmcgPSBudWxsXG4gIGNvbnN0IGFyZ3MgPSBbXVxuXG4gIGZvciAobGV0IGlpID0gMDsgaWkgPCBhcmdTdHJpbmcubGVuZ3RoOyBpaSsrKSB7XG4gICAgcHJldkMgPSBjXG4gICAgYyA9IGFyZ1N0cmluZy5jaGFyQXQoaWkpXG5cbiAgICAvLyBzcGxpdCBvbiBzcGFjZXMgdW5sZXNzIHdlJ3JlIGluIHF1b3Rlcy5cbiAgICBpZiAoYyA9PT0gJyAnICYmICFvcGVuaW5nKSB7XG4gICAgICBpZiAoIShwcmV2QyA9PT0gJyAnKSkge1xuICAgICAgICBpKytcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgLy8gZG9uJ3Qgc3BsaXQgdGhlIHN0cmluZyBpZiB3ZSdyZSBpbiBtYXRjaGluZ1xuICAgIC8vIG9wZW5pbmcgb3IgY2xvc2luZyBzaW5nbGUgYW5kIGRvdWJsZSBxdW90ZXMuXG4gICAgaWYgKGMgPT09IG9wZW5pbmcpIHtcbiAgICAgIG9wZW5pbmcgPSBudWxsXG4gICAgfSBlbHNlIGlmICgoYyA9PT0gXCInXCIgfHwgYyA9PT0gJ1wiJykgJiYgIW9wZW5pbmcpIHtcbiAgICAgIG9wZW5pbmcgPSBjXG4gICAgfVxuXG4gICAgaWYgKCFhcmdzW2ldKSBhcmdzW2ldID0gJydcbiAgICBhcmdzW2ldICs9IGNcbiAgfVxuXG4gIHJldHVybiBhcmdzXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///54\n")},function(module,exports){eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 55;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MtcGFyc2VyIHN5bmM/NWY1ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBIiwiZmlsZSI6IjU1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gd2VicGFja0VtcHR5Q29udGV4dChyZXEpIHtcblx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdHRocm93IGU7XG59XG53ZWJwYWNrRW1wdHlDb250ZXh0LmtleXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9O1xud2VicGFja0VtcHR5Q29udGV4dC5yZXNvbHZlID0gd2VicGFja0VtcHR5Q29udGV4dDtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0VtcHR5Q29udGV4dDtcbndlYnBhY2tFbXB0eUNvbnRleHQuaWQgPSA1NTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///55\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.usage = void 0;\n// this file handles outputting usage instructions,\n// failures, etc. keeps logging in one place.\nconst common_types_1 = __webpack_require__(1);\nconst obj_filter_1 = __webpack_require__(13);\nconst path = __webpack_require__(0);\nconst yerror_1 = __webpack_require__(6);\nconst decamelize = __webpack_require__(22);\nconst setBlocking = __webpack_require__(23);\nconst stringWidth = __webpack_require__(14);\nfunction usage(yargs, y18n) {\n    const __ = y18n.__;\n    const self = {};\n    // methods for ouputting/building failure message.\n    const fails = [];\n    self.failFn = function failFn(f) {\n        fails.push(f);\n    };\n    let failMessage = null;\n    let showHelpOnFail = true;\n    self.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {\n        function parseFunctionArgs() {\n            return typeof arg1 === 'string' ? [true, arg1] : [arg1, arg2];\n        }\n        const [enabled, message] = parseFunctionArgs();\n        failMessage = message;\n        showHelpOnFail = enabled;\n        return self;\n    };\n    let failureOutput = false;\n    self.fail = function fail(msg, err) {\n        const logger = yargs._getLoggerInstance();\n        if (fails.length) {\n            for (let i = fails.length - 1; i >= 0; --i) {\n                fails[i](msg, err, self);\n            }\n        }\n        else {\n            if (yargs.getExitProcess())\n                setBlocking(true);\n            // don't output failure message more than once\n            if (!failureOutput) {\n                failureOutput = true;\n                if (showHelpOnFail) {\n                    yargs.showHelp('error');\n                    logger.error();\n                }\n                if (msg || err)\n                    logger.error(msg || err);\n                if (failMessage) {\n                    if (msg || err)\n                        logger.error('');\n                    logger.error(failMessage);\n                }\n            }\n            err = err || new yerror_1.YError(msg);\n            if (yargs.getExitProcess()) {\n                return yargs.exit(1);\n            }\n            else if (yargs._hasParseCallback()) {\n                return yargs.exit(1, err);\n            }\n            else {\n                throw err;\n            }\n        }\n    };\n    // methods for ouputting/building help (usage) message.\n    let usages = [];\n    let usageDisabled = false;\n    self.usage = (msg, description) => {\n        if (msg === null) {\n            usageDisabled = true;\n            usages = [];\n            return self;\n        }\n        usageDisabled = false;\n        usages.push([msg, description || '']);\n        return self;\n    };\n    self.getUsage = () => {\n        return usages;\n    };\n    self.getUsageDisabled = () => {\n        return usageDisabled;\n    };\n    self.getPositionalGroupName = () => {\n        return __('Positionals:');\n    };\n    let examples = [];\n    self.example = (cmd, description) => {\n        examples.push([cmd, description || '']);\n    };\n    let commands = [];\n    self.command = function command(cmd, description, isDefault, aliases, deprecated = false) {\n        // the last default wins, so cancel out any previously set default\n        if (isDefault) {\n            commands = commands.map((cmdArray) => {\n                cmdArray[2] = false;\n                return cmdArray;\n            });\n        }\n        commands.push([cmd, description || '', isDefault, aliases, deprecated]);\n    };\n    self.getCommands = () => commands;\n    let descriptions = {};\n    self.describe = function describe(keyOrKeys, desc) {\n        if (Array.isArray(keyOrKeys)) {\n            keyOrKeys.forEach((k) => {\n                self.describe(k, desc);\n            });\n        }\n        else if (typeof keyOrKeys === 'object') {\n            Object.keys(keyOrKeys).forEach((k) => {\n                self.describe(k, keyOrKeys[k]);\n            });\n        }\n        else {\n            descriptions[keyOrKeys] = desc;\n        }\n    };\n    self.getDescriptions = () => descriptions;\n    let epilogs = [];\n    self.epilog = (msg) => {\n        epilogs.push(msg);\n    };\n    let wrapSet = false;\n    let wrap;\n    self.wrap = (cols) => {\n        wrapSet = true;\n        wrap = cols;\n    };\n    function getWrap() {\n        if (!wrapSet) {\n            wrap = windowWidth();\n            wrapSet = true;\n        }\n        return wrap;\n    }\n    const deferY18nLookupPrefix = '__yargsString__:';\n    self.deferY18nLookup = str => deferY18nLookupPrefix + str;\n    self.help = function help() {\n        if (cachedHelpMessage)\n            return cachedHelpMessage;\n        normalizeAliases();\n        // handle old demanded API\n        const base$0 = yargs.customScriptName ? yargs.$0 : path.basename(yargs.$0);\n        const demandedOptions = yargs.getDemandedOptions();\n        const demandedCommands = yargs.getDemandedCommands();\n        const deprecatedOptions = yargs.getDeprecatedOptions();\n        const groups = yargs.getGroups();\n        const options = yargs.getOptions();\n        let keys = [];\n        keys = keys.concat(Object.keys(descriptions));\n        keys = keys.concat(Object.keys(demandedOptions));\n        keys = keys.concat(Object.keys(demandedCommands));\n        keys = keys.concat(Object.keys(options.default));\n        keys = keys.filter(filterHiddenOptions);\n        keys = Object.keys(keys.reduce((acc, key) => {\n            if (key !== '_')\n                acc[key] = true;\n            return acc;\n        }, {}));\n        const theWrap = getWrap();\n        const ui = __webpack_require__(59)({\n            width: theWrap,\n            wrap: !!theWrap\n        });\n        // the usage string.\n        if (!usageDisabled) {\n            if (usages.length) {\n                // user-defined usage.\n                usages.forEach((usage) => {\n                    ui.div(`${usage[0].replace(/\\$0/g, base$0)}`);\n                    if (usage[1]) {\n                        ui.div({ text: `${usage[1]}`, padding: [1, 0, 0, 0] });\n                    }\n                });\n                ui.div();\n            }\n            else if (commands.length) {\n                let u = null;\n                // demonstrate how commands are used.\n                if (demandedCommands._) {\n                    u = `${base$0} <${__('command')}>\\n`;\n                }\n                else {\n                    u = `${base$0} [${__('command')}]\\n`;\n                }\n                ui.div(`${u}`);\n            }\n        }\n        // your application's commands, i.e., non-option\n        // arguments populated in '_'.\n        if (commands.length) {\n            ui.div(__('Commands:'));\n            const context = yargs.getContext();\n            const parentCommands = context.commands.length ? `${context.commands.join(' ')} ` : '';\n            if (yargs.getParserConfiguration()['sort-commands'] === true) {\n                commands = commands.sort((a, b) => a[0].localeCompare(b[0]));\n            }\n            commands.forEach((command) => {\n                const commandString = `${base$0} ${parentCommands}${command[0].replace(/^\\$0 ?/, '')}`; // drop $0 from default commands.\n                ui.span({\n                    text: commandString,\n                    padding: [0, 2, 0, 2],\n                    width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4\n                }, { text: command[1] });\n                const hints = [];\n                if (command[2])\n                    hints.push(`[${__('default')}]`);\n                if (command[3] && command[3].length) {\n                    hints.push(`[${__('aliases:')} ${command[3].join(', ')}]`);\n                }\n                if (command[4]) {\n                    if (typeof command[4] === 'string') {\n                        hints.push(`[${__('deprecated: %s', command[4])}]`);\n                    }\n                    else {\n                        hints.push(`[${__('deprecated')}]`);\n                    }\n                }\n                if (hints.length) {\n                    ui.div({ text: hints.join(' '), padding: [0, 0, 0, 2], align: 'right' });\n                }\n                else {\n                    ui.div();\n                }\n            });\n            ui.div();\n        }\n        // perform some cleanup on the keys array, making it\n        // only include top-level keys not their aliases.\n        const aliasKeys = (Object.keys(options.alias) || [])\n            .concat(Object.keys(yargs.parsed.newAliases) || []);\n        keys = keys.filter(key => !yargs.parsed.newAliases[key] && aliasKeys.every(alias => (options.alias[alias] || []).indexOf(key) === -1));\n        // populate 'Options:' group with any keys that have not\n        // explicitly had a group set.\n        const defaultGroup = __('Options:');\n        if (!groups[defaultGroup])\n            groups[defaultGroup] = [];\n        addUngroupedKeys(keys, options.alias, groups, defaultGroup);\n        // display 'Options:' table along with any custom tables:\n        Object.keys(groups).forEach((groupName) => {\n            if (!groups[groupName].length)\n                return;\n            // if we've grouped the key 'f', but 'f' aliases 'foobar',\n            // normalizedKeys should contain only 'foobar'.\n            const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key) => {\n                if (~aliasKeys.indexOf(key))\n                    return key;\n                for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {\n                    if (~(options.alias[aliasKey] || []).indexOf(key))\n                        return aliasKey;\n                }\n                return key;\n            });\n            if (normalizedKeys.length < 1)\n                return;\n            ui.div(groupName);\n            // actually generate the switches string --foo, -f, --bar.\n            const switches = normalizedKeys.reduce((acc, key) => {\n                acc[key] = [key].concat(options.alias[key] || [])\n                    .map(sw => {\n                    // for the special positional group don't\n                    // add '--' or '-' prefix.\n                    if (groupName === self.getPositionalGroupName())\n                        return sw;\n                    else {\n                        return (\n                        // matches yargs-parser logic in which single-digits\n                        // aliases declared with a boolean type are now valid\n                        /^[0-9]$/.test(sw)\n                            ? ~options.boolean.indexOf(key) ? '-' : '--'\n                            : sw.length > 1 ? '--' : '-') + sw;\n                    }\n                })\n                    .join(', ');\n                return acc;\n            }, {});\n            normalizedKeys.forEach((key) => {\n                const kswitch = switches[key];\n                let desc = descriptions[key] || '';\n                let type = null;\n                if (~desc.lastIndexOf(deferY18nLookupPrefix))\n                    desc = __(desc.substring(deferY18nLookupPrefix.length));\n                if (~options.boolean.indexOf(key))\n                    type = `[${__('boolean')}]`;\n                if (~options.count.indexOf(key))\n                    type = `[${__('count')}]`;\n                if (~options.string.indexOf(key))\n                    type = `[${__('string')}]`;\n                if (~options.normalize.indexOf(key))\n                    type = `[${__('string')}]`;\n                if (~options.array.indexOf(key))\n                    type = `[${__('array')}]`;\n                if (~options.number.indexOf(key))\n                    type = `[${__('number')}]`;\n                const deprecatedExtra = (deprecated) => typeof deprecated === 'string'\n                    ? `[${__('deprecated: %s', deprecated)}]`\n                    : `[${__('deprecated')}]`;\n                const extra = [\n                    (key in deprecatedOptions) ? deprecatedExtra(deprecatedOptions[key]) : null,\n                    type,\n                    (key in demandedOptions) ? `[${__('required')}]` : null,\n                    options.choices && options.choices[key] ? `[${__('choices:')} ${self.stringifiedValues(options.choices[key])}]` : null,\n                    defaultString(options.default[key], options.defaultDescription[key])\n                ].filter(Boolean).join(' ');\n                ui.span({ text: kswitch, padding: [0, 2, 0, 2], width: maxWidth(switches, theWrap) + 4 }, desc);\n                if (extra)\n                    ui.div({ text: extra, padding: [0, 0, 0, 2], align: 'right' });\n                else\n                    ui.div();\n            });\n            ui.div();\n        });\n        // describe some common use-cases for your application.\n        if (examples.length) {\n            ui.div(__('Examples:'));\n            examples.forEach((example) => {\n                example[0] = example[0].replace(/\\$0/g, base$0);\n            });\n            examples.forEach((example) => {\n                if (example[1] === '') {\n                    ui.div({\n                        text: example[0],\n                        padding: [0, 2, 0, 2]\n                    });\n                }\n                else {\n                    ui.div({\n                        text: example[0],\n                        padding: [0, 2, 0, 2],\n                        width: maxWidth(examples, theWrap) + 4\n                    }, {\n                        text: example[1]\n                    });\n                }\n            });\n            ui.div();\n        }\n        // the usage string.\n        if (epilogs.length > 0) {\n            const e = epilogs.map(epilog => epilog.replace(/\\$0/g, base$0)).join('\\n');\n            ui.div(`${e}\\n`);\n        }\n        // Remove the trailing white spaces\n        return ui.toString().replace(/\\s*$/, '');\n    };\n    // return the maximum width of a string\n    // in the left-hand column of a table.\n    function maxWidth(table, theWrap, modifier) {\n        let width = 0;\n        // table might be of the form [leftColumn],\n        // or {key: leftColumn}\n        if (!Array.isArray(table)) {\n            table = Object.values(table).map(v => [v]);\n        }\n        table.forEach((v) => {\n            width = Math.max(stringWidth(modifier ? `${modifier} ${v[0]}` : v[0]), width);\n        });\n        // if we've enabled 'wrap' we should limit\n        // the max-width of the left-column.\n        if (theWrap)\n            width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));\n        return width;\n    }\n    // make sure any options set for aliases,\n    // are copied to the keys being aliased.\n    function normalizeAliases() {\n        // handle old demanded API\n        const demandedOptions = yargs.getDemandedOptions();\n        const options = yargs.getOptions();\n        (Object.keys(options.alias) || []).forEach((key) => {\n            options.alias[key].forEach((alias) => {\n                // copy descriptions.\n                if (descriptions[alias])\n                    self.describe(key, descriptions[alias]);\n                // copy demanded.\n                if (alias in demandedOptions)\n                    yargs.demandOption(key, demandedOptions[alias]);\n                // type messages.\n                if (~options.boolean.indexOf(alias))\n                    yargs.boolean(key);\n                if (~options.count.indexOf(alias))\n                    yargs.count(key);\n                if (~options.string.indexOf(alias))\n                    yargs.string(key);\n                if (~options.normalize.indexOf(alias))\n                    yargs.normalize(key);\n                if (~options.array.indexOf(alias))\n                    yargs.array(key);\n                if (~options.number.indexOf(alias))\n                    yargs.number(key);\n            });\n        });\n    }\n    // if yargs is executing an async handler, we take a snapshot of the\n    // help message to display on failure:\n    let cachedHelpMessage;\n    self.cacheHelpMessage = function () {\n        cachedHelpMessage = this.help();\n    };\n    // however this snapshot must be cleared afterwards\n    // not to be be used by next calls to parse\n    self.clearCachedHelpMessage = function () {\n        cachedHelpMessage = undefined;\n    };\n    // given a set of keys, place any keys that are\n    // ungrouped under the 'Options:' grouping.\n    function addUngroupedKeys(keys, aliases, groups, defaultGroup) {\n        let groupedKeys = [];\n        let toCheck = null;\n        Object.keys(groups).forEach((group) => {\n            groupedKeys = groupedKeys.concat(groups[group]);\n        });\n        keys.forEach((key) => {\n            toCheck = [key].concat(aliases[key]);\n            if (!toCheck.some(k => groupedKeys.indexOf(k) !== -1)) {\n                groups[defaultGroup].push(key);\n            }\n        });\n        return groupedKeys;\n    }\n    function filterHiddenOptions(key) {\n        return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];\n    }\n    self.showHelp = (level) => {\n        const logger = yargs._getLoggerInstance();\n        if (!level)\n            level = 'error';\n        const emit = typeof level === 'function' ? level : logger[level];\n        emit(self.help());\n    };\n    self.functionDescription = (fn) => {\n        const description = fn.name ? decamelize(fn.name, '-') : __('generated-value');\n        return ['(', description, ')'].join('');\n    };\n    self.stringifiedValues = function stringifiedValues(values, separator) {\n        let string = '';\n        const sep = separator || ', ';\n        const array = [].concat(values);\n        if (!values || !array.length)\n            return string;\n        array.forEach((value) => {\n            if (string.length)\n                string += sep;\n            string += JSON.stringify(value);\n        });\n        return string;\n    };\n    // format the default-value-string displayed in\n    // the right-hand column.\n    function defaultString(value, defaultDescription) {\n        let string = `[${__('default:')} `;\n        if (value === undefined && !defaultDescription)\n            return null;\n        if (defaultDescription) {\n            string += defaultDescription;\n        }\n        else {\n            switch (typeof value) {\n                case 'string':\n                    string += `\"${value}\"`;\n                    break;\n                case 'object':\n                    string += JSON.stringify(value);\n                    break;\n                default:\n                    string += value;\n            }\n        }\n        return `${string}]`;\n    }\n    // guess the width of the console window, max-width 80.\n    function windowWidth() {\n        const maxWidth = 80;\n        // CI is not a TTY\n        /* c8 ignore next 2 */\n        if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n            return Math.min(maxWidth, process.stdout.columns);\n        }\n        else {\n            return maxWidth;\n        }\n    }\n    // logic for displaying application version.\n    let version = null;\n    self.version = (ver) => {\n        version = ver;\n    };\n    self.showVersion = () => {\n        const logger = yargs._getLoggerInstance();\n        logger.log(version);\n    };\n    self.reset = function reset(localLookup) {\n        // do not reset wrap here\n        // do not reset fails here\n        failMessage = null;\n        failureOutput = false;\n        usages = [];\n        usageDisabled = false;\n        epilogs = [];\n        examples = [];\n        commands = [];\n        descriptions = obj_filter_1.objFilter(descriptions, k => !localLookup[k]);\n        return self;\n    };\n    const frozens = [];\n    self.freeze = function freeze() {\n        frozens.push({\n            failMessage,\n            failureOutput,\n            usages,\n            usageDisabled,\n            epilogs,\n            examples,\n            commands,\n            descriptions\n        });\n    };\n    self.unfreeze = function unfreeze() {\n        const frozen = frozens.pop();\n        common_types_1.assertNotStrictEqual(frozen, undefined);\n        ({\n            failMessage,\n            failureOutput,\n            usages,\n            usageDisabled,\n            epilogs,\n            examples,\n            commands,\n            descriptions\n        } = frozen);\n    };\n    return self;\n}\nexports.usage = usage;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliL3VzYWdlLmpzPzc2MGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyxDQUFnQjtBQUMvQyxxQkFBcUIsbUJBQU8sQ0FBQyxFQUFjO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyxDQUFNO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLENBQVU7QUFDbkMsbUJBQW1CLG1CQUFPLENBQUMsRUFBWTtBQUN2QyxvQkFBb0IsbUJBQU8sQ0FBQyxFQUFjO0FBQzFDLG9CQUFvQixtQkFBTyxDQUFDLEVBQWM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLEVBQU87QUFDbEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlDQUFpQztBQUMvRDtBQUNBLGdDQUFnQyxVQUFVLFNBQVMsMEJBQTBCO0FBQzdFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixPQUFPLElBQUksY0FBYztBQUNwRDtBQUNBO0FBQ0EsMkJBQTJCLE9BQU8sSUFBSSxjQUFjO0FBQ3BEO0FBQ0EsMEJBQTBCLEVBQUU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsMkJBQTJCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLE9BQU8sR0FBRyxlQUFlLEVBQUUsaUNBQWlDLEVBQUU7QUFDdkc7QUFDQTtBQUNBO0FBQ0EsMERBQTBELE9BQU8sRUFBRSxlQUFlO0FBQ2xGLGlCQUFpQixHQUFHLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQSxtQ0FBbUMsZUFBZSxHQUFHLHNCQUFzQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUNBQWlDO0FBQ3hFO0FBQ0E7QUFDQSx1Q0FBdUMsaUJBQWlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0Q7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseUNBQXlDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQSwwQkFBMEIsaUNBQWlDO0FBQzNELDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGVBQWU7QUFDbEUsa0VBQWtFLGVBQWUsR0FBRyw2Q0FBNkM7QUFDakk7QUFDQTtBQUNBLHlCQUF5QiwrRUFBK0U7QUFDeEc7QUFDQSw0QkFBNEIscURBQXFEO0FBQ2pGO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEVBQUU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFNBQVMsR0FBRyxLQUFLO0FBQ3hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxNQUFNO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI1Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51c2FnZSA9IHZvaWQgMDtcbi8vIHRoaXMgZmlsZSBoYW5kbGVzIG91dHB1dHRpbmcgdXNhZ2UgaW5zdHJ1Y3Rpb25zLFxuLy8gZmFpbHVyZXMsIGV0Yy4ga2VlcHMgbG9nZ2luZyBpbiBvbmUgcGxhY2UuXG5jb25zdCBjb21tb25fdHlwZXNfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi10eXBlc1wiKTtcbmNvbnN0IG9ial9maWx0ZXJfMSA9IHJlcXVpcmUoXCIuL29iai1maWx0ZXJcIik7XG5jb25zdCBwYXRoID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCB5ZXJyb3JfMSA9IHJlcXVpcmUoXCIuL3llcnJvclwiKTtcbmNvbnN0IGRlY2FtZWxpemUgPSByZXF1aXJlKFwiZGVjYW1lbGl6ZVwiKTtcbmNvbnN0IHNldEJsb2NraW5nID0gcmVxdWlyZShcInNldC1ibG9ja2luZ1wiKTtcbmNvbnN0IHN0cmluZ1dpZHRoID0gcmVxdWlyZShcInN0cmluZy13aWR0aFwiKTtcbmZ1bmN0aW9uIHVzYWdlKHlhcmdzLCB5MThuKSB7XG4gICAgY29uc3QgX18gPSB5MThuLl9fO1xuICAgIGNvbnN0IHNlbGYgPSB7fTtcbiAgICAvLyBtZXRob2RzIGZvciBvdXB1dHRpbmcvYnVpbGRpbmcgZmFpbHVyZSBtZXNzYWdlLlxuICAgIGNvbnN0IGZhaWxzID0gW107XG4gICAgc2VsZi5mYWlsRm4gPSBmdW5jdGlvbiBmYWlsRm4oZikge1xuICAgICAgICBmYWlscy5wdXNoKGYpO1xuICAgIH07XG4gICAgbGV0IGZhaWxNZXNzYWdlID0gbnVsbDtcbiAgICBsZXQgc2hvd0hlbHBPbkZhaWwgPSB0cnVlO1xuICAgIHNlbGYuc2hvd0hlbHBPbkZhaWwgPSBmdW5jdGlvbiBzaG93SGVscE9uRmFpbEZuKGFyZzEgPSB0cnVlLCBhcmcyKSB7XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlRnVuY3Rpb25BcmdzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBhcmcxID09PSAnc3RyaW5nJyA/IFt0cnVlLCBhcmcxXSA6IFthcmcxLCBhcmcyXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbZW5hYmxlZCwgbWVzc2FnZV0gPSBwYXJzZUZ1bmN0aW9uQXJncygpO1xuICAgICAgICBmYWlsTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHNob3dIZWxwT25GYWlsID0gZW5hYmxlZDtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBsZXQgZmFpbHVyZU91dHB1dCA9IGZhbHNlO1xuICAgIHNlbGYuZmFpbCA9IGZ1bmN0aW9uIGZhaWwobXNnLCBlcnIpIHtcbiAgICAgICAgY29uc3QgbG9nZ2VyID0geWFyZ3MuX2dldExvZ2dlckluc3RhbmNlKCk7XG4gICAgICAgIGlmIChmYWlscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBmYWlscy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgICAgIGZhaWxzW2ldKG1zZywgZXJyLCBzZWxmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh5YXJncy5nZXRFeGl0UHJvY2VzcygpKVxuICAgICAgICAgICAgICAgIHNldEJsb2NraW5nKHRydWUpO1xuICAgICAgICAgICAgLy8gZG9uJ3Qgb3V0cHV0IGZhaWx1cmUgbWVzc2FnZSBtb3JlIHRoYW4gb25jZVxuICAgICAgICAgICAgaWYgKCFmYWlsdXJlT3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZU91dHB1dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHNob3dIZWxwT25GYWlsKSB7XG4gICAgICAgICAgICAgICAgICAgIHlhcmdzLnNob3dIZWxwKCdlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1zZyB8fCBlcnIpXG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcihtc2cgfHwgZXJyKTtcbiAgICAgICAgICAgICAgICBpZiAoZmFpbE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1zZyB8fCBlcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJycpO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZmFpbE1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVyciA9IGVyciB8fCBuZXcgeWVycm9yXzEuWUVycm9yKG1zZyk7XG4gICAgICAgICAgICBpZiAoeWFyZ3MuZ2V0RXhpdFByb2Nlc3MoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5YXJncy5leGl0KDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoeWFyZ3MuX2hhc1BhcnNlQ2FsbGJhY2soKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5YXJncy5leGl0KDEsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIG1ldGhvZHMgZm9yIG91cHV0dGluZy9idWlsZGluZyBoZWxwICh1c2FnZSkgbWVzc2FnZS5cbiAgICBsZXQgdXNhZ2VzID0gW107XG4gICAgbGV0IHVzYWdlRGlzYWJsZWQgPSBmYWxzZTtcbiAgICBzZWxmLnVzYWdlID0gKG1zZywgZGVzY3JpcHRpb24pID0+IHtcbiAgICAgICAgaWYgKG1zZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdXNhZ2VEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB1c2FnZXMgPSBbXTtcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICB9XG4gICAgICAgIHVzYWdlRGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdXNhZ2VzLnB1c2goW21zZywgZGVzY3JpcHRpb24gfHwgJyddKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBzZWxmLmdldFVzYWdlID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gdXNhZ2VzO1xuICAgIH07XG4gICAgc2VsZi5nZXRVc2FnZURpc2FibGVkID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gdXNhZ2VEaXNhYmxlZDtcbiAgICB9O1xuICAgIHNlbGYuZ2V0UG9zaXRpb25hbEdyb3VwTmFtZSA9ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIF9fKCdQb3NpdGlvbmFsczonKTtcbiAgICB9O1xuICAgIGxldCBleGFtcGxlcyA9IFtdO1xuICAgIHNlbGYuZXhhbXBsZSA9IChjbWQsIGRlc2NyaXB0aW9uKSA9PiB7XG4gICAgICAgIGV4YW1wbGVzLnB1c2goW2NtZCwgZGVzY3JpcHRpb24gfHwgJyddKTtcbiAgICB9O1xuICAgIGxldCBjb21tYW5kcyA9IFtdO1xuICAgIHNlbGYuY29tbWFuZCA9IGZ1bmN0aW9uIGNvbW1hbmQoY21kLCBkZXNjcmlwdGlvbiwgaXNEZWZhdWx0LCBhbGlhc2VzLCBkZXByZWNhdGVkID0gZmFsc2UpIHtcbiAgICAgICAgLy8gdGhlIGxhc3QgZGVmYXVsdCB3aW5zLCBzbyBjYW5jZWwgb3V0IGFueSBwcmV2aW91c2x5IHNldCBkZWZhdWx0XG4gICAgICAgIGlmIChpc0RlZmF1bHQpIHtcbiAgICAgICAgICAgIGNvbW1hbmRzID0gY29tbWFuZHMubWFwKChjbWRBcnJheSkgPT4ge1xuICAgICAgICAgICAgICAgIGNtZEFycmF5WzJdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNtZEFycmF5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29tbWFuZHMucHVzaChbY21kLCBkZXNjcmlwdGlvbiB8fCAnJywgaXNEZWZhdWx0LCBhbGlhc2VzLCBkZXByZWNhdGVkXSk7XG4gICAgfTtcbiAgICBzZWxmLmdldENvbW1hbmRzID0gKCkgPT4gY29tbWFuZHM7XG4gICAgbGV0IGRlc2NyaXB0aW9ucyA9IHt9O1xuICAgIHNlbGYuZGVzY3JpYmUgPSBmdW5jdGlvbiBkZXNjcmliZShrZXlPcktleXMsIGRlc2MpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5T3JLZXlzKSkge1xuICAgICAgICAgICAga2V5T3JLZXlzLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLmRlc2NyaWJlKGssIGRlc2MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGtleU9yS2V5cyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGtleU9yS2V5cykuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYuZGVzY3JpYmUoaywga2V5T3JLZXlzW2tdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzY3JpcHRpb25zW2tleU9yS2V5c10gPSBkZXNjO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzZWxmLmdldERlc2NyaXB0aW9ucyA9ICgpID0+IGRlc2NyaXB0aW9ucztcbiAgICBsZXQgZXBpbG9ncyA9IFtdO1xuICAgIHNlbGYuZXBpbG9nID0gKG1zZykgPT4ge1xuICAgICAgICBlcGlsb2dzLnB1c2gobXNnKTtcbiAgICB9O1xuICAgIGxldCB3cmFwU2V0ID0gZmFsc2U7XG4gICAgbGV0IHdyYXA7XG4gICAgc2VsZi53cmFwID0gKGNvbHMpID0+IHtcbiAgICAgICAgd3JhcFNldCA9IHRydWU7XG4gICAgICAgIHdyYXAgPSBjb2xzO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZ2V0V3JhcCgpIHtcbiAgICAgICAgaWYgKCF3cmFwU2V0KSB7XG4gICAgICAgICAgICB3cmFwID0gd2luZG93V2lkdGgoKTtcbiAgICAgICAgICAgIHdyYXBTZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3cmFwO1xuICAgIH1cbiAgICBjb25zdCBkZWZlclkxOG5Mb29rdXBQcmVmaXggPSAnX195YXJnc1N0cmluZ19fOic7XG4gICAgc2VsZi5kZWZlclkxOG5Mb29rdXAgPSBzdHIgPT4gZGVmZXJZMThuTG9va3VwUHJlZml4ICsgc3RyO1xuICAgIHNlbGYuaGVscCA9IGZ1bmN0aW9uIGhlbHAoKSB7XG4gICAgICAgIGlmIChjYWNoZWRIZWxwTWVzc2FnZSlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRIZWxwTWVzc2FnZTtcbiAgICAgICAgbm9ybWFsaXplQWxpYXNlcygpO1xuICAgICAgICAvLyBoYW5kbGUgb2xkIGRlbWFuZGVkIEFQSVxuICAgICAgICBjb25zdCBiYXNlJDAgPSB5YXJncy5jdXN0b21TY3JpcHROYW1lID8geWFyZ3MuJDAgOiBwYXRoLmJhc2VuYW1lKHlhcmdzLiQwKTtcbiAgICAgICAgY29uc3QgZGVtYW5kZWRPcHRpb25zID0geWFyZ3MuZ2V0RGVtYW5kZWRPcHRpb25zKCk7XG4gICAgICAgIGNvbnN0IGRlbWFuZGVkQ29tbWFuZHMgPSB5YXJncy5nZXREZW1hbmRlZENvbW1hbmRzKCk7XG4gICAgICAgIGNvbnN0IGRlcHJlY2F0ZWRPcHRpb25zID0geWFyZ3MuZ2V0RGVwcmVjYXRlZE9wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgZ3JvdXBzID0geWFyZ3MuZ2V0R3JvdXBzKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB5YXJncy5nZXRPcHRpb25zKCk7XG4gICAgICAgIGxldCBrZXlzID0gW107XG4gICAgICAgIGtleXMgPSBrZXlzLmNvbmNhdChPYmplY3Qua2V5cyhkZXNjcmlwdGlvbnMpKTtcbiAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KE9iamVjdC5rZXlzKGRlbWFuZGVkT3B0aW9ucykpO1xuICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoT2JqZWN0LmtleXMoZGVtYW5kZWRDb21tYW5kcykpO1xuICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoT2JqZWN0LmtleXMob3B0aW9ucy5kZWZhdWx0KSk7XG4gICAgICAgIGtleXMgPSBrZXlzLmZpbHRlcihmaWx0ZXJIaWRkZW5PcHRpb25zKTtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGtleXMucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGtleSAhPT0gJ18nKVxuICAgICAgICAgICAgICAgIGFjY1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KSk7XG4gICAgICAgIGNvbnN0IHRoZVdyYXAgPSBnZXRXcmFwKCk7XG4gICAgICAgIGNvbnN0IHVpID0gcmVxdWlyZSgnY2xpdWknKSh7XG4gICAgICAgICAgICB3aWR0aDogdGhlV3JhcCxcbiAgICAgICAgICAgIHdyYXA6ICEhdGhlV3JhcFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gdGhlIHVzYWdlIHN0cmluZy5cbiAgICAgICAgaWYgKCF1c2FnZURpc2FibGVkKSB7XG4gICAgICAgICAgICBpZiAodXNhZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIHVzZXItZGVmaW5lZCB1c2FnZS5cbiAgICAgICAgICAgICAgICB1c2FnZXMuZm9yRWFjaCgodXNhZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdWkuZGl2KGAke3VzYWdlWzBdLnJlcGxhY2UoL1xcJDAvZywgYmFzZSQwKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzYWdlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aS5kaXYoeyB0ZXh0OiBgJHt1c2FnZVsxXX1gLCBwYWRkaW5nOiBbMSwgMCwgMCwgMF0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB1aS5kaXYoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1hbmRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCB1ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBkZW1vbnN0cmF0ZSBob3cgY29tbWFuZHMgYXJlIHVzZWQuXG4gICAgICAgICAgICAgICAgaWYgKGRlbWFuZGVkQ29tbWFuZHMuXykge1xuICAgICAgICAgICAgICAgICAgICB1ID0gYCR7YmFzZSQwfSA8JHtfXygnY29tbWFuZCcpfT5cXG5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdSA9IGAke2Jhc2UkMH0gWyR7X18oJ2NvbW1hbmQnKX1dXFxuYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdWkuZGl2KGAke3V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8geW91ciBhcHBsaWNhdGlvbidzIGNvbW1hbmRzLCBpLmUuLCBub24tb3B0aW9uXG4gICAgICAgIC8vIGFyZ3VtZW50cyBwb3B1bGF0ZWQgaW4gJ18nLlxuICAgICAgICBpZiAoY29tbWFuZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB1aS5kaXYoX18oJ0NvbW1hbmRzOicpKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB5YXJncy5nZXRDb250ZXh0KCk7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRDb21tYW5kcyA9IGNvbnRleHQuY29tbWFuZHMubGVuZ3RoID8gYCR7Y29udGV4dC5jb21tYW5kcy5qb2luKCcgJyl9IGAgOiAnJztcbiAgICAgICAgICAgIGlmICh5YXJncy5nZXRQYXJzZXJDb25maWd1cmF0aW9uKClbJ3NvcnQtY29tbWFuZHMnXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbW1hbmRzID0gY29tbWFuZHMuc29ydCgoYSwgYikgPT4gYVswXS5sb2NhbGVDb21wYXJlKGJbMF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbW1hbmRzLmZvckVhY2goKGNvbW1hbmQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tYW5kU3RyaW5nID0gYCR7YmFzZSQwfSAke3BhcmVudENvbW1hbmRzfSR7Y29tbWFuZFswXS5yZXBsYWNlKC9eXFwkMCA/LywgJycpfWA7IC8vIGRyb3AgJDAgZnJvbSBkZWZhdWx0IGNvbW1hbmRzLlxuICAgICAgICAgICAgICAgIHVpLnNwYW4oe1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjb21tYW5kU3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nOiBbMCwgMiwgMCwgMl0sXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBtYXhXaWR0aChjb21tYW5kcywgdGhlV3JhcCwgYCR7YmFzZSQwfSR7cGFyZW50Q29tbWFuZHN9YCkgKyA0XG4gICAgICAgICAgICAgICAgfSwgeyB0ZXh0OiBjb21tYW5kWzFdIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhpbnRzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1hbmRbMl0pXG4gICAgICAgICAgICAgICAgICAgIGhpbnRzLnB1c2goYFske19fKCdkZWZhdWx0Jyl9XWApO1xuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kWzNdICYmIGNvbW1hbmRbM10ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpbnRzLnB1c2goYFske19fKCdhbGlhc2VzOicpfSAke2NvbW1hbmRbM10uam9pbignLCAnKX1dYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kWzRdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29tbWFuZFs0XSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpbnRzLnB1c2goYFske19fKCdkZXByZWNhdGVkOiAlcycsIGNvbW1hbmRbNF0pfV1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpbnRzLnB1c2goYFske19fKCdkZXByZWNhdGVkJyl9XWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoaW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdWkuZGl2KHsgdGV4dDogaGludHMuam9pbignICcpLCBwYWRkaW5nOiBbMCwgMCwgMCwgMl0sIGFsaWduOiAncmlnaHQnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdWkuZGl2KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1aS5kaXYoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwZXJmb3JtIHNvbWUgY2xlYW51cCBvbiB0aGUga2V5cyBhcnJheSwgbWFraW5nIGl0XG4gICAgICAgIC8vIG9ubHkgaW5jbHVkZSB0b3AtbGV2ZWwga2V5cyBub3QgdGhlaXIgYWxpYXNlcy5cbiAgICAgICAgY29uc3QgYWxpYXNLZXlzID0gKE9iamVjdC5rZXlzKG9wdGlvbnMuYWxpYXMpIHx8IFtdKVxuICAgICAgICAgICAgLmNvbmNhdChPYmplY3Qua2V5cyh5YXJncy5wYXJzZWQubmV3QWxpYXNlcykgfHwgW10pO1xuICAgICAgICBrZXlzID0ga2V5cy5maWx0ZXIoa2V5ID0+ICF5YXJncy5wYXJzZWQubmV3QWxpYXNlc1trZXldICYmIGFsaWFzS2V5cy5ldmVyeShhbGlhcyA9PiAob3B0aW9ucy5hbGlhc1thbGlhc10gfHwgW10pLmluZGV4T2Yoa2V5KSA9PT0gLTEpKTtcbiAgICAgICAgLy8gcG9wdWxhdGUgJ09wdGlvbnM6JyBncm91cCB3aXRoIGFueSBrZXlzIHRoYXQgaGF2ZSBub3RcbiAgICAgICAgLy8gZXhwbGljaXRseSBoYWQgYSBncm91cCBzZXQuXG4gICAgICAgIGNvbnN0IGRlZmF1bHRHcm91cCA9IF9fKCdPcHRpb25zOicpO1xuICAgICAgICBpZiAoIWdyb3Vwc1tkZWZhdWx0R3JvdXBdKVxuICAgICAgICAgICAgZ3JvdXBzW2RlZmF1bHRHcm91cF0gPSBbXTtcbiAgICAgICAgYWRkVW5ncm91cGVkS2V5cyhrZXlzLCBvcHRpb25zLmFsaWFzLCBncm91cHMsIGRlZmF1bHRHcm91cCk7XG4gICAgICAgIC8vIGRpc3BsYXkgJ09wdGlvbnM6JyB0YWJsZSBhbG9uZyB3aXRoIGFueSBjdXN0b20gdGFibGVzOlxuICAgICAgICBPYmplY3Qua2V5cyhncm91cHMpLmZvckVhY2goKGdyb3VwTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFncm91cHNbZ3JvdXBOYW1lXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gaWYgd2UndmUgZ3JvdXBlZCB0aGUga2V5ICdmJywgYnV0ICdmJyBhbGlhc2VzICdmb29iYXInLFxuICAgICAgICAgICAgLy8gbm9ybWFsaXplZEtleXMgc2hvdWxkIGNvbnRhaW4gb25seSAnZm9vYmFyJy5cbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRLZXlzID0gZ3JvdXBzW2dyb3VwTmFtZV0uZmlsdGVyKGZpbHRlckhpZGRlbk9wdGlvbnMpLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKH5hbGlhc0tleXMuaW5kZXhPZihrZXkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBhbGlhc0tleTsgKGFsaWFzS2V5ID0gYWxpYXNLZXlzW2ldKSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKH4ob3B0aW9ucy5hbGlhc1thbGlhc0tleV0gfHwgW10pLmluZGV4T2Yoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhbGlhc0tleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRLZXlzLmxlbmd0aCA8IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdWkuZGl2KGdyb3VwTmFtZSk7XG4gICAgICAgICAgICAvLyBhY3R1YWxseSBnZW5lcmF0ZSB0aGUgc3dpdGNoZXMgc3RyaW5nIC0tZm9vLCAtZiwgLS1iYXIuXG4gICAgICAgICAgICBjb25zdCBzd2l0Y2hlcyA9IG5vcm1hbGl6ZWRLZXlzLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBhY2Nba2V5XSA9IFtrZXldLmNvbmNhdChvcHRpb25zLmFsaWFzW2tleV0gfHwgW10pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoc3cgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIHNwZWNpYWwgcG9zaXRpb25hbCBncm91cCBkb24ndFxuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgJy0tJyBvciAnLScgcHJlZml4LlxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JvdXBOYW1lID09PSBzZWxmLmdldFBvc2l0aW9uYWxHcm91cE5hbWUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdztcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hlcyB5YXJncy1wYXJzZXIgbG9naWMgaW4gd2hpY2ggc2luZ2xlLWRpZ2l0c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxpYXNlcyBkZWNsYXJlZCB3aXRoIGEgYm9vbGVhbiB0eXBlIGFyZSBub3cgdmFsaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIC9eWzAtOV0kLy50ZXN0KHN3KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gfm9wdGlvbnMuYm9vbGVhbi5pbmRleE9mKGtleSkgPyAnLScgOiAnLS0nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzdy5sZW5ndGggPiAxID8gJy0tJyA6ICctJykgKyBzdztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICBub3JtYWxpemVkS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrc3dpdGNoID0gc3dpdGNoZXNba2V5XTtcbiAgICAgICAgICAgICAgICBsZXQgZGVzYyA9IGRlc2NyaXB0aW9uc1trZXldIHx8ICcnO1xuICAgICAgICAgICAgICAgIGxldCB0eXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAofmRlc2MubGFzdEluZGV4T2YoZGVmZXJZMThuTG9va3VwUHJlZml4KSlcbiAgICAgICAgICAgICAgICAgICAgZGVzYyA9IF9fKGRlc2Muc3Vic3RyaW5nKGRlZmVyWTE4bkxvb2t1cFByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBpZiAofm9wdGlvbnMuYm9vbGVhbi5pbmRleE9mKGtleSkpXG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBgWyR7X18oJ2Jvb2xlYW4nKX1dYDtcbiAgICAgICAgICAgICAgICBpZiAofm9wdGlvbnMuY291bnQuaW5kZXhPZihrZXkpKVxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gYFske19fKCdjb3VudCcpfV1gO1xuICAgICAgICAgICAgICAgIGlmICh+b3B0aW9ucy5zdHJpbmcuaW5kZXhPZihrZXkpKVxuICAgICAgICAgICAgICAgICAgICB0eXBlID0gYFske19fKCdzdHJpbmcnKX1dYDtcbiAgICAgICAgICAgICAgICBpZiAofm9wdGlvbnMubm9ybWFsaXplLmluZGV4T2Yoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGBbJHtfXygnc3RyaW5nJyl9XWA7XG4gICAgICAgICAgICAgICAgaWYgKH5vcHRpb25zLmFycmF5LmluZGV4T2Yoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGBbJHtfXygnYXJyYXknKX1dYDtcbiAgICAgICAgICAgICAgICBpZiAofm9wdGlvbnMubnVtYmVyLmluZGV4T2Yoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9IGBbJHtfXygnbnVtYmVyJyl9XWA7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVwcmVjYXRlZEV4dHJhID0gKGRlcHJlY2F0ZWQpID0+IHR5cGVvZiBkZXByZWNhdGVkID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IGBbJHtfXygnZGVwcmVjYXRlZDogJXMnLCBkZXByZWNhdGVkKX1dYFxuICAgICAgICAgICAgICAgICAgICA6IGBbJHtfXygnZGVwcmVjYXRlZCcpfV1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dHJhID0gW1xuICAgICAgICAgICAgICAgICAgICAoa2V5IGluIGRlcHJlY2F0ZWRPcHRpb25zKSA/IGRlcHJlY2F0ZWRFeHRyYShkZXByZWNhdGVkT3B0aW9uc1trZXldKSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgIChrZXkgaW4gZGVtYW5kZWRPcHRpb25zKSA/IGBbJHtfXygncmVxdWlyZWQnKX1dYCA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuY2hvaWNlcyAmJiBvcHRpb25zLmNob2ljZXNba2V5XSA/IGBbJHtfXygnY2hvaWNlczonKX0gJHtzZWxmLnN0cmluZ2lmaWVkVmFsdWVzKG9wdGlvbnMuY2hvaWNlc1trZXldKX1dYCA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRTdHJpbmcob3B0aW9ucy5kZWZhdWx0W2tleV0sIG9wdGlvbnMuZGVmYXVsdERlc2NyaXB0aW9uW2tleV0pXG4gICAgICAgICAgICAgICAgXS5maWx0ZXIoQm9vbGVhbikuam9pbignICcpO1xuICAgICAgICAgICAgICAgIHVpLnNwYW4oeyB0ZXh0OiBrc3dpdGNoLCBwYWRkaW5nOiBbMCwgMiwgMCwgMl0sIHdpZHRoOiBtYXhXaWR0aChzd2l0Y2hlcywgdGhlV3JhcCkgKyA0IH0sIGRlc2MpO1xuICAgICAgICAgICAgICAgIGlmIChleHRyYSlcbiAgICAgICAgICAgICAgICAgICAgdWkuZGl2KHsgdGV4dDogZXh0cmEsIHBhZGRpbmc6IFswLCAwLCAwLCAyXSwgYWxpZ246ICdyaWdodCcgfSk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB1aS5kaXYoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdWkuZGl2KCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBkZXNjcmliZSBzb21lIGNvbW1vbiB1c2UtY2FzZXMgZm9yIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICAgIGlmIChleGFtcGxlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHVpLmRpdihfXygnRXhhbXBsZXM6JykpO1xuICAgICAgICAgICAgZXhhbXBsZXMuZm9yRWFjaCgoZXhhbXBsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGV4YW1wbGVbMF0gPSBleGFtcGxlWzBdLnJlcGxhY2UoL1xcJDAvZywgYmFzZSQwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXhhbXBsZXMuZm9yRWFjaCgoZXhhbXBsZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChleGFtcGxlWzFdID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICB1aS5kaXYoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZXhhbXBsZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZGRpbmc6IFswLCAyLCAwLCAyXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVpLmRpdih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBleGFtcGxlWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZzogWzAsIDIsIDAsIDJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG1heFdpZHRoKGV4YW1wbGVzLCB0aGVXcmFwKSArIDRcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZXhhbXBsZVsxXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHVpLmRpdigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSB1c2FnZSBzdHJpbmcuXG4gICAgICAgIGlmIChlcGlsb2dzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlcGlsb2dzLm1hcChlcGlsb2cgPT4gZXBpbG9nLnJlcGxhY2UoL1xcJDAvZywgYmFzZSQwKSkuam9pbignXFxuJyk7XG4gICAgICAgICAgICB1aS5kaXYoYCR7ZX1cXG5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGhlIHRyYWlsaW5nIHdoaXRlIHNwYWNlc1xuICAgICAgICByZXR1cm4gdWkudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbiAgICB9O1xuICAgIC8vIHJldHVybiB0aGUgbWF4aW11bSB3aWR0aCBvZiBhIHN0cmluZ1xuICAgIC8vIGluIHRoZSBsZWZ0LWhhbmQgY29sdW1uIG9mIGEgdGFibGUuXG4gICAgZnVuY3Rpb24gbWF4V2lkdGgodGFibGUsIHRoZVdyYXAsIG1vZGlmaWVyKSB7XG4gICAgICAgIGxldCB3aWR0aCA9IDA7XG4gICAgICAgIC8vIHRhYmxlIG1pZ2h0IGJlIG9mIHRoZSBmb3JtIFtsZWZ0Q29sdW1uXSxcbiAgICAgICAgLy8gb3Ige2tleTogbGVmdENvbHVtbn1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhYmxlKSkge1xuICAgICAgICAgICAgdGFibGUgPSBPYmplY3QudmFsdWVzKHRhYmxlKS5tYXAodiA9PiBbdl0pO1xuICAgICAgICB9XG4gICAgICAgIHRhYmxlLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5tYXgoc3RyaW5nV2lkdGgobW9kaWZpZXIgPyBgJHttb2RpZmllcn0gJHt2WzBdfWAgOiB2WzBdKSwgd2lkdGgpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gaWYgd2UndmUgZW5hYmxlZCAnd3JhcCcgd2Ugc2hvdWxkIGxpbWl0XG4gICAgICAgIC8vIHRoZSBtYXgtd2lkdGggb2YgdGhlIGxlZnQtY29sdW1uLlxuICAgICAgICBpZiAodGhlV3JhcClcbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5taW4od2lkdGgsIHBhcnNlSW50KCh0aGVXcmFwICogMC41KS50b1N0cmluZygpLCAxMCkpO1xuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSBhbnkgb3B0aW9ucyBzZXQgZm9yIGFsaWFzZXMsXG4gICAgLy8gYXJlIGNvcGllZCB0byB0aGUga2V5cyBiZWluZyBhbGlhc2VkLlxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUFsaWFzZXMoKSB7XG4gICAgICAgIC8vIGhhbmRsZSBvbGQgZGVtYW5kZWQgQVBJXG4gICAgICAgIGNvbnN0IGRlbWFuZGVkT3B0aW9ucyA9IHlhcmdzLmdldERlbWFuZGVkT3B0aW9ucygpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0geWFyZ3MuZ2V0T3B0aW9ucygpO1xuICAgICAgICAoT2JqZWN0LmtleXMob3B0aW9ucy5hbGlhcykgfHwgW10pLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgb3B0aW9ucy5hbGlhc1trZXldLmZvckVhY2goKGFsaWFzKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gY29weSBkZXNjcmlwdGlvbnMuXG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uc1thbGlhc10pXG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZGVzY3JpYmUoa2V5LCBkZXNjcmlwdGlvbnNbYWxpYXNdKTtcbiAgICAgICAgICAgICAgICAvLyBjb3B5IGRlbWFuZGVkLlxuICAgICAgICAgICAgICAgIGlmIChhbGlhcyBpbiBkZW1hbmRlZE9wdGlvbnMpXG4gICAgICAgICAgICAgICAgICAgIHlhcmdzLmRlbWFuZE9wdGlvbihrZXksIGRlbWFuZGVkT3B0aW9uc1thbGlhc10pO1xuICAgICAgICAgICAgICAgIC8vIHR5cGUgbWVzc2FnZXMuXG4gICAgICAgICAgICAgICAgaWYgKH5vcHRpb25zLmJvb2xlYW4uaW5kZXhPZihhbGlhcykpXG4gICAgICAgICAgICAgICAgICAgIHlhcmdzLmJvb2xlYW4oa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAofm9wdGlvbnMuY291bnQuaW5kZXhPZihhbGlhcykpXG4gICAgICAgICAgICAgICAgICAgIHlhcmdzLmNvdW50KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKH5vcHRpb25zLnN0cmluZy5pbmRleE9mKGFsaWFzKSlcbiAgICAgICAgICAgICAgICAgICAgeWFyZ3Muc3RyaW5nKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKH5vcHRpb25zLm5vcm1hbGl6ZS5pbmRleE9mKGFsaWFzKSlcbiAgICAgICAgICAgICAgICAgICAgeWFyZ3Mubm9ybWFsaXplKGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKH5vcHRpb25zLmFycmF5LmluZGV4T2YoYWxpYXMpKVxuICAgICAgICAgICAgICAgICAgICB5YXJncy5hcnJheShrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh+b3B0aW9ucy5udW1iZXIuaW5kZXhPZihhbGlhcykpXG4gICAgICAgICAgICAgICAgICAgIHlhcmdzLm51bWJlcihrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBpZiB5YXJncyBpcyBleGVjdXRpbmcgYW4gYXN5bmMgaGFuZGxlciwgd2UgdGFrZSBhIHNuYXBzaG90IG9mIHRoZVxuICAgIC8vIGhlbHAgbWVzc2FnZSB0byBkaXNwbGF5IG9uIGZhaWx1cmU6XG4gICAgbGV0IGNhY2hlZEhlbHBNZXNzYWdlO1xuICAgIHNlbGYuY2FjaGVIZWxwTWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FjaGVkSGVscE1lc3NhZ2UgPSB0aGlzLmhlbHAoKTtcbiAgICB9O1xuICAgIC8vIGhvd2V2ZXIgdGhpcyBzbmFwc2hvdCBtdXN0IGJlIGNsZWFyZWQgYWZ0ZXJ3YXJkc1xuICAgIC8vIG5vdCB0byBiZSBiZSB1c2VkIGJ5IG5leHQgY2FsbHMgdG8gcGFyc2VcbiAgICBzZWxmLmNsZWFyQ2FjaGVkSGVscE1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhY2hlZEhlbHBNZXNzYWdlID0gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgLy8gZ2l2ZW4gYSBzZXQgb2Yga2V5cywgcGxhY2UgYW55IGtleXMgdGhhdCBhcmVcbiAgICAvLyB1bmdyb3VwZWQgdW5kZXIgdGhlICdPcHRpb25zOicgZ3JvdXBpbmcuXG4gICAgZnVuY3Rpb24gYWRkVW5ncm91cGVkS2V5cyhrZXlzLCBhbGlhc2VzLCBncm91cHMsIGRlZmF1bHRHcm91cCkge1xuICAgICAgICBsZXQgZ3JvdXBlZEtleXMgPSBbXTtcbiAgICAgICAgbGV0IHRvQ2hlY2sgPSBudWxsO1xuICAgICAgICBPYmplY3Qua2V5cyhncm91cHMpLmZvckVhY2goKGdyb3VwKSA9PiB7XG4gICAgICAgICAgICBncm91cGVkS2V5cyA9IGdyb3VwZWRLZXlzLmNvbmNhdChncm91cHNbZ3JvdXBdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICB0b0NoZWNrID0gW2tleV0uY29uY2F0KGFsaWFzZXNba2V5XSk7XG4gICAgICAgICAgICBpZiAoIXRvQ2hlY2suc29tZShrID0+IGdyb3VwZWRLZXlzLmluZGV4T2YoaykgIT09IC0xKSkge1xuICAgICAgICAgICAgICAgIGdyb3Vwc1tkZWZhdWx0R3JvdXBdLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBncm91cGVkS2V5cztcbiAgICB9XG4gICAgZnVuY3Rpb24gZmlsdGVySGlkZGVuT3B0aW9ucyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIHlhcmdzLmdldE9wdGlvbnMoKS5oaWRkZW5PcHRpb25zLmluZGV4T2Yoa2V5KSA8IDAgfHwgeWFyZ3MucGFyc2VkLmFyZ3ZbeWFyZ3MuZ2V0T3B0aW9ucygpLnNob3dIaWRkZW5PcHRdO1xuICAgIH1cbiAgICBzZWxmLnNob3dIZWxwID0gKGxldmVsKSA9PiB7XG4gICAgICAgIGNvbnN0IGxvZ2dlciA9IHlhcmdzLl9nZXRMb2dnZXJJbnN0YW5jZSgpO1xuICAgICAgICBpZiAoIWxldmVsKVxuICAgICAgICAgICAgbGV2ZWwgPSAnZXJyb3InO1xuICAgICAgICBjb25zdCBlbWl0ID0gdHlwZW9mIGxldmVsID09PSAnZnVuY3Rpb24nID8gbGV2ZWwgOiBsb2dnZXJbbGV2ZWxdO1xuICAgICAgICBlbWl0KHNlbGYuaGVscCgpKTtcbiAgICB9O1xuICAgIHNlbGYuZnVuY3Rpb25EZXNjcmlwdGlvbiA9IChmbikgPT4ge1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGZuLm5hbWUgPyBkZWNhbWVsaXplKGZuLm5hbWUsICctJykgOiBfXygnZ2VuZXJhdGVkLXZhbHVlJyk7XG4gICAgICAgIHJldHVybiBbJygnLCBkZXNjcmlwdGlvbiwgJyknXS5qb2luKCcnKTtcbiAgICB9O1xuICAgIHNlbGYuc3RyaW5naWZpZWRWYWx1ZXMgPSBmdW5jdGlvbiBzdHJpbmdpZmllZFZhbHVlcyh2YWx1ZXMsIHNlcGFyYXRvcikge1xuICAgICAgICBsZXQgc3RyaW5nID0gJyc7XG4gICAgICAgIGNvbnN0IHNlcCA9IHNlcGFyYXRvciB8fCAnLCAnO1xuICAgICAgICBjb25zdCBhcnJheSA9IFtdLmNvbmNhdCh2YWx1ZXMpO1xuICAgICAgICBpZiAoIXZhbHVlcyB8fCAhYXJyYXkubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgYXJyYXkuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmIChzdHJpbmcubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHN0cmluZyArPSBzZXA7XG4gICAgICAgICAgICBzdHJpbmcgKz0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9O1xuICAgIC8vIGZvcm1hdCB0aGUgZGVmYXVsdC12YWx1ZS1zdHJpbmcgZGlzcGxheWVkIGluXG4gICAgLy8gdGhlIHJpZ2h0LWhhbmQgY29sdW1uLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRTdHJpbmcodmFsdWUsIGRlZmF1bHREZXNjcmlwdGlvbikge1xuICAgICAgICBsZXQgc3RyaW5nID0gYFske19fKCdkZWZhdWx0OicpfSBgO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhZGVmYXVsdERlc2NyaXB0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmIChkZWZhdWx0RGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBkZWZhdWx0RGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBgXCIke3ZhbHVlfVwiYDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHtzdHJpbmd9XWA7XG4gICAgfVxuICAgIC8vIGd1ZXNzIHRoZSB3aWR0aCBvZiB0aGUgY29uc29sZSB3aW5kb3csIG1heC13aWR0aCA4MC5cbiAgICBmdW5jdGlvbiB3aW5kb3dXaWR0aCgpIHtcbiAgICAgICAgY29uc3QgbWF4V2lkdGggPSA4MDtcbiAgICAgICAgLy8gQ0kgaXMgbm90IGEgVFRZXG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLnN0ZG91dCAmJiBwcm9jZXNzLnN0ZG91dC5jb2x1bW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4obWF4V2lkdGgsIHByb2Nlc3Muc3Rkb3V0LmNvbHVtbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1heFdpZHRoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGxvZ2ljIGZvciBkaXNwbGF5aW5nIGFwcGxpY2F0aW9uIHZlcnNpb24uXG4gICAgbGV0IHZlcnNpb24gPSBudWxsO1xuICAgIHNlbGYudmVyc2lvbiA9ICh2ZXIpID0+IHtcbiAgICAgICAgdmVyc2lvbiA9IHZlcjtcbiAgICB9O1xuICAgIHNlbGYuc2hvd1ZlcnNpb24gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxvZ2dlciA9IHlhcmdzLl9nZXRMb2dnZXJJbnN0YW5jZSgpO1xuICAgICAgICBsb2dnZXIubG9nKHZlcnNpb24pO1xuICAgIH07XG4gICAgc2VsZi5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KGxvY2FsTG9va3VwKSB7XG4gICAgICAgIC8vIGRvIG5vdCByZXNldCB3cmFwIGhlcmVcbiAgICAgICAgLy8gZG8gbm90IHJlc2V0IGZhaWxzIGhlcmVcbiAgICAgICAgZmFpbE1lc3NhZ2UgPSBudWxsO1xuICAgICAgICBmYWlsdXJlT3V0cHV0ID0gZmFsc2U7XG4gICAgICAgIHVzYWdlcyA9IFtdO1xuICAgICAgICB1c2FnZURpc2FibGVkID0gZmFsc2U7XG4gICAgICAgIGVwaWxvZ3MgPSBbXTtcbiAgICAgICAgZXhhbXBsZXMgPSBbXTtcbiAgICAgICAgY29tbWFuZHMgPSBbXTtcbiAgICAgICAgZGVzY3JpcHRpb25zID0gb2JqX2ZpbHRlcl8xLm9iakZpbHRlcihkZXNjcmlwdGlvbnMsIGsgPT4gIWxvY2FsTG9va3VwW2tdKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBjb25zdCBmcm96ZW5zID0gW107XG4gICAgc2VsZi5mcmVlemUgPSBmdW5jdGlvbiBmcmVlemUoKSB7XG4gICAgICAgIGZyb3plbnMucHVzaCh7XG4gICAgICAgICAgICBmYWlsTWVzc2FnZSxcbiAgICAgICAgICAgIGZhaWx1cmVPdXRwdXQsXG4gICAgICAgICAgICB1c2FnZXMsXG4gICAgICAgICAgICB1c2FnZURpc2FibGVkLFxuICAgICAgICAgICAgZXBpbG9ncyxcbiAgICAgICAgICAgIGV4YW1wbGVzLFxuICAgICAgICAgICAgY29tbWFuZHMsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbnNcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBzZWxmLnVuZnJlZXplID0gZnVuY3Rpb24gdW5mcmVlemUoKSB7XG4gICAgICAgIGNvbnN0IGZyb3plbiA9IGZyb3plbnMucG9wKCk7XG4gICAgICAgIGNvbW1vbl90eXBlc18xLmFzc2VydE5vdFN0cmljdEVxdWFsKGZyb3plbiwgdW5kZWZpbmVkKTtcbiAgICAgICAgKHtcbiAgICAgICAgICAgIGZhaWxNZXNzYWdlLFxuICAgICAgICAgICAgZmFpbHVyZU91dHB1dCxcbiAgICAgICAgICAgIHVzYWdlcyxcbiAgICAgICAgICAgIHVzYWdlRGlzYWJsZWQsXG4gICAgICAgICAgICBlcGlsb2dzLFxuICAgICAgICAgICAgZXhhbXBsZXMsXG4gICAgICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uc1xuICAgICAgICB9ID0gZnJvemVuKTtcbiAgICB9O1xuICAgIHJldHVybiBzZWxmO1xufVxuZXhwb3J0cy51c2FnZSA9IHVzYWdlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///56\n")},function(module,exports,__webpack_require__){"use strict";eval("/* eslint-disable yoda */\n\n\nconst isFullwidthCodePoint = codePoint => {\n\tif (Number.isNaN(codePoint)) {\n\t\treturn false;\n\t}\n\n\t// Code points are derived from:\n\t// http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt\n\tif (\n\t\tcodePoint >= 0x1100 && (\n\t\t\tcodePoint <= 0x115F || // Hangul Jamo\n\t\t\tcodePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n\t\t\tcodePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET\n\t\t\t// CJK Radicals Supplement .. Enclosed CJK Letters and Months\n\t\t\t(0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F) ||\n\t\t\t// Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n\t\t\t(0x3250 <= codePoint && codePoint <= 0x4DBF) ||\n\t\t\t// CJK Unified Ideographs .. Yi Radicals\n\t\t\t(0x4E00 <= codePoint && codePoint <= 0xA4C6) ||\n\t\t\t// Hangul Jamo Extended-A\n\t\t\t(0xA960 <= codePoint && codePoint <= 0xA97C) ||\n\t\t\t// Hangul Syllables\n\t\t\t(0xAC00 <= codePoint && codePoint <= 0xD7A3) ||\n\t\t\t// CJK Compatibility Ideographs\n\t\t\t(0xF900 <= codePoint && codePoint <= 0xFAFF) ||\n\t\t\t// Vertical Forms\n\t\t\t(0xFE10 <= codePoint && codePoint <= 0xFE19) ||\n\t\t\t// CJK Compatibility Forms .. Small Form Variants\n\t\t\t(0xFE30 <= codePoint && codePoint <= 0xFE6B) ||\n\t\t\t// Halfwidth and Fullwidth Forms\n\t\t\t(0xFF01 <= codePoint && codePoint <= 0xFF60) ||\n\t\t\t(0xFFE0 <= codePoint && codePoint <= 0xFFE6) ||\n\t\t\t// Kana Supplement\n\t\t\t(0x1B000 <= codePoint && codePoint <= 0x1B001) ||\n\t\t\t// Enclosed Ideographic Supplement\n\t\t\t(0x1F200 <= codePoint && codePoint <= 0x1F251) ||\n\t\t\t// CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n\t\t\t(0x20000 <= codePoint && codePoint <= 0x3FFFD)\n\t\t)\n\t) {\n\t\treturn true;\n\t}\n\n\treturn false;\n};\n\nmodule.exports = isFullwidthCodePoint;\nmodule.exports.default = isFullwidthCodePoint;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXMtZnVsbHdpZHRoLWNvZGUtcG9pbnQvaW5kZXguanM/NDY5OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNhOztBQUViO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSB5b2RhICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGlzRnVsbHdpZHRoQ29kZVBvaW50ID0gY29kZVBvaW50ID0+IHtcblx0aWYgKE51bWJlci5pc05hTihjb2RlUG9pbnQpKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gQ29kZSBwb2ludHMgYXJlIGRlcml2ZWQgZnJvbTpcblx0Ly8gaHR0cDovL3d3dy51bml4Lm9yZy9QdWJsaWMvVU5JREFUQS9FYXN0QXNpYW5XaWR0aC50eHRcblx0aWYgKFxuXHRcdGNvZGVQb2ludCA+PSAweDExMDAgJiYgKFxuXHRcdFx0Y29kZVBvaW50IDw9IDB4MTE1RiB8fCAvLyBIYW5ndWwgSmFtb1xuXHRcdFx0Y29kZVBvaW50ID09PSAweDIzMjkgfHwgLy8gTEVGVC1QT0lOVElORyBBTkdMRSBCUkFDS0VUXG5cdFx0XHRjb2RlUG9pbnQgPT09IDB4MjMyQSB8fCAvLyBSSUdIVC1QT0lOVElORyBBTkdMRSBCUkFDS0VUXG5cdFx0XHQvLyBDSksgUmFkaWNhbHMgU3VwcGxlbWVudCAuLiBFbmNsb3NlZCBDSksgTGV0dGVycyBhbmQgTW9udGhzXG5cdFx0XHQoMHgyRTgwIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHgzMjQ3ICYmIGNvZGVQb2ludCAhPT0gMHgzMDNGKSB8fFxuXHRcdFx0Ly8gRW5jbG9zZWQgQ0pLIExldHRlcnMgYW5kIE1vbnRocyAuLiBDSksgVW5pZmllZCBJZGVvZ3JhcGhzIEV4dGVuc2lvbiBBXG5cdFx0XHQoMHgzMjUwIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHg0REJGKSB8fFxuXHRcdFx0Ly8gQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyAuLiBZaSBSYWRpY2Fsc1xuXHRcdFx0KDB4NEUwMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4QTRDNikgfHxcblx0XHRcdC8vIEhhbmd1bCBKYW1vIEV4dGVuZGVkLUFcblx0XHRcdCgweEE5NjAgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweEE5N0MpIHx8XG5cdFx0XHQvLyBIYW5ndWwgU3lsbGFibGVzXG5cdFx0XHQoMHhBQzAwIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHhEN0EzKSB8fFxuXHRcdFx0Ly8gQ0pLIENvbXBhdGliaWxpdHkgSWRlb2dyYXBoc1xuXHRcdFx0KDB4RjkwMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4RkFGRikgfHxcblx0XHRcdC8vIFZlcnRpY2FsIEZvcm1zXG5cdFx0XHQoMHhGRTEwIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHhGRTE5KSB8fFxuXHRcdFx0Ly8gQ0pLIENvbXBhdGliaWxpdHkgRm9ybXMgLi4gU21hbGwgRm9ybSBWYXJpYW50c1xuXHRcdFx0KDB4RkUzMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4RkU2QikgfHxcblx0XHRcdC8vIEhhbGZ3aWR0aCBhbmQgRnVsbHdpZHRoIEZvcm1zXG5cdFx0XHQoMHhGRjAxIDw9IGNvZGVQb2ludCAmJiBjb2RlUG9pbnQgPD0gMHhGRjYwKSB8fFxuXHRcdFx0KDB4RkZFMCA8PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50IDw9IDB4RkZFNikgfHxcblx0XHRcdC8vIEthbmEgU3VwcGxlbWVudFxuXHRcdFx0KDB4MUIwMDAgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweDFCMDAxKSB8fFxuXHRcdFx0Ly8gRW5jbG9zZWQgSWRlb2dyYXBoaWMgU3VwcGxlbWVudFxuXHRcdFx0KDB4MUYyMDAgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweDFGMjUxKSB8fFxuXHRcdFx0Ly8gQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyBFeHRlbnNpb24gQiAuLiBUZXJ0aWFyeSBJZGVvZ3JhcGhpYyBQbGFuZVxuXHRcdFx0KDB4MjAwMDAgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweDNGRkZEKVxuXHRcdClcblx0KSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRnVsbHdpZHRoQ29kZVBvaW50O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGlzRnVsbHdpZHRoQ29kZVBvaW50O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///57\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nmodule.exports = function () {\n  // https://mths.be/emoji\n  return /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73)\\uDB40\\uDC7F|\\uD83D\\uDC68(?:\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68\\uD83C\\uDFFB|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83D[\\uDC66\\uDC67]|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C[\\uDFFB-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)\\uD83C\\uDFFB|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB\\uDFFC])|\\uD83D\\uDC69(?:\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D\\uD83D\\uDC69)(?:\\uD83C[\\uDFFB-\\uDFFD])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|(?:(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)\\uFE0F|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\u200D[\\u2640\\u2642])|\\uD83C\\uDFF4\\u200D\\u2620)\\uFE0F|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83C\\uDDF6\\uD83C\\uDDE6|[#\\*0-9]\\uFE0F\\u20E3|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83D\\uDC69(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC70\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDCAA\\uDD74\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD36\\uDDB5\\uDDB6\\uDDBB\\uDDD2-\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5\\uDEEB\\uDEEC\\uDEF4-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFA\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDDFF\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZW1vamktcmVnZXgvaW5kZXguanM/Yjg1NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI1OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gaHR0cHM6Ly9tdGhzLmJlL2Vtb2ppXG4gIHJldHVybiAvXFx1RDgzQ1xcdURGRjRcXHVEQjQwXFx1REM2N1xcdURCNDBcXHVEQzYyKD86XFx1REI0MFxcdURDNjVcXHVEQjQwXFx1REM2RVxcdURCNDBcXHVEQzY3fFxcdURCNDBcXHVEQzczXFx1REI0MFxcdURDNjNcXHVEQjQwXFx1REM3NHxcXHVEQjQwXFx1REM3N1xcdURCNDBcXHVEQzZDXFx1REI0MFxcdURDNzMpXFx1REI0MFxcdURDN0Z8XFx1RDgzRFxcdURDNjgoPzpcXHVEODNDXFx1REZGQ1xcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OFxcdUQ4M0NcXHVERkZCfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRlxcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZFXSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZFXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkRdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkRcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkJcXHVERkZDXSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdTIwMEQoPzpcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY4fCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdTIwMEQoPzpcXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSkpfFxcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXwoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdXFx1RkUwRnxcXHVEODNEW1xcdURDNjZcXHVEQzY3XXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8KD86XFx1RDgzQ1xcdURGRkJcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkZcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkVcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkRcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkNcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF0pXFx1RkUwRnxcXHVEODNDXFx1REZGQlxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXwoPzpcXHVEODNFXFx1REREMVxcdUQ4M0NcXHVERkZCXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxfFxcdUQ4M0RcXHVEQzY5XFx1RDgzQ1xcdURGRkNcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjkpXFx1RDgzQ1xcdURGRkJ8XFx1RDgzRVxcdURERDEoPzpcXHVEODNDXFx1REZGRlxcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8XFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxKXwoPzpcXHVEODNFXFx1REREMVxcdUQ4M0NcXHVERkZFXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxfFxcdUQ4M0RcXHVEQzY5XFx1RDgzQ1xcdURGRkZcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZFXSl8KD86XFx1RDgzRVxcdURERDFcXHVEODNDXFx1REZGQ1xcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMXxcXHVEODNEXFx1REM2OVxcdUQ4M0NcXHVERkZEXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY5KSg/OlxcdUQ4M0NbXFx1REZGQlxcdURGRkNdKXxcXHVEODNEXFx1REM2OSg/OlxcdUQ4M0NcXHVERkZFXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkRcXHVERkZGXSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZDXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCXFx1REZGRC1cXHVERkZGXSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZCXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZDLVxcdURGRkZdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkRcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkJcXHVERkZDXFx1REZGRVxcdURGRkZdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1MjAwRCg/OlxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKXxcXHVEODNEW1xcdURDNjhcXHVEQzY5XSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZGXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKSl8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjlcXHUyMDBEKD86XFx1RDgzRFxcdURDNjZcXHUyMDBEXFx1RDgzRFxcdURDNjZ8XFx1RDgzRFxcdURDNjdcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pKXwoPzpcXHVEODNFXFx1REREMVxcdUQ4M0NcXHVERkZEXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0VcXHVEREQxfFxcdUQ4M0RcXHVEQzY5XFx1RDgzQ1xcdURGRkVcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjkpKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkRdKXxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2OVxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8KD86XFx1RDgzRFxcdURDNDFcXHVGRTBGXFx1MjAwRFxcdUQ4M0RcXHVEREU4fFxcdUQ4M0RcXHVEQzY5KD86XFx1RDgzQ1xcdURGRkZcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkVcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkNcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkJcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkRcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdKXwoPzooPzpcXHUyNkY5fFxcdUQ4M0NbXFx1REZDQlxcdURGQ0NdfFxcdUQ4M0RcXHVERDc1KVxcdUZFMEZ8XFx1RDgzRFxcdURDNkZ8XFx1RDgzRVtcXHVERDNDXFx1RERERVxcdUREREZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdfCg/OlxcdTI2Rjl8XFx1RDgzQ1tcXHVERkNCXFx1REZDQ118XFx1RDgzRFxcdURENzUpKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdfCg/OlxcdUQ4M0NbXFx1REZDM1xcdURGQzRcXHVERkNBXXxcXHVEODNEW1xcdURDNkVcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl18XFx1RDgzRVtcXHVERDI2XFx1REQzNy1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREI4XFx1RERCOVxcdUREQ0QtXFx1RERDRlxcdURERDYtXFx1RERERF0pKD86KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdfFxcdTIwMERbXFx1MjY0MFxcdTI2NDJdKXxcXHVEODNDXFx1REZGNFxcdTIwMERcXHUyNjIwKVxcdUZFMEZ8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjdcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfFxcdUQ4M0NcXHVERkYzXFx1RkUwRlxcdTIwMERcXHVEODNDXFx1REYwOHxcXHVEODNEXFx1REMxNVxcdTIwMERcXHVEODNFXFx1RERCQXxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2N3xcXHVEODNDXFx1RERGRFxcdUQ4M0NcXHVEREYwfFxcdUQ4M0NcXHVEREY0XFx1RDgzQ1xcdURERjJ8XFx1RDgzQ1xcdURERjZcXHVEODNDXFx1RERFNnxbI1xcKjAtOV1cXHVGRTBGXFx1MjBFM3xcXHVEODNDXFx1RERFNyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERTdcXHVEREU5LVxcdURERUZcXHVEREYxLVxcdURERjRcXHVEREY2LVxcdURERjlcXHVEREZCXFx1RERGQ1xcdURERkVcXHVEREZGXSl8XFx1RDgzQ1xcdURERjkoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFOVxcdURERUItXFx1RERFRFxcdURERUYtXFx1RERGNFxcdURERjdcXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZGXSl8XFx1RDgzQ1xcdURERUEoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQVxcdURERUNcXHVEREVEXFx1RERGNy1cXHVEREZBXSl8XFx1RDgzRVxcdURERDEoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdUQ4M0NcXHVEREY3KD86XFx1RDgzQ1tcXHVEREVBXFx1RERGNFxcdURERjhcXHVEREZBXFx1RERGQ10pfFxcdUQ4M0RcXHVEQzY5KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXxcXHVEODNDXFx1RERGMig/OlxcdUQ4M0NbXFx1RERFNlxcdURERTgtXFx1RERFRFxcdURERjAtXFx1RERGRl0pfFxcdUQ4M0NcXHVEREU2KD86XFx1RDgzQ1tcXHVEREU4LVxcdURERUNcXHVEREVFXFx1RERGMVxcdURERjJcXHVEREY0XFx1RERGNi1cXHVEREZBXFx1RERGQ1xcdURERkRcXHVEREZGXSl8XFx1RDgzQ1xcdURERjAoPzpcXHVEODNDW1xcdURERUFcXHVEREVDLVxcdURERUVcXHVEREYyXFx1RERGM1xcdURERjVcXHVEREY3XFx1RERGQ1xcdURERkVcXHVEREZGXSl8XFx1RDgzQ1xcdURERUQoPzpcXHVEODNDW1xcdURERjBcXHVEREYyXFx1RERGM1xcdURERjdcXHVEREY5XFx1RERGQV0pfFxcdUQ4M0NcXHVEREU5KD86XFx1RDgzQ1tcXHVEREVBXFx1RERFQ1xcdURERUZcXHVEREYwXFx1RERGMlxcdURERjRcXHVEREZGXSl8XFx1RDgzQ1xcdURERkUoPzpcXHVEODNDW1xcdURERUFcXHVEREY5XSl8XFx1RDgzQ1xcdURERUMoPzpcXHVEODNDW1xcdURERTZcXHVEREU3XFx1RERFOS1cXHVEREVFXFx1RERGMS1cXHVEREYzXFx1RERGNS1cXHVEREZBXFx1RERGQ1xcdURERkVdKXxcXHVEODNDXFx1RERGOCg/OlxcdUQ4M0NbXFx1RERFNi1cXHVEREVBXFx1RERFQy1cXHVEREY0XFx1RERGNy1cXHVEREY5XFx1RERGQlxcdURERkQtXFx1RERGRl0pfFxcdUQ4M0NcXHVEREVCKD86XFx1RDgzQ1tcXHVEREVFLVxcdURERjBcXHVEREYyXFx1RERGNFxcdURERjddKXxcXHVEODNDXFx1RERGNSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERUEtXFx1RERFRFxcdURERjAtXFx1RERGM1xcdURERjctXFx1RERGOVxcdURERkNcXHVEREZFXSl8XFx1RDgzQ1xcdURERkIoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQVxcdURERUNcXHVEREVFXFx1RERGM1xcdURERkFdKXxcXHVEODNDXFx1RERGMyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBLVxcdURERUNcXHVEREVFXFx1RERGMVxcdURERjRcXHVEREY1XFx1RERGN1xcdURERkFcXHVEREZGXSl8XFx1RDgzQ1xcdURERTgoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFOVxcdURERUItXFx1RERFRVxcdURERjAtXFx1RERGNVxcdURERjdcXHVEREZBLVxcdURERkZdKXxcXHVEODNDXFx1RERGMSg/OlxcdUQ4M0NbXFx1RERFNi1cXHVEREU4XFx1RERFRVxcdURERjBcXHVEREY3LVxcdURERkJcXHVEREZFXSl8XFx1RDgzQ1xcdURERkYoPzpcXHVEODNDW1xcdURERTZcXHVEREYyXFx1RERGQ10pfFxcdUQ4M0NcXHVEREZDKD86XFx1RDgzQ1tcXHVEREVCXFx1RERGOF0pfFxcdUQ4M0NcXHVEREZBKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFQ1xcdURERjJcXHVEREYzXFx1RERGOFxcdURERkVcXHVEREZGXSl8XFx1RDgzQ1xcdURERUUoPzpcXHVEODNDW1xcdURERTgtXFx1RERFQVxcdURERjEtXFx1RERGNFxcdURERjYtXFx1RERGOV0pfFxcdUQ4M0NcXHVEREVGKD86XFx1RDgzQ1tcXHVEREVBXFx1RERGMlxcdURERjRcXHVEREY1XSl8KD86XFx1RDgzQ1tcXHVERkMzXFx1REZDNFxcdURGQ0FdfFxcdUQ4M0RbXFx1REM2RVxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM3LVxcdUREMzlcXHVERDNEXFx1REQzRVxcdUREQjhcXHVEREI5XFx1RERDRC1cXHVERENGXFx1RERENi1cXHVEREREXSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OlxcdTI2Rjl8XFx1RDgzQ1tcXHVERkNCXFx1REZDQ118XFx1RDgzRFxcdURENzUpKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXwoPzpbXFx1MjYxRFxcdTI3MEEtXFx1MjcwRF18XFx1RDgzQ1tcXHVERjg1XFx1REZDMlxcdURGQzddfFxcdUQ4M0RbXFx1REM0MlxcdURDNDNcXHVEQzQ2LVxcdURDNTBcXHVEQzY2XFx1REM2N1xcdURDNkItXFx1REM2RFxcdURDNzBcXHVEQzcyXFx1REM3NC1cXHVEQzc2XFx1REM3OFxcdURDN0NcXHVEQzgzXFx1REM4NVxcdURDQUFcXHVERDc0XFx1REQ3QVxcdUREOTBcXHVERDk1XFx1REQ5NlxcdURFNENcXHVERTRGXFx1REVDMFxcdURFQ0NdfFxcdUQ4M0VbXFx1REQwRlxcdUREMTgtXFx1REQxQ1xcdUREMUVcXHVERDFGXFx1REQzMC1cXHVERDM2XFx1RERCNVxcdUREQjZcXHVEREJCXFx1REREMi1cXHVEREQ1XSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OltcXHUyMzFBXFx1MjMxQlxcdTIzRTktXFx1MjNFQ1xcdTIzRjBcXHUyM0YzXFx1MjVGRFxcdTI1RkVcXHUyNjE0XFx1MjYxNVxcdTI2NDgtXFx1MjY1M1xcdTI2N0ZcXHUyNjkzXFx1MjZBMVxcdTI2QUFcXHUyNkFCXFx1MjZCRFxcdTI2QkVcXHUyNkM0XFx1MjZDNVxcdTI2Q0VcXHUyNkQ0XFx1MjZFQVxcdTI2RjJcXHUyNkYzXFx1MjZGNVxcdTI2RkFcXHUyNkZEXFx1MjcwNVxcdTI3MEFcXHUyNzBCXFx1MjcyOFxcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QjBcXHUyN0JGXFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NV18XFx1RDgzQ1tcXHVEQzA0XFx1RENDRlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREU2LVxcdURERkZcXHVERTAxXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFMzZcXHVERTM4LVxcdURFM0FcXHVERTUwXFx1REU1MVxcdURGMDAtXFx1REYyMFxcdURGMkQtXFx1REYzNVxcdURGMzctXFx1REY3Q1xcdURGN0UtXFx1REY5M1xcdURGQTAtXFx1REZDQVxcdURGQ0YtXFx1REZEM1xcdURGRTAtXFx1REZGMFxcdURGRjRcXHVERkY4LVxcdURGRkZdfFxcdUQ4M0RbXFx1REMwMC1cXHVEQzNFXFx1REM0MFxcdURDNDItXFx1RENGQ1xcdURDRkYtXFx1REQzRFxcdURENEItXFx1REQ0RVxcdURENTAtXFx1REQ2N1xcdUREN0FcXHVERDk1XFx1REQ5NlxcdUREQTRcXHVEREZCLVxcdURFNEZcXHVERTgwLVxcdURFQzVcXHVERUNDXFx1REVEMC1cXHVERUQyXFx1REVENVxcdURFRUJcXHVERUVDXFx1REVGNC1cXHVERUZBXFx1REZFMC1cXHVERkVCXXxcXHVEODNFW1xcdUREMEQtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REQ3MVxcdURENzMtXFx1REQ3NlxcdUREN0EtXFx1RERBMlxcdUREQTUtXFx1RERBQVxcdUREQUUtXFx1RERDQVxcdUREQ0QtXFx1RERGRlxcdURFNzAtXFx1REU3M1xcdURFNzgtXFx1REU3QVxcdURFODAtXFx1REU4MlxcdURFOTAtXFx1REU5NV0pfCg/OlsjXFwqMC05XFx4QTlcXHhBRVxcdTIwM0NcXHUyMDQ5XFx1MjEyMlxcdTIxMzlcXHUyMTk0LVxcdTIxOTlcXHUyMUE5XFx1MjFBQVxcdTIzMUFcXHUyMzFCXFx1MjMyOFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNFxcdTI2MEVcXHUyNjExXFx1MjYxNFxcdTI2MTVcXHUyNjE4XFx1MjYxRFxcdTI2MjBcXHUyNjIyXFx1MjYyM1xcdTI2MjZcXHUyNjJBXFx1MjYyRVxcdTI2MkZcXHUyNjM4LVxcdTI2M0FcXHUyNjQwXFx1MjY0MlxcdTI2NDgtXFx1MjY1M1xcdTI2NUZcXHUyNjYwXFx1MjY2M1xcdTI2NjVcXHUyNjY2XFx1MjY2OFxcdTI2N0JcXHUyNjdFXFx1MjY3RlxcdTI2OTItXFx1MjY5N1xcdTI2OTlcXHUyNjlCXFx1MjY5Q1xcdTI2QTBcXHUyNkExXFx1MjZBQVxcdTI2QUJcXHUyNkIwXFx1MjZCMVxcdTI2QkRcXHUyNkJFXFx1MjZDNFxcdTI2QzVcXHUyNkM4XFx1MjZDRVxcdTI2Q0ZcXHUyNkQxXFx1MjZEM1xcdTI2RDRcXHUyNkU5XFx1MjZFQVxcdTI2RjAtXFx1MjZGNVxcdTI2RjctXFx1MjZGQVxcdTI2RkRcXHUyNzAyXFx1MjcwNVxcdTI3MDgtXFx1MjcwRFxcdTI3MEZcXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2M1xcdTI3NjRcXHUyNzk1LVxcdTI3OTdcXHUyN0ExXFx1MjdCMFxcdTI3QkZcXHUyOTM0XFx1MjkzNVxcdTJCMDUtXFx1MkIwN1xcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVcXHUzMDMwXFx1MzAzRFxcdTMyOTdcXHUzMjk5XXxcXHVEODNDW1xcdURDMDRcXHVEQ0NGXFx1REQ3MFxcdURENzFcXHVERDdFXFx1REQ3RlxcdUREOEVcXHVERDkxLVxcdUREOUFcXHVEREU2LVxcdURERkZcXHVERTAxXFx1REUwMlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGMjFcXHVERjI0LVxcdURGOTNcXHVERjk2XFx1REY5N1xcdURGOTktXFx1REY5QlxcdURGOUUtXFx1REZGMFxcdURGRjMtXFx1REZGNVxcdURGRjctXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURDRkRcXHVEQ0ZGLVxcdUREM0RcXHVERDQ5LVxcdURENEVcXHVERDUwLVxcdURENjdcXHVERDZGXFx1REQ3MFxcdURENzMtXFx1REQ3QVxcdUREODdcXHVERDhBLVxcdUREOERcXHVERDkwXFx1REQ5NVxcdUREOTZcXHVEREE0XFx1RERBNVxcdUREQThcXHVEREIxXFx1RERCMlxcdUREQkNcXHVEREMyLVxcdUREQzRcXHVEREQxLVxcdURERDNcXHVERERDLVxcdUREREVcXHVEREUxXFx1RERFM1xcdURERThcXHVEREVGXFx1RERGM1xcdURERkEtXFx1REU0RlxcdURFODAtXFx1REVDNVxcdURFQ0ItXFx1REVEMlxcdURFRDVcXHVERUUwLVxcdURFRTVcXHVERUU5XFx1REVFQlxcdURFRUNcXHVERUYwXFx1REVGMy1cXHVERUZBXFx1REZFMC1cXHVERkVCXXxcXHVEODNFW1xcdUREMEQtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REQ3MVxcdURENzMtXFx1REQ3NlxcdUREN0EtXFx1RERBMlxcdUREQTUtXFx1RERBQVxcdUREQUUtXFx1RERDQVxcdUREQ0QtXFx1RERGRlxcdURFNzAtXFx1REU3M1xcdURFNzgtXFx1REU3QVxcdURFODAtXFx1REU4MlxcdURFOTAtXFx1REU5NV0pXFx1RkUwRnwoPzpbXFx1MjYxRFxcdTI2RjlcXHUyNzBBLVxcdTI3MERdfFxcdUQ4M0NbXFx1REY4NVxcdURGQzItXFx1REZDNFxcdURGQzdcXHVERkNBLVxcdURGQ0NdfFxcdUQ4M0RbXFx1REM0MlxcdURDNDNcXHVEQzQ2LVxcdURDNTBcXHVEQzY2LVxcdURDNzhcXHVEQzdDXFx1REM4MS1cXHVEQzgzXFx1REM4NS1cXHVEQzg3XFx1REM4RlxcdURDOTFcXHVEQ0FBXFx1REQ3NFxcdURENzVcXHVERDdBXFx1REQ5MFxcdUREOTVcXHVERDk2XFx1REU0NS1cXHVERTQ3XFx1REU0Qi1cXHVERTRGXFx1REVBM1xcdURFQjQtXFx1REVCNlxcdURFQzBcXHVERUNDXXxcXHVEODNFW1xcdUREMEZcXHVERDE4LVxcdUREMUZcXHVERDI2XFx1REQzMC1cXHVERDM5XFx1REQzQy1cXHVERDNFXFx1RERCNVxcdUREQjZcXHVEREI4XFx1RERCOVxcdUREQkJcXHVERENELVxcdUREQ0ZcXHVEREQxLVxcdURERERdKS9nO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///58\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nconst stringWidth = __webpack_require__(14)\nconst stripAnsi = __webpack_require__(4)\nconst wrap = __webpack_require__(60)\n\nconst align = {\n  right: alignRight,\n  center: alignCenter\n}\nconst top = 0\nconst right = 1\nconst bottom = 2\nconst left = 3\n\nclass UI {\n  constructor (opts) {\n    this.width = opts.width\n    this.wrap = opts.wrap\n    this.rows = []\n  }\n\n  span (...args) {\n    const cols = this.div(...args)\n    cols.span = true\n  }\n\n  resetOutput () {\n    this.rows = []\n  }\n\n  div (...args) {\n    if (args.length === 0) {\n      this.div('')\n    }\n\n    if (this.wrap && this._shouldApplyLayoutDSL(...args)) {\n      return this._applyLayoutDSL(args[0])\n    }\n\n    const cols = args.map(arg => {\n      if (typeof arg === 'string') {\n        return this._colFromString(arg)\n      }\n\n      return arg\n    })\n\n    this.rows.push(cols)\n    return cols\n  }\n\n  _shouldApplyLayoutDSL (...args) {\n    return args.length === 1 && typeof args[0] === 'string' &&\n      /[\\t\\n]/.test(args[0])\n  }\n\n  _applyLayoutDSL (str) {\n    const rows = str.split('\\n').map(row => row.split('\\t'))\n    let leftColumnWidth = 0\n\n    // simple heuristic for layout, make sure the\n    // second column lines up along the left-hand.\n    // don't allow the first column to take up more\n    // than 50% of the screen.\n    rows.forEach(columns => {\n      if (columns.length > 1 && stringWidth(columns[0]) > leftColumnWidth) {\n        leftColumnWidth = Math.min(\n          Math.floor(this.width * 0.5),\n          stringWidth(columns[0])\n        )\n      }\n    })\n\n    // generate a table:\n    //  replacing ' ' with padding calculations.\n    //  using the algorithmically generated width.\n    rows.forEach(columns => {\n      this.div(...columns.map((r, i) => {\n        return {\n          text: r.trim(),\n          padding: this._measurePadding(r),\n          width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined\n        }\n      }))\n    })\n\n    return this.rows[this.rows.length - 1]\n  }\n\n  _colFromString (text) {\n    return {\n      text,\n      padding: this._measurePadding(text)\n    }\n  }\n\n  _measurePadding (str) {\n    // measure padding without ansi escape codes\n    const noAnsi = stripAnsi(str)\n    return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length]\n  }\n\n  toString () {\n    const lines = []\n\n    this.rows.forEach(row => {\n      this.rowToString(row, lines)\n    })\n\n    // don't display any lines with the\n    // hidden flag set.\n    return lines\n      .filter(line => !line.hidden)\n      .map(line => line.text)\n      .join('\\n')\n  }\n\n  rowToString (row, lines) {\n    this._rasterize(row).forEach((rrow, r) => {\n      let str = ''\n      rrow.forEach((col, c) => {\n        const { width } = row[c] // the width with padding.\n        const wrapWidth = this._negatePadding(row[c]) // the width without padding.\n\n        let ts = col // temporary string used during alignment/padding.\n\n        if (wrapWidth > stringWidth(col)) {\n          ts += ' '.repeat(wrapWidth - stringWidth(col))\n        }\n\n        // align the string within its column.\n        if (row[c].align && row[c].align !== 'left' && this.wrap) {\n          ts = align[row[c].align](ts, wrapWidth)\n          if (stringWidth(ts) < wrapWidth) {\n            ts += ' '.repeat(width - stringWidth(ts) - 1)\n          }\n        }\n\n        // apply border and padding to string.\n        const padding = row[c].padding || [0, 0, 0, 0]\n        if (padding[left]) {\n          str += ' '.repeat(padding[left])\n        }\n\n        str += addBorder(row[c], ts, '| ')\n        str += ts\n        str += addBorder(row[c], ts, ' |')\n        if (padding[right]) {\n          str += ' '.repeat(padding[right])\n        }\n\n        // if prior row is span, try to render the\n        // current row on the prior line.\n        if (r === 0 && lines.length > 0) {\n          str = this._renderInline(str, lines[lines.length - 1])\n        }\n      })\n\n      // remove trailing whitespace.\n      lines.push({\n        text: str.replace(/ +$/, ''),\n        span: row.span\n      })\n    })\n\n    return lines\n  }\n\n  // if the full 'source' can render in\n  // the target line, do so.\n  _renderInline (source, previousLine) {\n    const leadingWhitespace = source.match(/^ */)[0].length\n    const target = previousLine.text\n    const targetTextWidth = stringWidth(target.trimRight())\n\n    if (!previousLine.span) {\n      return source\n    }\n\n    // if we're not applying wrapping logic,\n    // just always append to the span.\n    if (!this.wrap) {\n      previousLine.hidden = true\n      return target + source\n    }\n\n    if (leadingWhitespace < targetTextWidth) {\n      return source\n    }\n\n    previousLine.hidden = true\n\n    return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft()\n  }\n\n  _rasterize (row) {\n    const rrows = []\n    const widths = this._columnWidths(row)\n    let wrapped\n\n    // word wrap all columns, and create\n    // a data-structure that is easy to rasterize.\n    row.forEach((col, c) => {\n      // leave room for left and right padding.\n      col.width = widths[c]\n      if (this.wrap) {\n        wrapped = wrap(col.text, this._negatePadding(col), { hard: true }).split('\\n')\n      } else {\n        wrapped = col.text.split('\\n')\n      }\n\n      if (col.border) {\n        wrapped.unshift('.' + '-'.repeat(this._negatePadding(col) + 2) + '.')\n        wrapped.push(\"'\" + '-'.repeat(this._negatePadding(col) + 2) + \"'\")\n      }\n\n      // add top and bottom padding.\n      if (col.padding) {\n        wrapped.unshift(...new Array(col.padding[top] || 0).fill(''))\n        wrapped.push(...new Array(col.padding[bottom] || 0).fill(''))\n      }\n\n      wrapped.forEach((str, r) => {\n        if (!rrows[r]) {\n          rrows.push([])\n        }\n\n        const rrow = rrows[r]\n\n        for (let i = 0; i < c; i++) {\n          if (rrow[i] === undefined) {\n            rrow.push('')\n          }\n        }\n\n        rrow.push(str)\n      })\n    })\n\n    return rrows\n  }\n\n  _negatePadding (col) {\n    let wrapWidth = col.width\n    if (col.padding) {\n      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0)\n    }\n\n    if (col.border) {\n      wrapWidth -= 4\n    }\n\n    return wrapWidth\n  }\n\n  _columnWidths (row) {\n    if (!this.wrap) {\n      return row.map(col => {\n        return col.width || stringWidth(col.text)\n      })\n    }\n\n    let unset = row.length\n    let remainingWidth = this.width\n\n    // column widths can be set in config.\n    const widths = row.map(col => {\n      if (col.width) {\n        unset--\n        remainingWidth -= col.width\n        return col.width\n      }\n\n      return undefined\n    })\n\n    // any unset widths should be calculated.\n    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0\n\n    return widths.map((w, i) => {\n      if (w === undefined) {\n        return Math.max(unsetWidth, _minWidth(row[i]))\n      }\n\n      return w\n    })\n  }\n}\n\nfunction addBorder (col, ts, style) {\n  if (col.border) {\n    if (/[.']-+[.']/.test(ts)) {\n      return ''\n    }\n\n    if (ts.trim().length !== 0) {\n      return style\n    }\n\n    return '  '\n  }\n\n  return ''\n}\n\n// calculates the minimum width of\n// a column, based on padding preferences.\nfunction _minWidth (col) {\n  const padding = col.padding || []\n  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0)\n  if (col.border) {\n    return minWidth + 4\n  }\n\n  return minWidth\n}\n\nfunction getWindowWidth () {\n  /* istanbul ignore next: depends on terminal */\n  if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n    return process.stdout.columns\n  }\n}\n\nfunction alignRight (str, width) {\n  str = str.trim()\n  const strWidth = stringWidth(str)\n\n  if (strWidth < width) {\n    return ' '.repeat(width - strWidth) + str\n  }\n\n  return str\n}\n\nfunction alignCenter (str, width) {\n  str = str.trim()\n  const strWidth = stringWidth(str)\n\n  /* istanbul ignore next */\n  if (strWidth >= width) {\n    return str\n  }\n\n  return ' '.repeat((width - strWidth) >> 1) + str\n}\n\nmodule.exports = function (opts = {}) {\n  return new UI({\n    width: opts.width || getWindowWidth() || /* istanbul ignore next */ 80,\n    wrap: opts.wrap !== false\n  })\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xpdWkvaW5kZXguanM/ZTgyYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBWTs7QUFFWixvQkFBb0IsbUJBQU8sQ0FBQyxFQUFjO0FBQzFDLGtCQUFrQixtQkFBTyxDQUFDLENBQVk7QUFDdEMsYUFBYSxtQkFBTyxDQUFDLEVBQVc7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsYUFBYTtBQUN6RSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiI1OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBzdHJpbmdXaWR0aCA9IHJlcXVpcmUoJ3N0cmluZy13aWR0aCcpXG5jb25zdCBzdHJpcEFuc2kgPSByZXF1aXJlKCdzdHJpcC1hbnNpJylcbmNvbnN0IHdyYXAgPSByZXF1aXJlKCd3cmFwLWFuc2knKVxuXG5jb25zdCBhbGlnbiA9IHtcbiAgcmlnaHQ6IGFsaWduUmlnaHQsXG4gIGNlbnRlcjogYWxpZ25DZW50ZXJcbn1cbmNvbnN0IHRvcCA9IDBcbmNvbnN0IHJpZ2h0ID0gMVxuY29uc3QgYm90dG9tID0gMlxuY29uc3QgbGVmdCA9IDNcblxuY2xhc3MgVUkge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHRoaXMud2lkdGggPSBvcHRzLndpZHRoXG4gICAgdGhpcy53cmFwID0gb3B0cy53cmFwXG4gICAgdGhpcy5yb3dzID0gW11cbiAgfVxuXG4gIHNwYW4gKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBjb2xzID0gdGhpcy5kaXYoLi4uYXJncylcbiAgICBjb2xzLnNwYW4gPSB0cnVlXG4gIH1cblxuICByZXNldE91dHB1dCAoKSB7XG4gICAgdGhpcy5yb3dzID0gW11cbiAgfVxuXG4gIGRpdiAoLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5kaXYoJycpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMud3JhcCAmJiB0aGlzLl9zaG91bGRBcHBseUxheW91dERTTCguLi5hcmdzKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FwcGx5TGF5b3V0RFNMKGFyZ3NbMF0pXG4gICAgfVxuXG4gICAgY29uc3QgY29scyA9IGFyZ3MubWFwKGFyZyA9PiB7XG4gICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbEZyb21TdHJpbmcoYXJnKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJnXG4gICAgfSlcblxuICAgIHRoaXMucm93cy5wdXNoKGNvbHMpXG4gICAgcmV0dXJuIGNvbHNcbiAgfVxuXG4gIF9zaG91bGRBcHBseUxheW91dERTTCAoLi4uYXJncykge1xuICAgIHJldHVybiBhcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgJiZcbiAgICAgIC9bXFx0XFxuXS8udGVzdChhcmdzWzBdKVxuICB9XG5cbiAgX2FwcGx5TGF5b3V0RFNMIChzdHIpIHtcbiAgICBjb25zdCByb3dzID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAocm93ID0+IHJvdy5zcGxpdCgnXFx0JykpXG4gICAgbGV0IGxlZnRDb2x1bW5XaWR0aCA9IDBcblxuICAgIC8vIHNpbXBsZSBoZXVyaXN0aWMgZm9yIGxheW91dCwgbWFrZSBzdXJlIHRoZVxuICAgIC8vIHNlY29uZCBjb2x1bW4gbGluZXMgdXAgYWxvbmcgdGhlIGxlZnQtaGFuZC5cbiAgICAvLyBkb24ndCBhbGxvdyB0aGUgZmlyc3QgY29sdW1uIHRvIHRha2UgdXAgbW9yZVxuICAgIC8vIHRoYW4gNTAlIG9mIHRoZSBzY3JlZW4uXG4gICAgcm93cy5mb3JFYWNoKGNvbHVtbnMgPT4ge1xuICAgICAgaWYgKGNvbHVtbnMubGVuZ3RoID4gMSAmJiBzdHJpbmdXaWR0aChjb2x1bW5zWzBdKSA+IGxlZnRDb2x1bW5XaWR0aCkge1xuICAgICAgICBsZWZ0Q29sdW1uV2lkdGggPSBNYXRoLm1pbihcbiAgICAgICAgICBNYXRoLmZsb29yKHRoaXMud2lkdGggKiAwLjUpLFxuICAgICAgICAgIHN0cmluZ1dpZHRoKGNvbHVtbnNbMF0pXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gZ2VuZXJhdGUgYSB0YWJsZTpcbiAgICAvLyAgcmVwbGFjaW5nICcgJyB3aXRoIHBhZGRpbmcgY2FsY3VsYXRpb25zLlxuICAgIC8vICB1c2luZyB0aGUgYWxnb3JpdGhtaWNhbGx5IGdlbmVyYXRlZCB3aWR0aC5cbiAgICByb3dzLmZvckVhY2goY29sdW1ucyA9PiB7XG4gICAgICB0aGlzLmRpdiguLi5jb2x1bW5zLm1hcCgociwgaSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRleHQ6IHIudHJpbSgpLFxuICAgICAgICAgIHBhZGRpbmc6IHRoaXMuX21lYXN1cmVQYWRkaW5nKHIpLFxuICAgICAgICAgIHdpZHRoOiAoaSA9PT0gMCAmJiBjb2x1bW5zLmxlbmd0aCA+IDEpID8gbGVmdENvbHVtbldpZHRoIDogdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgIH0pKVxuICAgIH0pXG5cbiAgICByZXR1cm4gdGhpcy5yb3dzW3RoaXMucm93cy5sZW5ndGggLSAxXVxuICB9XG5cbiAgX2NvbEZyb21TdHJpbmcgKHRleHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGV4dCxcbiAgICAgIHBhZGRpbmc6IHRoaXMuX21lYXN1cmVQYWRkaW5nKHRleHQpXG4gICAgfVxuICB9XG5cbiAgX21lYXN1cmVQYWRkaW5nIChzdHIpIHtcbiAgICAvLyBtZWFzdXJlIHBhZGRpbmcgd2l0aG91dCBhbnNpIGVzY2FwZSBjb2Rlc1xuICAgIGNvbnN0IG5vQW5zaSA9IHN0cmlwQW5zaShzdHIpXG4gICAgcmV0dXJuIFswLCBub0Fuc2kubWF0Y2goL1xccyokLylbMF0ubGVuZ3RoLCAwLCBub0Fuc2kubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoXVxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIGNvbnN0IGxpbmVzID0gW11cblxuICAgIHRoaXMucm93cy5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICB0aGlzLnJvd1RvU3RyaW5nKHJvdywgbGluZXMpXG4gICAgfSlcblxuICAgIC8vIGRvbid0IGRpc3BsYXkgYW55IGxpbmVzIHdpdGggdGhlXG4gICAgLy8gaGlkZGVuIGZsYWcgc2V0LlxuICAgIHJldHVybiBsaW5lc1xuICAgICAgLmZpbHRlcihsaW5lID0+ICFsaW5lLmhpZGRlbilcbiAgICAgIC5tYXAobGluZSA9PiBsaW5lLnRleHQpXG4gICAgICAuam9pbignXFxuJylcbiAgfVxuXG4gIHJvd1RvU3RyaW5nIChyb3csIGxpbmVzKSB7XG4gICAgdGhpcy5fcmFzdGVyaXplKHJvdykuZm9yRWFjaCgocnJvdywgcikgPT4ge1xuICAgICAgbGV0IHN0ciA9ICcnXG4gICAgICBycm93LmZvckVhY2goKGNvbCwgYykgPT4ge1xuICAgICAgICBjb25zdCB7IHdpZHRoIH0gPSByb3dbY10gLy8gdGhlIHdpZHRoIHdpdGggcGFkZGluZy5cbiAgICAgICAgY29uc3Qgd3JhcFdpZHRoID0gdGhpcy5fbmVnYXRlUGFkZGluZyhyb3dbY10pIC8vIHRoZSB3aWR0aCB3aXRob3V0IHBhZGRpbmcuXG5cbiAgICAgICAgbGV0IHRzID0gY29sIC8vIHRlbXBvcmFyeSBzdHJpbmcgdXNlZCBkdXJpbmcgYWxpZ25tZW50L3BhZGRpbmcuXG5cbiAgICAgICAgaWYgKHdyYXBXaWR0aCA+IHN0cmluZ1dpZHRoKGNvbCkpIHtcbiAgICAgICAgICB0cyArPSAnICcucmVwZWF0KHdyYXBXaWR0aCAtIHN0cmluZ1dpZHRoKGNvbCkpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbGlnbiB0aGUgc3RyaW5nIHdpdGhpbiBpdHMgY29sdW1uLlxuICAgICAgICBpZiAocm93W2NdLmFsaWduICYmIHJvd1tjXS5hbGlnbiAhPT0gJ2xlZnQnICYmIHRoaXMud3JhcCkge1xuICAgICAgICAgIHRzID0gYWxpZ25bcm93W2NdLmFsaWduXSh0cywgd3JhcFdpZHRoKVxuICAgICAgICAgIGlmIChzdHJpbmdXaWR0aCh0cykgPCB3cmFwV2lkdGgpIHtcbiAgICAgICAgICAgIHRzICs9ICcgJy5yZXBlYXQod2lkdGggLSBzdHJpbmdXaWR0aCh0cykgLSAxKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGx5IGJvcmRlciBhbmQgcGFkZGluZyB0byBzdHJpbmcuXG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSByb3dbY10ucGFkZGluZyB8fCBbMCwgMCwgMCwgMF1cbiAgICAgICAgaWYgKHBhZGRpbmdbbGVmdF0pIHtcbiAgICAgICAgICBzdHIgKz0gJyAnLnJlcGVhdChwYWRkaW5nW2xlZnRdKVxuICAgICAgICB9XG5cbiAgICAgICAgc3RyICs9IGFkZEJvcmRlcihyb3dbY10sIHRzLCAnfCAnKVxuICAgICAgICBzdHIgKz0gdHNcbiAgICAgICAgc3RyICs9IGFkZEJvcmRlcihyb3dbY10sIHRzLCAnIHwnKVxuICAgICAgICBpZiAocGFkZGluZ1tyaWdodF0pIHtcbiAgICAgICAgICBzdHIgKz0gJyAnLnJlcGVhdChwYWRkaW5nW3JpZ2h0XSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHByaW9yIHJvdyBpcyBzcGFuLCB0cnkgdG8gcmVuZGVyIHRoZVxuICAgICAgICAvLyBjdXJyZW50IHJvdyBvbiB0aGUgcHJpb3IgbGluZS5cbiAgICAgICAgaWYgKHIgPT09IDAgJiYgbGluZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0ciA9IHRoaXMuX3JlbmRlcklubGluZShzdHIsIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZS5cbiAgICAgIGxpbmVzLnB1c2goe1xuICAgICAgICB0ZXh0OiBzdHIucmVwbGFjZSgvICskLywgJycpLFxuICAgICAgICBzcGFuOiByb3cuc3BhblxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIGxpbmVzXG4gIH1cblxuICAvLyBpZiB0aGUgZnVsbCAnc291cmNlJyBjYW4gcmVuZGVyIGluXG4gIC8vIHRoZSB0YXJnZXQgbGluZSwgZG8gc28uXG4gIF9yZW5kZXJJbmxpbmUgKHNvdXJjZSwgcHJldmlvdXNMaW5lKSB7XG4gICAgY29uc3QgbGVhZGluZ1doaXRlc3BhY2UgPSBzb3VyY2UubWF0Y2goL14gKi8pWzBdLmxlbmd0aFxuICAgIGNvbnN0IHRhcmdldCA9IHByZXZpb3VzTGluZS50ZXh0XG4gICAgY29uc3QgdGFyZ2V0VGV4dFdpZHRoID0gc3RyaW5nV2lkdGgodGFyZ2V0LnRyaW1SaWdodCgpKVxuXG4gICAgaWYgKCFwcmV2aW91c0xpbmUuc3Bhbikge1xuICAgICAgcmV0dXJuIHNvdXJjZVxuICAgIH1cblxuICAgIC8vIGlmIHdlJ3JlIG5vdCBhcHBseWluZyB3cmFwcGluZyBsb2dpYyxcbiAgICAvLyBqdXN0IGFsd2F5cyBhcHBlbmQgdG8gdGhlIHNwYW4uXG4gICAgaWYgKCF0aGlzLndyYXApIHtcbiAgICAgIHByZXZpb3VzTGluZS5oaWRkZW4gPSB0cnVlXG4gICAgICByZXR1cm4gdGFyZ2V0ICsgc291cmNlXG4gICAgfVxuXG4gICAgaWYgKGxlYWRpbmdXaGl0ZXNwYWNlIDwgdGFyZ2V0VGV4dFdpZHRoKSB7XG4gICAgICByZXR1cm4gc291cmNlXG4gICAgfVxuXG4gICAgcHJldmlvdXNMaW5lLmhpZGRlbiA9IHRydWVcblxuICAgIHJldHVybiB0YXJnZXQudHJpbVJpZ2h0KCkgKyAnICcucmVwZWF0KGxlYWRpbmdXaGl0ZXNwYWNlIC0gdGFyZ2V0VGV4dFdpZHRoKSArIHNvdXJjZS50cmltTGVmdCgpXG4gIH1cblxuICBfcmFzdGVyaXplIChyb3cpIHtcbiAgICBjb25zdCBycm93cyA9IFtdXG4gICAgY29uc3Qgd2lkdGhzID0gdGhpcy5fY29sdW1uV2lkdGhzKHJvdylcbiAgICBsZXQgd3JhcHBlZFxuXG4gICAgLy8gd29yZCB3cmFwIGFsbCBjb2x1bW5zLCBhbmQgY3JlYXRlXG4gICAgLy8gYSBkYXRhLXN0cnVjdHVyZSB0aGF0IGlzIGVhc3kgdG8gcmFzdGVyaXplLlxuICAgIHJvdy5mb3JFYWNoKChjb2wsIGMpID0+IHtcbiAgICAgIC8vIGxlYXZlIHJvb20gZm9yIGxlZnQgYW5kIHJpZ2h0IHBhZGRpbmcuXG4gICAgICBjb2wud2lkdGggPSB3aWR0aHNbY11cbiAgICAgIGlmICh0aGlzLndyYXApIHtcbiAgICAgICAgd3JhcHBlZCA9IHdyYXAoY29sLnRleHQsIHRoaXMuX25lZ2F0ZVBhZGRpbmcoY29sKSwgeyBoYXJkOiB0cnVlIH0pLnNwbGl0KCdcXG4nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JhcHBlZCA9IGNvbC50ZXh0LnNwbGl0KCdcXG4nKVxuICAgICAgfVxuXG4gICAgICBpZiAoY29sLmJvcmRlcikge1xuICAgICAgICB3cmFwcGVkLnVuc2hpZnQoJy4nICsgJy0nLnJlcGVhdCh0aGlzLl9uZWdhdGVQYWRkaW5nKGNvbCkgKyAyKSArICcuJylcbiAgICAgICAgd3JhcHBlZC5wdXNoKFwiJ1wiICsgJy0nLnJlcGVhdCh0aGlzLl9uZWdhdGVQYWRkaW5nKGNvbCkgKyAyKSArIFwiJ1wiKVxuICAgICAgfVxuXG4gICAgICAvLyBhZGQgdG9wIGFuZCBib3R0b20gcGFkZGluZy5cbiAgICAgIGlmIChjb2wucGFkZGluZykge1xuICAgICAgICB3cmFwcGVkLnVuc2hpZnQoLi4ubmV3IEFycmF5KGNvbC5wYWRkaW5nW3RvcF0gfHwgMCkuZmlsbCgnJykpXG4gICAgICAgIHdyYXBwZWQucHVzaCguLi5uZXcgQXJyYXkoY29sLnBhZGRpbmdbYm90dG9tXSB8fCAwKS5maWxsKCcnKSlcbiAgICAgIH1cblxuICAgICAgd3JhcHBlZC5mb3JFYWNoKChzdHIsIHIpID0+IHtcbiAgICAgICAgaWYgKCFycm93c1tyXSkge1xuICAgICAgICAgIHJyb3dzLnB1c2goW10pXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBycm93ID0gcnJvd3Nbcl1cblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGM7IGkrKykge1xuICAgICAgICAgIGlmIChycm93W2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJyb3cucHVzaCgnJylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBycm93LnB1c2goc3RyKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcmV0dXJuIHJyb3dzXG4gIH1cblxuICBfbmVnYXRlUGFkZGluZyAoY29sKSB7XG4gICAgbGV0IHdyYXBXaWR0aCA9IGNvbC53aWR0aFxuICAgIGlmIChjb2wucGFkZGluZykge1xuICAgICAgd3JhcFdpZHRoIC09IChjb2wucGFkZGluZ1tsZWZ0XSB8fCAwKSArIChjb2wucGFkZGluZ1tyaWdodF0gfHwgMClcbiAgICB9XG5cbiAgICBpZiAoY29sLmJvcmRlcikge1xuICAgICAgd3JhcFdpZHRoIC09IDRcbiAgICB9XG5cbiAgICByZXR1cm4gd3JhcFdpZHRoXG4gIH1cblxuICBfY29sdW1uV2lkdGhzIChyb3cpIHtcbiAgICBpZiAoIXRoaXMud3JhcCkge1xuICAgICAgcmV0dXJuIHJvdy5tYXAoY29sID0+IHtcbiAgICAgICAgcmV0dXJuIGNvbC53aWR0aCB8fCBzdHJpbmdXaWR0aChjb2wudGV4dClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgbGV0IHVuc2V0ID0gcm93Lmxlbmd0aFxuICAgIGxldCByZW1haW5pbmdXaWR0aCA9IHRoaXMud2lkdGhcblxuICAgIC8vIGNvbHVtbiB3aWR0aHMgY2FuIGJlIHNldCBpbiBjb25maWcuXG4gICAgY29uc3Qgd2lkdGhzID0gcm93Lm1hcChjb2wgPT4ge1xuICAgICAgaWYgKGNvbC53aWR0aCkge1xuICAgICAgICB1bnNldC0tXG4gICAgICAgIHJlbWFpbmluZ1dpZHRoIC09IGNvbC53aWR0aFxuICAgICAgICByZXR1cm4gY29sLndpZHRoXG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9KVxuXG4gICAgLy8gYW55IHVuc2V0IHdpZHRocyBzaG91bGQgYmUgY2FsY3VsYXRlZC5cbiAgICBjb25zdCB1bnNldFdpZHRoID0gdW5zZXQgPyBNYXRoLmZsb29yKHJlbWFpbmluZ1dpZHRoIC8gdW5zZXQpIDogMFxuXG4gICAgcmV0dXJuIHdpZHRocy5tYXAoKHcsIGkpID0+IHtcbiAgICAgIGlmICh3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHVuc2V0V2lkdGgsIF9taW5XaWR0aChyb3dbaV0pKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gd1xuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkQm9yZGVyIChjb2wsIHRzLCBzdHlsZSkge1xuICBpZiAoY29sLmJvcmRlcikge1xuICAgIGlmICgvWy4nXS0rWy4nXS8udGVzdCh0cykpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cblxuICAgIGlmICh0cy50cmltKCkubGVuZ3RoICE9PSAwKSB7XG4gICAgICByZXR1cm4gc3R5bGVcbiAgICB9XG5cbiAgICByZXR1cm4gJyAgJ1xuICB9XG5cbiAgcmV0dXJuICcnXG59XG5cbi8vIGNhbGN1bGF0ZXMgdGhlIG1pbmltdW0gd2lkdGggb2Zcbi8vIGEgY29sdW1uLCBiYXNlZCBvbiBwYWRkaW5nIHByZWZlcmVuY2VzLlxuZnVuY3Rpb24gX21pbldpZHRoIChjb2wpIHtcbiAgY29uc3QgcGFkZGluZyA9IGNvbC5wYWRkaW5nIHx8IFtdXG4gIGNvbnN0IG1pbldpZHRoID0gMSArIChwYWRkaW5nW2xlZnRdIHx8IDApICsgKHBhZGRpbmdbcmlnaHRdIHx8IDApXG4gIGlmIChjb2wuYm9yZGVyKSB7XG4gICAgcmV0dXJuIG1pbldpZHRoICsgNFxuICB9XG5cbiAgcmV0dXJuIG1pbldpZHRoXG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1dpZHRoICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IGRlcGVuZHMgb24gdGVybWluYWwgKi9cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLnN0ZG91dCAmJiBwcm9jZXNzLnN0ZG91dC5jb2x1bW5zKSB7XG4gICAgcmV0dXJuIHByb2Nlc3Muc3Rkb3V0LmNvbHVtbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGlnblJpZ2h0IChzdHIsIHdpZHRoKSB7XG4gIHN0ciA9IHN0ci50cmltKClcbiAgY29uc3Qgc3RyV2lkdGggPSBzdHJpbmdXaWR0aChzdHIpXG5cbiAgaWYgKHN0cldpZHRoIDwgd2lkdGgpIHtcbiAgICByZXR1cm4gJyAnLnJlcGVhdCh3aWR0aCAtIHN0cldpZHRoKSArIHN0clxuICB9XG5cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBhbGlnbkNlbnRlciAoc3RyLCB3aWR0aCkge1xuICBzdHIgPSBzdHIudHJpbSgpXG4gIGNvbnN0IHN0cldpZHRoID0gc3RyaW5nV2lkdGgoc3RyKVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGlmIChzdHJXaWR0aCA+PSB3aWR0aCkge1xuICAgIHJldHVybiBzdHJcbiAgfVxuXG4gIHJldHVybiAnICcucmVwZWF0KCh3aWR0aCAtIHN0cldpZHRoKSA+PiAxKSArIHN0clxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzID0ge30pIHtcbiAgcmV0dXJuIG5ldyBVSSh7XG4gICAgd2lkdGg6IG9wdHMud2lkdGggfHwgZ2V0V2luZG93V2lkdGgoKSB8fCAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqLyA4MCxcbiAgICB3cmFwOiBvcHRzLndyYXAgIT09IGZhbHNlXG4gIH0pXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///59\n")},function(module,exports,__webpack_require__){"use strict";eval("\nconst stringWidth = __webpack_require__(14);\nconst stripAnsi = __webpack_require__(4);\nconst ansiStyles = __webpack_require__(16);\n\nconst ESCAPES = new Set([\n\t'\\u001B',\n\t'\\u009B'\n]);\n\nconst END_CODE = 39;\n\nconst wrapAnsi = code => `${ESCAPES.values().next().value}[${code}m`;\n\n// Calculate the length of words split on ' ', ignoring\n// the extra characters added by ansi escape codes\nconst wordLengths = string => string.split(' ').map(character => stringWidth(character));\n\n// Wrap a long word across multiple rows\n// Ansi escape codes do not count towards length\nconst wrapWord = (rows, word, columns) => {\n\tconst characters = [...word];\n\n\tlet isInsideEscape = false;\n\tlet visible = stringWidth(stripAnsi(rows[rows.length - 1]));\n\n\tfor (const [index, character] of characters.entries()) {\n\t\tconst characterLength = stringWidth(character);\n\n\t\tif (visible + characterLength <= columns) {\n\t\t\trows[rows.length - 1] += character;\n\t\t} else {\n\t\t\trows.push(character);\n\t\t\tvisible = 0;\n\t\t}\n\n\t\tif (ESCAPES.has(character)) {\n\t\t\tisInsideEscape = true;\n\t\t} else if (isInsideEscape && character === 'm') {\n\t\t\tisInsideEscape = false;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (isInsideEscape) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tvisible += characterLength;\n\n\t\tif (visible === columns && index < characters.length - 1) {\n\t\t\trows.push('');\n\t\t\tvisible = 0;\n\t\t}\n\t}\n\n\t// It's possible that the last row we copy over is only\n\t// ansi escape characters, handle this edge-case\n\tif (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {\n\t\trows[rows.length - 2] += rows.pop();\n\t}\n};\n\n// Trims spaces from a string ignoring invisible sequences\nconst stringVisibleTrimSpacesRight = str => {\n\tconst words = str.split(' ');\n\tlet last = words.length;\n\n\twhile (last > 0) {\n\t\tif (stringWidth(words[last - 1]) > 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlast--;\n\t}\n\n\tif (last === words.length) {\n\t\treturn str;\n\t}\n\n\treturn words.slice(0, last).join(' ') + words.slice(last).join('');\n};\n\n// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode\n//\n// 'hard' will never allow a string to take up more than columns characters\n//\n// 'soft' allows long words to expand past the column length\nconst exec = (string, columns, options = {}) => {\n\tif (options.trim !== false && string.trim() === '') {\n\t\treturn '';\n\t}\n\n\tlet pre = '';\n\tlet ret = '';\n\tlet escapeCode;\n\n\tconst lengths = wordLengths(string);\n\tlet rows = [''];\n\n\tfor (const [index, word] of string.split(' ').entries()) {\n\t\tif (options.trim !== false) {\n\t\t\trows[rows.length - 1] = rows[rows.length - 1].trimLeft();\n\t\t}\n\n\t\tlet rowLength = stringWidth(rows[rows.length - 1]);\n\n\t\tif (index !== 0) {\n\t\t\tif (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {\n\t\t\t\t// If we start with a new word but the current row length equals the length of the columns, add a new row\n\t\t\t\trows.push('');\n\t\t\t\trowLength = 0;\n\t\t\t}\n\n\t\t\tif (rowLength > 0 || options.trim === false) {\n\t\t\t\trows[rows.length - 1] += ' ';\n\t\t\t\trowLength++;\n\t\t\t}\n\t\t}\n\n\t\t// In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'\n\t\tif (options.hard && lengths[index] > columns) {\n\t\t\tconst remainingColumns = (columns - rowLength);\n\t\t\tconst breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);\n\t\t\tconst breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);\n\t\t\tif (breaksStartingNextLine < breaksStartingThisLine) {\n\t\t\t\trows.push('');\n\t\t\t}\n\n\t\t\twrapWord(rows, word, columns);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > 0) {\n\t\t\tif (options.wordWrap === false && rowLength < columns) {\n\t\t\t\twrapWord(rows, word, columns);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trows.push('');\n\t\t}\n\n\t\tif (rowLength + lengths[index] > columns && options.wordWrap === false) {\n\t\t\twrapWord(rows, word, columns);\n\t\t\tcontinue;\n\t\t}\n\n\t\trows[rows.length - 1] += word;\n\t}\n\n\tif (options.trim !== false) {\n\t\trows = rows.map(stringVisibleTrimSpacesRight);\n\t}\n\n\tpre = rows.join('\\n');\n\n\tfor (const [index, character] of [...pre].entries()) {\n\t\tret += character;\n\n\t\tif (ESCAPES.has(character)) {\n\t\t\tconst code = parseFloat(/\\d[^m]*/.exec(pre.slice(index, index + 4)));\n\t\t\tescapeCode = code === END_CODE ? null : code;\n\t\t}\n\n\t\tconst code = ansiStyles.codes.get(Number(escapeCode));\n\n\t\tif (escapeCode && code) {\n\t\t\tif (pre[index + 1] === '\\n') {\n\t\t\t\tret += wrapAnsi(code);\n\t\t\t} else if (character === '\\n') {\n\t\t\t\tret += wrapAnsi(escapeCode);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n};\n\n// For each newline, invoke the method separately\nmodule.exports = (string, columns, options) => {\n\treturn String(string)\n\t\t.normalize()\n\t\t.replace(/\\r\\n/g, '\\n')\n\t\t.split('\\n')\n\t\t.map(line => exec(line, columns, options))\n\t\t.join('\\n');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvd3JhcC1hbnNpL2luZGV4LmpzPzU0NDQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixvQkFBb0IsbUJBQU8sQ0FBQyxFQUFjO0FBQzFDLGtCQUFrQixtQkFBTyxDQUFDLENBQVk7QUFDdEMsbUJBQW1CLG1CQUFPLENBQUMsRUFBYTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCLDhCQUE4QixHQUFHLEtBQUs7O0FBRWxFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjYwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3Qgc3RyaW5nV2lkdGggPSByZXF1aXJlKCdzdHJpbmctd2lkdGgnKTtcbmNvbnN0IHN0cmlwQW5zaSA9IHJlcXVpcmUoJ3N0cmlwLWFuc2knKTtcbmNvbnN0IGFuc2lTdHlsZXMgPSByZXF1aXJlKCdhbnNpLXN0eWxlcycpO1xuXG5jb25zdCBFU0NBUEVTID0gbmV3IFNldChbXG5cdCdcXHUwMDFCJyxcblx0J1xcdTAwOUInXG5dKTtcblxuY29uc3QgRU5EX0NPREUgPSAzOTtcblxuY29uc3Qgd3JhcEFuc2kgPSBjb2RlID0+IGAke0VTQ0FQRVMudmFsdWVzKCkubmV4dCgpLnZhbHVlfVske2NvZGV9bWA7XG5cbi8vIENhbGN1bGF0ZSB0aGUgbGVuZ3RoIG9mIHdvcmRzIHNwbGl0IG9uICcgJywgaWdub3Jpbmdcbi8vIHRoZSBleHRyYSBjaGFyYWN0ZXJzIGFkZGVkIGJ5IGFuc2kgZXNjYXBlIGNvZGVzXG5jb25zdCB3b3JkTGVuZ3RocyA9IHN0cmluZyA9PiBzdHJpbmcuc3BsaXQoJyAnKS5tYXAoY2hhcmFjdGVyID0+IHN0cmluZ1dpZHRoKGNoYXJhY3RlcikpO1xuXG4vLyBXcmFwIGEgbG9uZyB3b3JkIGFjcm9zcyBtdWx0aXBsZSByb3dzXG4vLyBBbnNpIGVzY2FwZSBjb2RlcyBkbyBub3QgY291bnQgdG93YXJkcyBsZW5ndGhcbmNvbnN0IHdyYXBXb3JkID0gKHJvd3MsIHdvcmQsIGNvbHVtbnMpID0+IHtcblx0Y29uc3QgY2hhcmFjdGVycyA9IFsuLi53b3JkXTtcblxuXHRsZXQgaXNJbnNpZGVFc2NhcGUgPSBmYWxzZTtcblx0bGV0IHZpc2libGUgPSBzdHJpbmdXaWR0aChzdHJpcEFuc2kocm93c1tyb3dzLmxlbmd0aCAtIDFdKSk7XG5cblx0Zm9yIChjb25zdCBbaW5kZXgsIGNoYXJhY3Rlcl0gb2YgY2hhcmFjdGVycy5lbnRyaWVzKCkpIHtcblx0XHRjb25zdCBjaGFyYWN0ZXJMZW5ndGggPSBzdHJpbmdXaWR0aChjaGFyYWN0ZXIpO1xuXG5cdFx0aWYgKHZpc2libGUgKyBjaGFyYWN0ZXJMZW5ndGggPD0gY29sdW1ucykge1xuXHRcdFx0cm93c1tyb3dzLmxlbmd0aCAtIDFdICs9IGNoYXJhY3Rlcjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cm93cy5wdXNoKGNoYXJhY3Rlcik7XG5cdFx0XHR2aXNpYmxlID0gMDtcblx0XHR9XG5cblx0XHRpZiAoRVNDQVBFUy5oYXMoY2hhcmFjdGVyKSkge1xuXHRcdFx0aXNJbnNpZGVFc2NhcGUgPSB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoaXNJbnNpZGVFc2NhcGUgJiYgY2hhcmFjdGVyID09PSAnbScpIHtcblx0XHRcdGlzSW5zaWRlRXNjYXBlID0gZmFsc2U7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRpZiAoaXNJbnNpZGVFc2NhcGUpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZpc2libGUgKz0gY2hhcmFjdGVyTGVuZ3RoO1xuXG5cdFx0aWYgKHZpc2libGUgPT09IGNvbHVtbnMgJiYgaW5kZXggPCBjaGFyYWN0ZXJzLmxlbmd0aCAtIDEpIHtcblx0XHRcdHJvd3MucHVzaCgnJyk7XG5cdFx0XHR2aXNpYmxlID0gMDtcblx0XHR9XG5cdH1cblxuXHQvLyBJdCdzIHBvc3NpYmxlIHRoYXQgdGhlIGxhc3Qgcm93IHdlIGNvcHkgb3ZlciBpcyBvbmx5XG5cdC8vIGFuc2kgZXNjYXBlIGNoYXJhY3RlcnMsIGhhbmRsZSB0aGlzIGVkZ2UtY2FzZVxuXHRpZiAoIXZpc2libGUgJiYgcm93c1tyb3dzLmxlbmd0aCAtIDFdLmxlbmd0aCA+IDAgJiYgcm93cy5sZW5ndGggPiAxKSB7XG5cdFx0cm93c1tyb3dzLmxlbmd0aCAtIDJdICs9IHJvd3MucG9wKCk7XG5cdH1cbn07XG5cbi8vIFRyaW1zIHNwYWNlcyBmcm9tIGEgc3RyaW5nIGlnbm9yaW5nIGludmlzaWJsZSBzZXF1ZW5jZXNcbmNvbnN0IHN0cmluZ1Zpc2libGVUcmltU3BhY2VzUmlnaHQgPSBzdHIgPT4ge1xuXHRjb25zdCB3b3JkcyA9IHN0ci5zcGxpdCgnICcpO1xuXHRsZXQgbGFzdCA9IHdvcmRzLmxlbmd0aDtcblxuXHR3aGlsZSAobGFzdCA+IDApIHtcblx0XHRpZiAoc3RyaW5nV2lkdGgod29yZHNbbGFzdCAtIDFdKSA+IDApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdGxhc3QtLTtcblx0fVxuXG5cdGlmIChsYXN0ID09PSB3b3Jkcy5sZW5ndGgpIHtcblx0XHRyZXR1cm4gc3RyO1xuXHR9XG5cblx0cmV0dXJuIHdvcmRzLnNsaWNlKDAsIGxhc3QpLmpvaW4oJyAnKSArIHdvcmRzLnNsaWNlKGxhc3QpLmpvaW4oJycpO1xufTtcblxuLy8gVGhlIHdyYXAtYW5zaSBtb2R1bGUgY2FuIGJlIGludm9rZWQgaW4gZWl0aGVyICdoYXJkJyBvciAnc29mdCcgd3JhcCBtb2RlXG4vL1xuLy8gJ2hhcmQnIHdpbGwgbmV2ZXIgYWxsb3cgYSBzdHJpbmcgdG8gdGFrZSB1cCBtb3JlIHRoYW4gY29sdW1ucyBjaGFyYWN0ZXJzXG4vL1xuLy8gJ3NvZnQnIGFsbG93cyBsb25nIHdvcmRzIHRvIGV4cGFuZCBwYXN0IHRoZSBjb2x1bW4gbGVuZ3RoXG5jb25zdCBleGVjID0gKHN0cmluZywgY29sdW1ucywgb3B0aW9ucyA9IHt9KSA9PiB7XG5cdGlmIChvcHRpb25zLnRyaW0gIT09IGZhbHNlICYmIHN0cmluZy50cmltKCkgPT09ICcnKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cblx0bGV0IHByZSA9ICcnO1xuXHRsZXQgcmV0ID0gJyc7XG5cdGxldCBlc2NhcGVDb2RlO1xuXG5cdGNvbnN0IGxlbmd0aHMgPSB3b3JkTGVuZ3RocyhzdHJpbmcpO1xuXHRsZXQgcm93cyA9IFsnJ107XG5cblx0Zm9yIChjb25zdCBbaW5kZXgsIHdvcmRdIG9mIHN0cmluZy5zcGxpdCgnICcpLmVudHJpZXMoKSkge1xuXHRcdGlmIChvcHRpb25zLnRyaW0gIT09IGZhbHNlKSB7XG5cdFx0XHRyb3dzW3Jvd3MubGVuZ3RoIC0gMV0gPSByb3dzW3Jvd3MubGVuZ3RoIC0gMV0udHJpbUxlZnQoKTtcblx0XHR9XG5cblx0XHRsZXQgcm93TGVuZ3RoID0gc3RyaW5nV2lkdGgocm93c1tyb3dzLmxlbmd0aCAtIDFdKTtcblxuXHRcdGlmIChpbmRleCAhPT0gMCkge1xuXHRcdFx0aWYgKHJvd0xlbmd0aCA+PSBjb2x1bW5zICYmIChvcHRpb25zLndvcmRXcmFwID09PSBmYWxzZSB8fCBvcHRpb25zLnRyaW0gPT09IGZhbHNlKSkge1xuXHRcdFx0XHQvLyBJZiB3ZSBzdGFydCB3aXRoIGEgbmV3IHdvcmQgYnV0IHRoZSBjdXJyZW50IHJvdyBsZW5ndGggZXF1YWxzIHRoZSBsZW5ndGggb2YgdGhlIGNvbHVtbnMsIGFkZCBhIG5ldyByb3dcblx0XHRcdFx0cm93cy5wdXNoKCcnKTtcblx0XHRcdFx0cm93TGVuZ3RoID0gMDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJvd0xlbmd0aCA+IDAgfHwgb3B0aW9ucy50cmltID09PSBmYWxzZSkge1xuXHRcdFx0XHRyb3dzW3Jvd3MubGVuZ3RoIC0gMV0gKz0gJyAnO1xuXHRcdFx0XHRyb3dMZW5ndGgrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBJbiAnaGFyZCcgd3JhcCBtb2RlLCB0aGUgbGVuZ3RoIG9mIGEgbGluZSBpcyBuZXZlciBhbGxvd2VkIHRvIGV4dGVuZCBwYXN0ICdjb2x1bW5zJ1xuXHRcdGlmIChvcHRpb25zLmhhcmQgJiYgbGVuZ3Roc1tpbmRleF0gPiBjb2x1bW5zKSB7XG5cdFx0XHRjb25zdCByZW1haW5pbmdDb2x1bW5zID0gKGNvbHVtbnMgLSByb3dMZW5ndGgpO1xuXHRcdFx0Y29uc3QgYnJlYWtzU3RhcnRpbmdUaGlzTGluZSA9IDEgKyBNYXRoLmZsb29yKChsZW5ndGhzW2luZGV4XSAtIHJlbWFpbmluZ0NvbHVtbnMgLSAxKSAvIGNvbHVtbnMpO1xuXHRcdFx0Y29uc3QgYnJlYWtzU3RhcnRpbmdOZXh0TGluZSA9IE1hdGguZmxvb3IoKGxlbmd0aHNbaW5kZXhdIC0gMSkgLyBjb2x1bW5zKTtcblx0XHRcdGlmIChicmVha3NTdGFydGluZ05leHRMaW5lIDwgYnJlYWtzU3RhcnRpbmdUaGlzTGluZSkge1xuXHRcdFx0XHRyb3dzLnB1c2goJycpO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwV29yZChyb3dzLCB3b3JkLCBjb2x1bW5zKTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGlmIChyb3dMZW5ndGggKyBsZW5ndGhzW2luZGV4XSA+IGNvbHVtbnMgJiYgcm93TGVuZ3RoID4gMCAmJiBsZW5ndGhzW2luZGV4XSA+IDApIHtcblx0XHRcdGlmIChvcHRpb25zLndvcmRXcmFwID09PSBmYWxzZSAmJiByb3dMZW5ndGggPCBjb2x1bW5zKSB7XG5cdFx0XHRcdHdyYXBXb3JkKHJvd3MsIHdvcmQsIGNvbHVtbnMpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0cm93cy5wdXNoKCcnKTtcblx0XHR9XG5cblx0XHRpZiAocm93TGVuZ3RoICsgbGVuZ3Roc1tpbmRleF0gPiBjb2x1bW5zICYmIG9wdGlvbnMud29yZFdyYXAgPT09IGZhbHNlKSB7XG5cdFx0XHR3cmFwV29yZChyb3dzLCB3b3JkLCBjb2x1bW5zKTtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHJvd3Nbcm93cy5sZW5ndGggLSAxXSArPSB3b3JkO1xuXHR9XG5cblx0aWYgKG9wdGlvbnMudHJpbSAhPT0gZmFsc2UpIHtcblx0XHRyb3dzID0gcm93cy5tYXAoc3RyaW5nVmlzaWJsZVRyaW1TcGFjZXNSaWdodCk7XG5cdH1cblxuXHRwcmUgPSByb3dzLmpvaW4oJ1xcbicpO1xuXG5cdGZvciAoY29uc3QgW2luZGV4LCBjaGFyYWN0ZXJdIG9mIFsuLi5wcmVdLmVudHJpZXMoKSkge1xuXHRcdHJldCArPSBjaGFyYWN0ZXI7XG5cblx0XHRpZiAoRVNDQVBFUy5oYXMoY2hhcmFjdGVyKSkge1xuXHRcdFx0Y29uc3QgY29kZSA9IHBhcnNlRmxvYXQoL1xcZFtebV0qLy5leGVjKHByZS5zbGljZShpbmRleCwgaW5kZXggKyA0KSkpO1xuXHRcdFx0ZXNjYXBlQ29kZSA9IGNvZGUgPT09IEVORF9DT0RFID8gbnVsbCA6IGNvZGU7XG5cdFx0fVxuXG5cdFx0Y29uc3QgY29kZSA9IGFuc2lTdHlsZXMuY29kZXMuZ2V0KE51bWJlcihlc2NhcGVDb2RlKSk7XG5cblx0XHRpZiAoZXNjYXBlQ29kZSAmJiBjb2RlKSB7XG5cdFx0XHRpZiAocHJlW2luZGV4ICsgMV0gPT09ICdcXG4nKSB7XG5cdFx0XHRcdHJldCArPSB3cmFwQW5zaShjb2RlKTtcblx0XHRcdH0gZWxzZSBpZiAoY2hhcmFjdGVyID09PSAnXFxuJykge1xuXHRcdFx0XHRyZXQgKz0gd3JhcEFuc2koZXNjYXBlQ29kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cbi8vIEZvciBlYWNoIG5ld2xpbmUsIGludm9rZSB0aGUgbWV0aG9kIHNlcGFyYXRlbHlcbm1vZHVsZS5leHBvcnRzID0gKHN0cmluZywgY29sdW1ucywgb3B0aW9ucykgPT4ge1xuXHRyZXR1cm4gU3RyaW5nKHN0cmluZylcblx0XHQubm9ybWFsaXplKClcblx0XHQucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKVxuXHRcdC5zcGxpdCgnXFxuJylcblx0XHQubWFwKGxpbmUgPT4gZXhlYyhsaW5lLCBjb2x1bW5zLCBvcHRpb25zKSlcblx0XHQuam9pbignXFxuJyk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///60\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.completion = void 0;\nconst command_1 = __webpack_require__(20);\nconst templates = __webpack_require__(62);\nconst is_promise_1 = __webpack_require__(5);\nconst parse_command_1 = __webpack_require__(11);\nconst path = __webpack_require__(0);\nconst common_types_1 = __webpack_require__(1);\n// add bash completions to your\n//  yargs-powered applications.\nfunction completion(yargs, usage, command) {\n    const self = {\n        completionKey: 'get-yargs-completions'\n    };\n    let aliases;\n    self.setParsed = function setParsed(parsed) {\n        aliases = parsed.aliases;\n    };\n    const zshShell = (process.env.SHELL && process.env.SHELL.indexOf('zsh') !== -1) ||\n        (process.env.ZSH_NAME && process.env.ZSH_NAME.indexOf('zsh') !== -1);\n    // get a list of completion commands.\n    // 'args' is the array of strings from the line to be completed\n    self.getCompletion = function getCompletion(args, done) {\n        const completions = [];\n        const current = args.length ? args[args.length - 1] : '';\n        const argv = yargs.parse(args, true);\n        const parentCommands = yargs.getContext().commands;\n        // a custom completion function can be provided\n        // to completion().\n        function runCompletionFunction(argv) {\n            common_types_1.assertNotStrictEqual(completionFunction, null);\n            if (isSyncCompletionFunction(completionFunction)) {\n                const result = completionFunction(current, argv);\n                // promise based completion function.\n                if (is_promise_1.isPromise(result)) {\n                    return result.then((list) => {\n                        process.nextTick(() => { done(list); });\n                    }).catch((err) => {\n                        process.nextTick(() => { throw err; });\n                    });\n                }\n                // synchronous completion function.\n                return done(result);\n            }\n            else {\n                // asynchronous completion function\n                return completionFunction(current, argv, (completions) => {\n                    done(completions);\n                });\n            }\n        }\n        if (completionFunction) {\n            return is_promise_1.isPromise(argv) ? argv.then(runCompletionFunction) : runCompletionFunction(argv);\n        }\n        const handlers = command.getCommandHandlers();\n        for (let i = 0, ii = args.length; i < ii; ++i) {\n            if (handlers[args[i]] && handlers[args[i]].builder) {\n                const builder = handlers[args[i]].builder;\n                if (command_1.isCommandBuilderCallback(builder)) {\n                    const y = yargs.reset();\n                    builder(y);\n                    return y.argv;\n                }\n            }\n        }\n        if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current) {\n            usage.getCommands().forEach((usageCommand) => {\n                const commandName = parse_command_1.parseCommand(usageCommand[0]).cmd;\n                if (args.indexOf(commandName) === -1) {\n                    if (!zshShell) {\n                        completions.push(commandName);\n                    }\n                    else {\n                        const desc = usageCommand[1] || '';\n                        completions.push(commandName.replace(/:/g, '\\\\:') + ':' + desc);\n                    }\n                }\n            });\n        }\n        if (current.match(/^-/) || (current === '' && completions.length === 0)) {\n            const descs = usage.getDescriptions();\n            const options = yargs.getOptions();\n            Object.keys(options.key).forEach((key) => {\n                const negable = !!options.configuration['boolean-negation'] && options.boolean.includes(key);\n                // If the key and its aliases aren't in 'args', add the key to 'completions'\n                let keyAndAliases = [key].concat(aliases[key] || []);\n                if (negable)\n                    keyAndAliases = keyAndAliases.concat(keyAndAliases.map(key => `no-${key}`));\n                function completeOptionKey(key) {\n                    const notInArgs = keyAndAliases.every(val => args.indexOf(`--${val}`) === -1);\n                    if (notInArgs) {\n                        const startsByTwoDashes = (s) => /^--/.test(s);\n                        const isShortOption = (s) => /^[^0-9]$/.test(s);\n                        const dashes = !startsByTwoDashes(current) && isShortOption(key) ? '-' : '--';\n                        if (!zshShell) {\n                            completions.push(dashes + key);\n                        }\n                        else {\n                            const desc = descs[key] || '';\n                            completions.push(dashes + `${key.replace(/:/g, '\\\\:')}:${desc.replace('__yargsString__:', '')}`);\n                        }\n                    }\n                }\n                completeOptionKey(key);\n                if (negable && !!options.default[key])\n                    completeOptionKey(`no-${key}`);\n            });\n        }\n        done(completions);\n    };\n    // generate the completion script to add to your .bashrc.\n    self.generateCompletionScript = function generateCompletionScript($0, cmd) {\n        let script = zshShell ? templates.completionZshTemplate : templates.completionShTemplate;\n        const name = path.basename($0);\n        // add ./to applications not yet installed as bin.\n        if ($0.match(/\\.js$/))\n            $0 = `./${$0}`;\n        script = script.replace(/{{app_name}}/g, name);\n        script = script.replace(/{{completion_command}}/g, cmd);\n        return script.replace(/{{app_path}}/g, $0);\n    };\n    // register a function to perform your own custom\n    // completions., this function can be either\n    // synchrnous or asynchronous.\n    let completionFunction = null;\n    self.registerFunction = (fn) => {\n        completionFunction = fn;\n    };\n    return self;\n}\nexports.completion = completion;\nfunction isSyncCompletionFunction(completionFunction) {\n    return completionFunction.length < 3;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliL2NvbXBsZXRpb24uanM/Mzk0MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsRUFBVztBQUNyQyxrQkFBa0IsbUJBQU8sQ0FBQyxFQUF3QjtBQUNsRCxxQkFBcUIsbUJBQU8sQ0FBQyxDQUFjO0FBQzNDLHdCQUF3QixtQkFBTyxDQUFDLEVBQWlCO0FBQ2pELGFBQWEsbUJBQU8sQ0FBQyxDQUFNO0FBQzNCLHVCQUF1QixtQkFBTyxDQUFDLENBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVksRUFBRTtBQUM5RCxxQkFBcUI7QUFDckIsZ0RBQWdELFdBQVcsRUFBRTtBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLElBQUk7QUFDNUY7QUFDQSxtRkFBbUYsSUFBSTtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQseUJBQXlCLEdBQUcscUNBQXFDO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsSUFBSTtBQUNoRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLEdBQUc7QUFDekIsbUNBQW1DLFVBQVU7QUFDN0MsbUNBQW1DLG9CQUFvQjtBQUN2RCxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjYxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbXBsZXRpb24gPSB2b2lkIDA7XG5jb25zdCBjb21tYW5kXzEgPSByZXF1aXJlKFwiLi9jb21tYW5kXCIpO1xuY29uc3QgdGVtcGxhdGVzID0gcmVxdWlyZShcIi4vY29tcGxldGlvbi10ZW1wbGF0ZXNcIik7XG5jb25zdCBpc19wcm9taXNlXzEgPSByZXF1aXJlKFwiLi9pcy1wcm9taXNlXCIpO1xuY29uc3QgcGFyc2VfY29tbWFuZF8xID0gcmVxdWlyZShcIi4vcGFyc2UtY29tbWFuZFwiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IGNvbW1vbl90eXBlc18xID0gcmVxdWlyZShcIi4vY29tbW9uLXR5cGVzXCIpO1xuLy8gYWRkIGJhc2ggY29tcGxldGlvbnMgdG8geW91clxuLy8gIHlhcmdzLXBvd2VyZWQgYXBwbGljYXRpb25zLlxuZnVuY3Rpb24gY29tcGxldGlvbih5YXJncywgdXNhZ2UsIGNvbW1hbmQpIHtcbiAgICBjb25zdCBzZWxmID0ge1xuICAgICAgICBjb21wbGV0aW9uS2V5OiAnZ2V0LXlhcmdzLWNvbXBsZXRpb25zJ1xuICAgIH07XG4gICAgbGV0IGFsaWFzZXM7XG4gICAgc2VsZi5zZXRQYXJzZWQgPSBmdW5jdGlvbiBzZXRQYXJzZWQocGFyc2VkKSB7XG4gICAgICAgIGFsaWFzZXMgPSBwYXJzZWQuYWxpYXNlcztcbiAgICB9O1xuICAgIGNvbnN0IHpzaFNoZWxsID0gKHByb2Nlc3MuZW52LlNIRUxMICYmIHByb2Nlc3MuZW52LlNIRUxMLmluZGV4T2YoJ3pzaCcpICE9PSAtMSkgfHxcbiAgICAgICAgKHByb2Nlc3MuZW52LlpTSF9OQU1FICYmIHByb2Nlc3MuZW52LlpTSF9OQU1FLmluZGV4T2YoJ3pzaCcpICE9PSAtMSk7XG4gICAgLy8gZ2V0IGEgbGlzdCBvZiBjb21wbGV0aW9uIGNvbW1hbmRzLlxuICAgIC8vICdhcmdzJyBpcyB0aGUgYXJyYXkgb2Ygc3RyaW5ncyBmcm9tIHRoZSBsaW5lIHRvIGJlIGNvbXBsZXRlZFxuICAgIHNlbGYuZ2V0Q29tcGxldGlvbiA9IGZ1bmN0aW9uIGdldENvbXBsZXRpb24oYXJncywgZG9uZSkge1xuICAgICAgICBjb25zdCBjb21wbGV0aW9ucyA9IFtdO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gYXJncy5sZW5ndGggPyBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gOiAnJztcbiAgICAgICAgY29uc3QgYXJndiA9IHlhcmdzLnBhcnNlKGFyZ3MsIHRydWUpO1xuICAgICAgICBjb25zdCBwYXJlbnRDb21tYW5kcyA9IHlhcmdzLmdldENvbnRleHQoKS5jb21tYW5kcztcbiAgICAgICAgLy8gYSBjdXN0b20gY29tcGxldGlvbiBmdW5jdGlvbiBjYW4gYmUgcHJvdmlkZWRcbiAgICAgICAgLy8gdG8gY29tcGxldGlvbigpLlxuICAgICAgICBmdW5jdGlvbiBydW5Db21wbGV0aW9uRnVuY3Rpb24oYXJndikge1xuICAgICAgICAgICAgY29tbW9uX3R5cGVzXzEuYXNzZXJ0Tm90U3RyaWN0RXF1YWwoY29tcGxldGlvbkZ1bmN0aW9uLCBudWxsKTtcbiAgICAgICAgICAgIGlmIChpc1N5bmNDb21wbGV0aW9uRnVuY3Rpb24oY29tcGxldGlvbkZ1bmN0aW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBsZXRpb25GdW5jdGlvbihjdXJyZW50LCBhcmd2KTtcbiAgICAgICAgICAgICAgICAvLyBwcm9taXNlIGJhc2VkIGNvbXBsZXRpb24gZnVuY3Rpb24uXG4gICAgICAgICAgICAgICAgaWYgKGlzX3Byb21pc2VfMS5pc1Byb21pc2UocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKGxpc3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4geyBkb25lKGxpc3QpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7IHRocm93IGVycjsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzeW5jaHJvbm91cyBjb21wbGV0aW9uIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgIHJldHVybiBkb25lKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhc3luY2hyb25vdXMgY29tcGxldGlvbiBmdW5jdGlvblxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wbGV0aW9uRnVuY3Rpb24oY3VycmVudCwgYXJndiwgKGNvbXBsZXRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGRvbmUoY29tcGxldGlvbnMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wbGV0aW9uRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBpc19wcm9taXNlXzEuaXNQcm9taXNlKGFyZ3YpID8gYXJndi50aGVuKHJ1bkNvbXBsZXRpb25GdW5jdGlvbikgOiBydW5Db21wbGV0aW9uRnVuY3Rpb24oYXJndik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBjb21tYW5kLmdldENvbW1hbmRIYW5kbGVycygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBhcmdzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChoYW5kbGVyc1thcmdzW2ldXSAmJiBoYW5kbGVyc1thcmdzW2ldXS5idWlsZGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVpbGRlciA9IGhhbmRsZXJzW2FyZ3NbaV1dLmJ1aWxkZXI7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1hbmRfMS5pc0NvbW1hbmRCdWlsZGVyQ2FsbGJhY2soYnVpbGRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeSA9IHlhcmdzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkZXIoeSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5LmFyZ3Y7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY3VycmVudC5tYXRjaCgvXi0vKSAmJiBwYXJlbnRDb21tYW5kc1twYXJlbnRDb21tYW5kcy5sZW5ndGggLSAxXSAhPT0gY3VycmVudCkge1xuICAgICAgICAgICAgdXNhZ2UuZ2V0Q29tbWFuZHMoKS5mb3JFYWNoKCh1c2FnZUNvbW1hbmQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tYW5kTmFtZSA9IHBhcnNlX2NvbW1hbmRfMS5wYXJzZUNvbW1hbmQodXNhZ2VDb21tYW5kWzBdKS5jbWQ7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3MuaW5kZXhPZihjb21tYW5kTmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghenNoU2hlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25zLnB1c2goY29tbWFuZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzYyA9IHVzYWdlQ29tbWFuZFsxXSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25zLnB1c2goY29tbWFuZE5hbWUucmVwbGFjZSgvOi9nLCAnXFxcXDonKSArICc6JyArIGRlc2MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQubWF0Y2goL14tLykgfHwgKGN1cnJlbnQgPT09ICcnICYmIGNvbXBsZXRpb25zLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NzID0gdXNhZ2UuZ2V0RGVzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0geWFyZ3MuZ2V0T3B0aW9ucygpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMob3B0aW9ucy5rZXkpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5lZ2FibGUgPSAhIW9wdGlvbnMuY29uZmlndXJhdGlvblsnYm9vbGVhbi1uZWdhdGlvbiddICYmIG9wdGlvbnMuYm9vbGVhbi5pbmNsdWRlcyhrZXkpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBrZXkgYW5kIGl0cyBhbGlhc2VzIGFyZW4ndCBpbiAnYXJncycsIGFkZCB0aGUga2V5IHRvICdjb21wbGV0aW9ucydcbiAgICAgICAgICAgICAgICBsZXQga2V5QW5kQWxpYXNlcyA9IFtrZXldLmNvbmNhdChhbGlhc2VzW2tleV0gfHwgW10pO1xuICAgICAgICAgICAgICAgIGlmIChuZWdhYmxlKVxuICAgICAgICAgICAgICAgICAgICBrZXlBbmRBbGlhc2VzID0ga2V5QW5kQWxpYXNlcy5jb25jYXQoa2V5QW5kQWxpYXNlcy5tYXAoa2V5ID0+IGBuby0ke2tleX1gKSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY29tcGxldGVPcHRpb25LZXkoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vdEluQXJncyA9IGtleUFuZEFsaWFzZXMuZXZlcnkodmFsID0+IGFyZ3MuaW5kZXhPZihgLS0ke3ZhbH1gKSA9PT0gLTEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobm90SW5BcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFydHNCeVR3b0Rhc2hlcyA9IChzKSA9PiAvXi0tLy50ZXN0KHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNTaG9ydE9wdGlvbiA9IChzKSA9PiAvXlteMC05XSQvLnRlc3Qocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXNoZXMgPSAhc3RhcnRzQnlUd29EYXNoZXMoY3VycmVudCkgJiYgaXNTaG9ydE9wdGlvbihrZXkpID8gJy0nIDogJy0tJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghenNoU2hlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9ucy5wdXNoKGRhc2hlcyArIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXNjID0gZGVzY3Nba2V5XSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wbGV0aW9ucy5wdXNoKGRhc2hlcyArIGAke2tleS5yZXBsYWNlKC86L2csICdcXFxcOicpfToke2Rlc2MucmVwbGFjZSgnX195YXJnc1N0cmluZ19fOicsICcnKX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wbGV0ZU9wdGlvbktleShrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChuZWdhYmxlICYmICEhb3B0aW9ucy5kZWZhdWx0W2tleV0pXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlT3B0aW9uS2V5KGBuby0ke2tleX1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGRvbmUoY29tcGxldGlvbnMpO1xuICAgIH07XG4gICAgLy8gZ2VuZXJhdGUgdGhlIGNvbXBsZXRpb24gc2NyaXB0IHRvIGFkZCB0byB5b3VyIC5iYXNocmMuXG4gICAgc2VsZi5nZW5lcmF0ZUNvbXBsZXRpb25TY3JpcHQgPSBmdW5jdGlvbiBnZW5lcmF0ZUNvbXBsZXRpb25TY3JpcHQoJDAsIGNtZCkge1xuICAgICAgICBsZXQgc2NyaXB0ID0genNoU2hlbGwgPyB0ZW1wbGF0ZXMuY29tcGxldGlvblpzaFRlbXBsYXRlIDogdGVtcGxhdGVzLmNvbXBsZXRpb25TaFRlbXBsYXRlO1xuICAgICAgICBjb25zdCBuYW1lID0gcGF0aC5iYXNlbmFtZSgkMCk7XG4gICAgICAgIC8vIGFkZCAuL3RvIGFwcGxpY2F0aW9ucyBub3QgeWV0IGluc3RhbGxlZCBhcyBiaW4uXG4gICAgICAgIGlmICgkMC5tYXRjaCgvXFwuanMkLykpXG4gICAgICAgICAgICAkMCA9IGAuLyR7JDB9YDtcbiAgICAgICAgc2NyaXB0ID0gc2NyaXB0LnJlcGxhY2UoL3t7YXBwX25hbWV9fS9nLCBuYW1lKTtcbiAgICAgICAgc2NyaXB0ID0gc2NyaXB0LnJlcGxhY2UoL3t7Y29tcGxldGlvbl9jb21tYW5kfX0vZywgY21kKTtcbiAgICAgICAgcmV0dXJuIHNjcmlwdC5yZXBsYWNlKC97e2FwcF9wYXRofX0vZywgJDApO1xuICAgIH07XG4gICAgLy8gcmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBwZXJmb3JtIHlvdXIgb3duIGN1c3RvbVxuICAgIC8vIGNvbXBsZXRpb25zLiwgdGhpcyBmdW5jdGlvbiBjYW4gYmUgZWl0aGVyXG4gICAgLy8gc3luY2hybm91cyBvciBhc3luY2hyb25vdXMuXG4gICAgbGV0IGNvbXBsZXRpb25GdW5jdGlvbiA9IG51bGw7XG4gICAgc2VsZi5yZWdpc3RlckZ1bmN0aW9uID0gKGZuKSA9PiB7XG4gICAgICAgIGNvbXBsZXRpb25GdW5jdGlvbiA9IGZuO1xuICAgIH07XG4gICAgcmV0dXJuIHNlbGY7XG59XG5leHBvcnRzLmNvbXBsZXRpb24gPSBjb21wbGV0aW9uO1xuZnVuY3Rpb24gaXNTeW5jQ29tcGxldGlvbkZ1bmN0aW9uKGNvbXBsZXRpb25GdW5jdGlvbikge1xuICAgIHJldHVybiBjb21wbGV0aW9uRnVuY3Rpb24ubGVuZ3RoIDwgMztcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///61\n")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.completionZshTemplate = exports.completionShTemplate = void 0;\nexports.completionShTemplate = `###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc\n#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.\n#\n_yargs_completions()\n{\n    local cur_word args type_list\n\n    cur_word="\\${COMP_WORDS[COMP_CWORD]}"\n    args=("\\${COMP_WORDS[@]}")\n\n    # ask yargs to generate completions.\n    type_list=$({{app_path}} --get-yargs-completions "\\${args[@]}")\n\n    COMPREPLY=( $(compgen -W "\\${type_list}" -- \\${cur_word}) )\n\n    # if no match was found, fall back to filename completion\n    if [ \\${#COMPREPLY[@]} -eq 0 ]; then\n      COMPREPLY=()\n    fi\n\n    return 0\n}\ncomplete -o default -F _yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n`;\nexports.completionZshTemplate = `###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc\n#    or {{app_path}} {{completion_command}} >> ~/.zsh_profile on OSX.\n#\n_{{app_name}}_yargs_completions()\n{\n  local reply\n  local si=$IFS\n  IFS=$\'\\n\' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\\${words[@]}"))\n  IFS=$si\n  _describe \'values\' reply\n}\ncompdef _{{app_name}}_yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliL2NvbXBsZXRpb24tdGVtcGxhdGVzLmpzP2Q3NGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVLEdBQUcsb0JBQW9CO0FBQ25ELFVBQVUsVUFBVSxHQUFHLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsdUJBQXVCO0FBQ3hDLGNBQWMsY0FBYzs7QUFFNUI7QUFDQSxrQkFBa0IsVUFBVSw2QkFBNkIsUUFBUTs7QUFFakUsaUNBQWlDLFVBQVUsUUFBUSxTQUFTOztBQUU1RDtBQUNBLFlBQVksY0FBYyxTQUFTO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxVQUFVLFVBQVU7QUFDcEI7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVSxHQUFHLG9CQUFvQjtBQUNuRCxVQUFVLFVBQVUsR0FBRyxvQkFBb0I7QUFDM0M7QUFDQSxHQUFHLFVBQVU7QUFDYjtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsVUFBVSw2QkFBNkIsU0FBUztBQUM1STtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVUscUJBQXFCO0FBQzFDLFVBQVUsVUFBVTtBQUNwQiIsImZpbGUiOiI2Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb21wbGV0aW9uWnNoVGVtcGxhdGUgPSBleHBvcnRzLmNvbXBsZXRpb25TaFRlbXBsYXRlID0gdm9pZCAwO1xuZXhwb3J0cy5jb21wbGV0aW9uU2hUZW1wbGF0ZSA9IGAjIyMtYmVnaW4te3thcHBfbmFtZX19LWNvbXBsZXRpb25zLSMjI1xuI1xuIyB5YXJncyBjb21tYW5kIGNvbXBsZXRpb24gc2NyaXB0XG4jXG4jIEluc3RhbGxhdGlvbjoge3thcHBfcGF0aH19IHt7Y29tcGxldGlvbl9jb21tYW5kfX0gPj4gfi8uYmFzaHJjXG4jICAgIG9yIHt7YXBwX3BhdGh9fSB7e2NvbXBsZXRpb25fY29tbWFuZH19ID4+IH4vLmJhc2hfcHJvZmlsZSBvbiBPU1guXG4jXG5feWFyZ3NfY29tcGxldGlvbnMoKVxue1xuICAgIGxvY2FsIGN1cl93b3JkIGFyZ3MgdHlwZV9saXN0XG5cbiAgICBjdXJfd29yZD1cIlxcJHtDT01QX1dPUkRTW0NPTVBfQ1dPUkRdfVwiXG4gICAgYXJncz0oXCJcXCR7Q09NUF9XT1JEU1tAXX1cIilcblxuICAgICMgYXNrIHlhcmdzIHRvIGdlbmVyYXRlIGNvbXBsZXRpb25zLlxuICAgIHR5cGVfbGlzdD0kKHt7YXBwX3BhdGh9fSAtLWdldC15YXJncy1jb21wbGV0aW9ucyBcIlxcJHthcmdzW0BdfVwiKVxuXG4gICAgQ09NUFJFUExZPSggJChjb21wZ2VuIC1XIFwiXFwke3R5cGVfbGlzdH1cIiAtLSBcXCR7Y3VyX3dvcmR9KSApXG5cbiAgICAjIGlmIG5vIG1hdGNoIHdhcyBmb3VuZCwgZmFsbCBiYWNrIHRvIGZpbGVuYW1lIGNvbXBsZXRpb25cbiAgICBpZiBbIFxcJHsjQ09NUFJFUExZW0BdfSAtZXEgMCBdOyB0aGVuXG4gICAgICBDT01QUkVQTFk9KClcbiAgICBmaVxuXG4gICAgcmV0dXJuIDBcbn1cbmNvbXBsZXRlIC1vIGRlZmF1bHQgLUYgX3lhcmdzX2NvbXBsZXRpb25zIHt7YXBwX25hbWV9fVxuIyMjLWVuZC17e2FwcF9uYW1lfX0tY29tcGxldGlvbnMtIyMjXG5gO1xuZXhwb3J0cy5jb21wbGV0aW9uWnNoVGVtcGxhdGUgPSBgIyMjLWJlZ2luLXt7YXBwX25hbWV9fS1jb21wbGV0aW9ucy0jIyNcbiNcbiMgeWFyZ3MgY29tbWFuZCBjb21wbGV0aW9uIHNjcmlwdFxuI1xuIyBJbnN0YWxsYXRpb246IHt7YXBwX3BhdGh9fSB7e2NvbXBsZXRpb25fY29tbWFuZH19ID4+IH4vLnpzaHJjXG4jICAgIG9yIHt7YXBwX3BhdGh9fSB7e2NvbXBsZXRpb25fY29tbWFuZH19ID4+IH4vLnpzaF9wcm9maWxlIG9uIE9TWC5cbiNcbl97e2FwcF9uYW1lfX1feWFyZ3NfY29tcGxldGlvbnMoKVxue1xuICBsb2NhbCByZXBseVxuICBsb2NhbCBzaT0kSUZTXG4gIElGUz0kJ1xcbicgcmVwbHk9KCQoQ09NUF9DV09SRD1cIiQoKENVUlJFTlQtMSkpXCIgQ09NUF9MSU5FPVwiJEJVRkZFUlwiIENPTVBfUE9JTlQ9XCIkQ1VSU09SXCIge3thcHBfcGF0aH19IC0tZ2V0LXlhcmdzLWNvbXBsZXRpb25zIFwiXFwke3dvcmRzW0BdfVwiKSlcbiAgSUZTPSRzaVxuICBfZGVzY3JpYmUgJ3ZhbHVlcycgcmVwbHlcbn1cbmNvbXBkZWYgX3t7YXBwX25hbWV9fV95YXJnc19jb21wbGV0aW9ucyB7e2FwcF9uYW1lfX1cbiMjIy1lbmQte3thcHBfbmFtZX19LWNvbXBsZXRpb25zLSMjI1xuYDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///62\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validation = void 0;\nconst argsert_1 = __webpack_require__(10);\nconst common_types_1 = __webpack_require__(1);\nconst levenshtein_1 = __webpack_require__(64);\nconst obj_filter_1 = __webpack_require__(13);\nconst specialKeys = ['$0', '--', '_'];\n// validation-type-stuff, missing params,\n// bad implications, custom checks.\nfunction validation(yargs, usage, y18n) {\n    const __ = y18n.__;\n    const __n = y18n.__n;\n    const self = {};\n    // validate appropriate # of non-option\n    // arguments were provided, i.e., '_'.\n    self.nonOptionCount = function nonOptionCount(argv) {\n        const demandedCommands = yargs.getDemandedCommands();\n        // don't count currently executing commands\n        const _s = argv._.length - yargs.getContext().commands.length;\n        if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n            if (_s < demandedCommands._.min) {\n                if (demandedCommands._.minMsg !== undefined) {\n                    usage.fail(\n                    // replace $0 with observed, $1 with expected.\n                    demandedCommands._.minMsg\n                        ? demandedCommands._.minMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.min.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s, demandedCommands._.min));\n                }\n            }\n            else if (_s > demandedCommands._.max) {\n                if (demandedCommands._.maxMsg !== undefined) {\n                    usage.fail(\n                    // replace $0 with observed, $1 with expected.\n                    demandedCommands._.maxMsg\n                        ? demandedCommands._.maxMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.max.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s, demandedCommands._.max));\n                }\n            }\n        }\n    };\n    // validate the appropriate # of <required>\n    // positional arguments were provided:\n    self.positionalCount = function positionalCount(required, observed) {\n        if (observed < required) {\n            usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed, required));\n        }\n    };\n    // make sure all the required arguments are present.\n    self.requiredArguments = function requiredArguments(argv) {\n        const demandedOptions = yargs.getDemandedOptions();\n        let missing = null;\n        for (const key of Object.keys(demandedOptions)) {\n            if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === 'undefined') {\n                missing = missing || {};\n                missing[key] = demandedOptions[key];\n            }\n        }\n        if (missing) {\n            const customMsgs = [];\n            for (const key of Object.keys(missing)) {\n                const msg = missing[key];\n                if (msg && customMsgs.indexOf(msg) < 0) {\n                    customMsgs.push(msg);\n                }\n            }\n            const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n            usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n        }\n    };\n    // check for unknown arguments (strict-mode).\n    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand) {\n        const commandKeys = yargs.getCommandInstance().getCommands();\n        const unknown = [];\n        const currentContext = yargs.getContext();\n        Object.keys(argv).forEach((key) => {\n            if (specialKeys.indexOf(key) === -1 &&\n                !Object.prototype.hasOwnProperty.call(positionalMap, key) &&\n                !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) &&\n                !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n                unknown.push(key);\n            }\n        });\n        if ((currentContext.commands.length > 0) || (commandKeys.length > 0) || isDefaultCommand) {\n            argv._.slice(currentContext.commands.length).forEach((key) => {\n                if (commandKeys.indexOf(key) === -1) {\n                    unknown.push(key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n        }\n    };\n    self.unknownCommands = function unknownCommands(argv) {\n        const commandKeys = yargs.getCommandInstance().getCommands();\n        const unknown = [];\n        const currentContext = yargs.getContext();\n        if ((currentContext.commands.length > 0) || (commandKeys.length > 0)) {\n            argv._.slice(currentContext.commands.length).forEach((key) => {\n                if (commandKeys.indexOf(key) === -1) {\n                    unknown.push(key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    // check for a key that is not an alias, or for which every alias is new,\n    // implying that it was invented by the parser, e.g., during camelization\n    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {\n            return false;\n        }\n        const newAliases = yargs.parsed.newAliases;\n        for (const a of [key, ...aliases[key]]) {\n            if (!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]) {\n                return true;\n            }\n        }\n        return false;\n    };\n    // validate arguments limited to enumerated choices\n    self.limitedChoices = function limitedChoices(argv) {\n        const options = yargs.getOptions();\n        const invalid = {};\n        if (!Object.keys(options.choices).length)\n            return;\n        Object.keys(argv).forEach((key) => {\n            if (specialKeys.indexOf(key) === -1 &&\n                Object.prototype.hasOwnProperty.call(options.choices, key)) {\n                [].concat(argv[key]).forEach((value) => {\n                    // TODO case-insensitive configurability\n                    if (options.choices[key].indexOf(value) === -1 &&\n                        value !== undefined) {\n                        invalid[key] = (invalid[key] || []).concat(value);\n                    }\n                });\n            }\n        });\n        const invalidKeys = Object.keys(invalid);\n        if (!invalidKeys.length)\n            return;\n        let msg = __('Invalid values:');\n        invalidKeys.forEach((key) => {\n            msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n        });\n        usage.fail(msg);\n    };\n    // custom checks, added using the `check` option on yargs.\n    let checks = [];\n    self.check = function check(f, global) {\n        checks.push({\n            func: f,\n            global\n        });\n    };\n    self.customChecks = function customChecks(argv, aliases) {\n        for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n            const func = f.func;\n            let result = null;\n            try {\n                result = func(argv, aliases);\n            }\n            catch (err) {\n                usage.fail(err.message ? err.message : err, err);\n                continue;\n            }\n            if (!result) {\n                usage.fail(__('Argument check failed: %s', func.toString()));\n            }\n            else if (typeof result === 'string' || result instanceof Error) {\n                usage.fail(result.toString(), result);\n            }\n        }\n    };\n    // check implications, argument foo implies => argument bar.\n    let implied = {};\n    self.implies = function implies(key, value) {\n        argsert_1.argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach((k) => {\n                self.implies(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!implied[key]) {\n                implied[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach((i) => self.implies(key, i));\n            }\n            else {\n                common_types_1.assertNotStrictEqual(value, undefined);\n                implied[key].push(value);\n            }\n        }\n    };\n    self.getImplied = function getImplied() {\n        return implied;\n    };\n    function keyExists(argv, val) {\n        // convert string '1' to number 1\n        const num = Number(val);\n        val = isNaN(num) ? val : num;\n        if (typeof val === 'number') {\n            // check length of argv._\n            val = argv._.length >= val;\n        }\n        else if (val.match(/^--no-.+/)) {\n            // check if key/value doesn't exist\n            val = val.match(/^--no-(.+)/)[1];\n            val = !argv[val];\n        }\n        else {\n            // check if key/value exists\n            val = argv[val];\n        }\n        return val;\n    }\n    self.implications = function implications(argv) {\n        const implyFail = [];\n        Object.keys(implied).forEach((key) => {\n            const origKey = key;\n            (implied[key] || []).forEach((value) => {\n                let key = origKey;\n                const origValue = value;\n                key = keyExists(argv, key);\n                value = keyExists(argv, value);\n                if (key && !value) {\n                    implyFail.push(` ${origKey} -> ${origValue}`);\n                }\n            });\n        });\n        if (implyFail.length) {\n            let msg = `${__('Implications failed:')}\\n`;\n            implyFail.forEach((value) => {\n                msg += (value);\n            });\n            usage.fail(msg);\n        }\n    };\n    let conflicting = {};\n    self.conflicts = function conflicts(key, value) {\n        argsert_1.argsert('<string|object> [array|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach((k) => {\n                self.conflicts(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!conflicting[key]) {\n                conflicting[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach((i) => self.conflicts(key, i));\n            }\n            else {\n                conflicting[key].push(value);\n            }\n        }\n    };\n    self.getConflicting = () => conflicting;\n    self.conflicting = function conflictingFn(argv) {\n        Object.keys(argv).forEach((key) => {\n            if (conflicting[key]) {\n                conflicting[key].forEach((value) => {\n                    // we default keys to 'undefined' that have been configured, we should not\n                    // apply conflicting check unless they are a value other than 'undefined'.\n                    if (value && argv[key] !== undefined && argv[value] !== undefined) {\n                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n                    }\n                });\n            }\n        });\n    };\n    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n        const threshold = 3; // if it takes more than three edits, let's move on.\n        potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n        let recommended = null;\n        let bestDistance = Infinity;\n        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n            const d = levenshtein_1.levenshtein(cmd, candidate);\n            if (d <= threshold && d < bestDistance) {\n                bestDistance = d;\n                recommended = candidate;\n            }\n        }\n        if (recommended)\n            usage.fail(__('Did you mean %s?', recommended));\n    };\n    self.reset = function reset(localLookup) {\n        implied = obj_filter_1.objFilter(implied, k => !localLookup[k]);\n        conflicting = obj_filter_1.objFilter(conflicting, k => !localLookup[k]);\n        checks = checks.filter(c => c.global);\n        return self;\n    };\n    const frozens = [];\n    self.freeze = function freeze() {\n        frozens.push({\n            implied,\n            checks,\n            conflicting\n        });\n    };\n    self.unfreeze = function unfreeze() {\n        const frozen = frozens.pop();\n        common_types_1.assertNotStrictEqual(frozen, undefined);\n        ({\n            implied,\n            checks,\n            conflicting\n        } = frozen);\n    };\n    return self;\n}\nexports.validation = validation;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliL3ZhbGlkYXRpb24uanM/NzRlNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsRUFBVztBQUNyQyx1QkFBdUIsbUJBQU8sQ0FBQyxDQUFnQjtBQUMvQyxzQkFBc0IsbUJBQU8sQ0FBQyxFQUFlO0FBQzdDLHFCQUFxQixtQkFBTyxDQUFDLEVBQWM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxzQkFBc0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0lBQXNJO0FBQ2hLLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwwQkFBMEIsK0JBQStCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVEsTUFBTSxVQUFVO0FBQy9EO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtEQUFrRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI2My5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy52YWxpZGF0aW9uID0gdm9pZCAwO1xuY29uc3QgYXJnc2VydF8xID0gcmVxdWlyZShcIi4vYXJnc2VydFwiKTtcbmNvbnN0IGNvbW1vbl90eXBlc18xID0gcmVxdWlyZShcIi4vY29tbW9uLXR5cGVzXCIpO1xuY29uc3QgbGV2ZW5zaHRlaW5fMSA9IHJlcXVpcmUoXCIuL2xldmVuc2h0ZWluXCIpO1xuY29uc3Qgb2JqX2ZpbHRlcl8xID0gcmVxdWlyZShcIi4vb2JqLWZpbHRlclwiKTtcbmNvbnN0IHNwZWNpYWxLZXlzID0gWyckMCcsICctLScsICdfJ107XG4vLyB2YWxpZGF0aW9uLXR5cGUtc3R1ZmYsIG1pc3NpbmcgcGFyYW1zLFxuLy8gYmFkIGltcGxpY2F0aW9ucywgY3VzdG9tIGNoZWNrcy5cbmZ1bmN0aW9uIHZhbGlkYXRpb24oeWFyZ3MsIHVzYWdlLCB5MThuKSB7XG4gICAgY29uc3QgX18gPSB5MThuLl9fO1xuICAgIGNvbnN0IF9fbiA9IHkxOG4uX19uO1xuICAgIGNvbnN0IHNlbGYgPSB7fTtcbiAgICAvLyB2YWxpZGF0ZSBhcHByb3ByaWF0ZSAjIG9mIG5vbi1vcHRpb25cbiAgICAvLyBhcmd1bWVudHMgd2VyZSBwcm92aWRlZCwgaS5lLiwgJ18nLlxuICAgIHNlbGYubm9uT3B0aW9uQ291bnQgPSBmdW5jdGlvbiBub25PcHRpb25Db3VudChhcmd2KSB7XG4gICAgICAgIGNvbnN0IGRlbWFuZGVkQ29tbWFuZHMgPSB5YXJncy5nZXREZW1hbmRlZENvbW1hbmRzKCk7XG4gICAgICAgIC8vIGRvbid0IGNvdW50IGN1cnJlbnRseSBleGVjdXRpbmcgY29tbWFuZHNcbiAgICAgICAgY29uc3QgX3MgPSBhcmd2Ll8ubGVuZ3RoIC0geWFyZ3MuZ2V0Q29udGV4dCgpLmNvbW1hbmRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGRlbWFuZGVkQ29tbWFuZHMuXyAmJiAoX3MgPCBkZW1hbmRlZENvbW1hbmRzLl8ubWluIHx8IF9zID4gZGVtYW5kZWRDb21tYW5kcy5fLm1heCkpIHtcbiAgICAgICAgICAgIGlmIChfcyA8IGRlbWFuZGVkQ29tbWFuZHMuXy5taW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVtYW5kZWRDb21tYW5kcy5fLm1pbk1zZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHVzYWdlLmZhaWwoXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgJDAgd2l0aCBvYnNlcnZlZCwgJDEgd2l0aCBleHBlY3RlZC5cbiAgICAgICAgICAgICAgICAgICAgZGVtYW5kZWRDb21tYW5kcy5fLm1pbk1zZ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBkZW1hbmRlZENvbW1hbmRzLl8ubWluTXNnLnJlcGxhY2UoL1xcJDAvZywgX3MudG9TdHJpbmcoKSkucmVwbGFjZSgvXFwkMS8sIGRlbWFuZGVkQ29tbWFuZHMuXy5taW4udG9TdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1c2FnZS5mYWlsKF9fbignTm90IGVub3VnaCBub24tb3B0aW9uIGFyZ3VtZW50czogZ290ICVzLCBuZWVkIGF0IGxlYXN0ICVzJywgJ05vdCBlbm91Z2ggbm9uLW9wdGlvbiBhcmd1bWVudHM6IGdvdCAlcywgbmVlZCBhdCBsZWFzdCAlcycsIF9zLCBfcywgZGVtYW5kZWRDb21tYW5kcy5fLm1pbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF9zID4gZGVtYW5kZWRDb21tYW5kcy5fLm1heCkge1xuICAgICAgICAgICAgICAgIGlmIChkZW1hbmRlZENvbW1hbmRzLl8ubWF4TXNnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNhZ2UuZmFpbChcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZSAkMCB3aXRoIG9ic2VydmVkLCAkMSB3aXRoIGV4cGVjdGVkLlxuICAgICAgICAgICAgICAgICAgICBkZW1hbmRlZENvbW1hbmRzLl8ubWF4TXNnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGRlbWFuZGVkQ29tbWFuZHMuXy5tYXhNc2cucmVwbGFjZSgvXFwkMC9nLCBfcy50b1N0cmluZygpKS5yZXBsYWNlKC9cXCQxLywgZGVtYW5kZWRDb21tYW5kcy5fLm1heC50b1N0cmluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVzYWdlLmZhaWwoX19uKCdUb28gbWFueSBub24tb3B0aW9uIGFyZ3VtZW50czogZ290ICVzLCBtYXhpbXVtIG9mICVzJywgJ1RvbyBtYW55IG5vbi1vcHRpb24gYXJndW1lbnRzOiBnb3QgJXMsIG1heGltdW0gb2YgJXMnLCBfcywgX3MsIGRlbWFuZGVkQ29tbWFuZHMuXy5tYXgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIHZhbGlkYXRlIHRoZSBhcHByb3ByaWF0ZSAjIG9mIDxyZXF1aXJlZD5cbiAgICAvLyBwb3NpdGlvbmFsIGFyZ3VtZW50cyB3ZXJlIHByb3ZpZGVkOlxuICAgIHNlbGYucG9zaXRpb25hbENvdW50ID0gZnVuY3Rpb24gcG9zaXRpb25hbENvdW50KHJlcXVpcmVkLCBvYnNlcnZlZCkge1xuICAgICAgICBpZiAob2JzZXJ2ZWQgPCByZXF1aXJlZCkge1xuICAgICAgICAgICAgdXNhZ2UuZmFpbChfX24oJ05vdCBlbm91Z2ggbm9uLW9wdGlvbiBhcmd1bWVudHM6IGdvdCAlcywgbmVlZCBhdCBsZWFzdCAlcycsICdOb3QgZW5vdWdoIG5vbi1vcHRpb24gYXJndW1lbnRzOiBnb3QgJXMsIG5lZWQgYXQgbGVhc3QgJXMnLCBvYnNlcnZlZCwgb2JzZXJ2ZWQsIHJlcXVpcmVkKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIG1ha2Ugc3VyZSBhbGwgdGhlIHJlcXVpcmVkIGFyZ3VtZW50cyBhcmUgcHJlc2VudC5cbiAgICBzZWxmLnJlcXVpcmVkQXJndW1lbnRzID0gZnVuY3Rpb24gcmVxdWlyZWRBcmd1bWVudHMoYXJndikge1xuICAgICAgICBjb25zdCBkZW1hbmRlZE9wdGlvbnMgPSB5YXJncy5nZXREZW1hbmRlZE9wdGlvbnMoKTtcbiAgICAgICAgbGV0IG1pc3NpbmcgPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhkZW1hbmRlZE9wdGlvbnMpKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcmd2LCBrZXkpIHx8IHR5cGVvZiBhcmd2W2tleV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgbWlzc2luZyA9IG1pc3NpbmcgfHwge307XG4gICAgICAgICAgICAgICAgbWlzc2luZ1trZXldID0gZGVtYW5kZWRPcHRpb25zW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pc3NpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbU1zZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG1pc3NpbmcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gbWlzc2luZ1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChtc2cgJiYgY3VzdG9tTXNncy5pbmRleE9mKG1zZykgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbU1zZ3MucHVzaChtc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGN1c3RvbU1zZyA9IGN1c3RvbU1zZ3MubGVuZ3RoID8gYFxcbiR7Y3VzdG9tTXNncy5qb2luKCdcXG4nKX1gIDogJyc7XG4gICAgICAgICAgICB1c2FnZS5mYWlsKF9fbignTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudDogJXMnLCAnTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudHM6ICVzJywgT2JqZWN0LmtleXMobWlzc2luZykubGVuZ3RoLCBPYmplY3Qua2V5cyhtaXNzaW5nKS5qb2luKCcsICcpICsgY3VzdG9tTXNnKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGNoZWNrIGZvciB1bmtub3duIGFyZ3VtZW50cyAoc3RyaWN0LW1vZGUpLlxuICAgIHNlbGYudW5rbm93bkFyZ3VtZW50cyA9IGZ1bmN0aW9uIHVua25vd25Bcmd1bWVudHMoYXJndiwgYWxpYXNlcywgcG9zaXRpb25hbE1hcCwgaXNEZWZhdWx0Q29tbWFuZCkge1xuICAgICAgICBjb25zdCBjb21tYW5kS2V5cyA9IHlhcmdzLmdldENvbW1hbmRJbnN0YW5jZSgpLmdldENvbW1hbmRzKCk7XG4gICAgICAgIGNvbnN0IHVua25vd24gPSBbXTtcbiAgICAgICAgY29uc3QgY3VycmVudENvbnRleHQgPSB5YXJncy5nZXRDb250ZXh0KCk7XG4gICAgICAgIE9iamVjdC5rZXlzKGFyZ3YpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNwZWNpYWxLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBvc2l0aW9uYWxNYXAsIGtleSkgJiZcbiAgICAgICAgICAgICAgICAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHlhcmdzLl9nZXRQYXJzZUNvbnRleHQoKSwga2V5KSAmJlxuICAgICAgICAgICAgICAgICFzZWxmLmlzVmFsaWRBbmRTb21lQWxpYXNJc05vdE5ldyhrZXksIGFsaWFzZXMpKSB7XG4gICAgICAgICAgICAgICAgdW5rbm93bi5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoKGN1cnJlbnRDb250ZXh0LmNvbW1hbmRzLmxlbmd0aCA+IDApIHx8IChjb21tYW5kS2V5cy5sZW5ndGggPiAwKSB8fCBpc0RlZmF1bHRDb21tYW5kKSB7XG4gICAgICAgICAgICBhcmd2Ll8uc2xpY2UoY3VycmVudENvbnRleHQuY29tbWFuZHMubGVuZ3RoKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29tbWFuZEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICB1bmtub3duLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5rbm93bi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB1c2FnZS5mYWlsKF9fbignVW5rbm93biBhcmd1bWVudDogJXMnLCAnVW5rbm93biBhcmd1bWVudHM6ICVzJywgdW5rbm93bi5sZW5ndGgsIHVua25vd24uam9pbignLCAnKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzZWxmLnVua25vd25Db21tYW5kcyA9IGZ1bmN0aW9uIHVua25vd25Db21tYW5kcyhhcmd2KSB7XG4gICAgICAgIGNvbnN0IGNvbW1hbmRLZXlzID0geWFyZ3MuZ2V0Q29tbWFuZEluc3RhbmNlKCkuZ2V0Q29tbWFuZHMoKTtcbiAgICAgICAgY29uc3QgdW5rbm93biA9IFtdO1xuICAgICAgICBjb25zdCBjdXJyZW50Q29udGV4dCA9IHlhcmdzLmdldENvbnRleHQoKTtcbiAgICAgICAgaWYgKChjdXJyZW50Q29udGV4dC5jb21tYW5kcy5sZW5ndGggPiAwKSB8fCAoY29tbWFuZEtleXMubGVuZ3RoID4gMCkpIHtcbiAgICAgICAgICAgIGFyZ3YuXy5zbGljZShjdXJyZW50Q29udGV4dC5jb21tYW5kcy5sZW5ndGgpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjb21tYW5kS2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHVua25vd24ucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmtub3duLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHVzYWdlLmZhaWwoX19uKCdVbmtub3duIGNvbW1hbmQ6ICVzJywgJ1Vua25vd24gY29tbWFuZHM6ICVzJywgdW5rbm93bi5sZW5ndGgsIHVua25vd24uam9pbignLCAnKSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGNoZWNrIGZvciBhIGtleSB0aGF0IGlzIG5vdCBhbiBhbGlhcywgb3IgZm9yIHdoaWNoIGV2ZXJ5IGFsaWFzIGlzIG5ldyxcbiAgICAvLyBpbXBseWluZyB0aGF0IGl0IHdhcyBpbnZlbnRlZCBieSB0aGUgcGFyc2VyLCBlLmcuLCBkdXJpbmcgY2FtZWxpemF0aW9uXG4gICAgc2VsZi5pc1ZhbGlkQW5kU29tZUFsaWFzSXNOb3ROZXcgPSBmdW5jdGlvbiBpc1ZhbGlkQW5kU29tZUFsaWFzSXNOb3ROZXcoa2V5LCBhbGlhc2VzKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFsaWFzZXMsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdBbGlhc2VzID0geWFyZ3MucGFyc2VkLm5ld0FsaWFzZXM7XG4gICAgICAgIGZvciAoY29uc3QgYSBvZiBba2V5LCAuLi5hbGlhc2VzW2tleV1dKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuZXdBbGlhc2VzLCBhKSB8fCAhbmV3QWxpYXNlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgLy8gdmFsaWRhdGUgYXJndW1lbnRzIGxpbWl0ZWQgdG8gZW51bWVyYXRlZCBjaG9pY2VzXG4gICAgc2VsZi5saW1pdGVkQ2hvaWNlcyA9IGZ1bmN0aW9uIGxpbWl0ZWRDaG9pY2VzKGFyZ3YpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHlhcmdzLmdldE9wdGlvbnMoKTtcbiAgICAgICAgY29uc3QgaW52YWxpZCA9IHt9O1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKG9wdGlvbnMuY2hvaWNlcykubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBPYmplY3Qua2V5cyhhcmd2KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChzcGVjaWFsS2V5cy5pbmRleE9mKGtleSkgPT09IC0xICYmXG4gICAgICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMuY2hvaWNlcywga2V5KSkge1xuICAgICAgICAgICAgICAgIFtdLmNvbmNhdChhcmd2W2tleV0pLmZvckVhY2goKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gY2FzZS1pbnNlbnNpdGl2ZSBjb25maWd1cmFiaWxpdHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2hvaWNlc1trZXldLmluZGV4T2YodmFsdWUpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZFtrZXldID0gKGludmFsaWRba2V5XSB8fCBbXSkuY29uY2F0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaW52YWxpZEtleXMgPSBPYmplY3Qua2V5cyhpbnZhbGlkKTtcbiAgICAgICAgaWYgKCFpbnZhbGlkS2V5cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBtc2cgPSBfXygnSW52YWxpZCB2YWx1ZXM6Jyk7XG4gICAgICAgIGludmFsaWRLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgbXNnICs9IGBcXG4gICR7X18oJ0FyZ3VtZW50OiAlcywgR2l2ZW46ICVzLCBDaG9pY2VzOiAlcycsIGtleSwgdXNhZ2Uuc3RyaW5naWZpZWRWYWx1ZXMoaW52YWxpZFtrZXldKSwgdXNhZ2Uuc3RyaW5naWZpZWRWYWx1ZXMob3B0aW9ucy5jaG9pY2VzW2tleV0pKX1gO1xuICAgICAgICB9KTtcbiAgICAgICAgdXNhZ2UuZmFpbChtc2cpO1xuICAgIH07XG4gICAgLy8gY3VzdG9tIGNoZWNrcywgYWRkZWQgdXNpbmcgdGhlIGBjaGVja2Agb3B0aW9uIG9uIHlhcmdzLlxuICAgIGxldCBjaGVja3MgPSBbXTtcbiAgICBzZWxmLmNoZWNrID0gZnVuY3Rpb24gY2hlY2soZiwgZ2xvYmFsKSB7XG4gICAgICAgIGNoZWNrcy5wdXNoKHtcbiAgICAgICAgICAgIGZ1bmM6IGYsXG4gICAgICAgICAgICBnbG9iYWxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBzZWxmLmN1c3RvbUNoZWNrcyA9IGZ1bmN0aW9uIGN1c3RvbUNoZWNrcyhhcmd2LCBhbGlhc2VzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBmOyAoZiA9IGNoZWNrc1tpXSkgIT09IHVuZGVmaW5lZDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBmdW5jID0gZi5mdW5jO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmMoYXJndiwgYWxpYXNlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdXNhZ2UuZmFpbChlcnIubWVzc2FnZSA/IGVyci5tZXNzYWdlIDogZXJyLCBlcnIpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB1c2FnZS5mYWlsKF9fKCdBcmd1bWVudCBjaGVjayBmYWlsZWQ6ICVzJywgZnVuYy50b1N0cmluZygpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJyB8fCByZXN1bHQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHVzYWdlLmZhaWwocmVzdWx0LnRvU3RyaW5nKCksIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGNoZWNrIGltcGxpY2F0aW9ucywgYXJndW1lbnQgZm9vIGltcGxpZXMgPT4gYXJndW1lbnQgYmFyLlxuICAgIGxldCBpbXBsaWVkID0ge307XG4gICAgc2VsZi5pbXBsaWVzID0gZnVuY3Rpb24gaW1wbGllcyhrZXksIHZhbHVlKSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCc8c3RyaW5nfG9iamVjdD4gW2FycmF5fG51bWJlcnxzdHJpbmddJywgW2tleSwgdmFsdWVdLCBhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhrZXkpLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgICAgICBzZWxmLmltcGxpZXMoaywga2V5W2tdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgeWFyZ3MuZ2xvYmFsKGtleSk7XG4gICAgICAgICAgICBpZiAoIWltcGxpZWRba2V5XSkge1xuICAgICAgICAgICAgICAgIGltcGxpZWRba2V5XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgoaSkgPT4gc2VsZi5pbXBsaWVzKGtleSwgaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tbW9uX3R5cGVzXzEuYXNzZXJ0Tm90U3RyaWN0RXF1YWwodmFsdWUsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgaW1wbGllZFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBzZWxmLmdldEltcGxpZWQgPSBmdW5jdGlvbiBnZXRJbXBsaWVkKCkge1xuICAgICAgICByZXR1cm4gaW1wbGllZDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGtleUV4aXN0cyhhcmd2LCB2YWwpIHtcbiAgICAgICAgLy8gY29udmVydCBzdHJpbmcgJzEnIHRvIG51bWJlciAxXG4gICAgICAgIGNvbnN0IG51bSA9IE51bWJlcih2YWwpO1xuICAgICAgICB2YWwgPSBpc05hTihudW0pID8gdmFsIDogbnVtO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGxlbmd0aCBvZiBhcmd2Ll9cbiAgICAgICAgICAgIHZhbCA9IGFyZ3YuXy5sZW5ndGggPj0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbC5tYXRjaCgvXi0tbm8tLisvKSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYga2V5L3ZhbHVlIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgICAgIHZhbCA9IHZhbC5tYXRjaCgvXi0tbm8tKC4rKS8pWzFdO1xuICAgICAgICAgICAgdmFsID0gIWFyZ3ZbdmFsXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGtleS92YWx1ZSBleGlzdHNcbiAgICAgICAgICAgIHZhbCA9IGFyZ3ZbdmFsXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBzZWxmLmltcGxpY2F0aW9ucyA9IGZ1bmN0aW9uIGltcGxpY2F0aW9ucyhhcmd2KSB7XG4gICAgICAgIGNvbnN0IGltcGx5RmFpbCA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhpbXBsaWVkKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdLZXkgPSBrZXk7XG4gICAgICAgICAgICAoaW1wbGllZFtrZXldIHx8IFtdKS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBrZXkgPSBvcmlnS2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGtleSA9IGtleUV4aXN0cyhhcmd2LCBrZXkpO1xuICAgICAgICAgICAgICAgIHZhbHVlID0ga2V5RXhpc3RzKGFyZ3YsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICYmICF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpbXBseUZhaWwucHVzaChgICR7b3JpZ0tleX0gLT4gJHtvcmlnVmFsdWV9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW1wbHlGYWlsLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IG1zZyA9IGAke19fKCdJbXBsaWNhdGlvbnMgZmFpbGVkOicpfVxcbmA7XG4gICAgICAgICAgICBpbXBseUZhaWwuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBtc2cgKz0gKHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdXNhZ2UuZmFpbChtc2cpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgY29uZmxpY3RpbmcgPSB7fTtcbiAgICBzZWxmLmNvbmZsaWN0cyA9IGZ1bmN0aW9uIGNvbmZsaWN0cyhrZXksIHZhbHVlKSB7XG4gICAgICAgIGFyZ3NlcnRfMS5hcmdzZXJ0KCc8c3RyaW5nfG9iamVjdD4gW2FycmF5fHN0cmluZ10nLCBba2V5LCB2YWx1ZV0sIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGtleSkuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmxpY3RzKGssIGtleVtrXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHlhcmdzLmdsb2JhbChrZXkpO1xuICAgICAgICAgICAgaWYgKCFjb25mbGljdGluZ1trZXldKSB7XG4gICAgICAgICAgICAgICAgY29uZmxpY3Rpbmdba2V5XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgoaSkgPT4gc2VsZi5jb25mbGljdHMoa2V5LCBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25mbGljdGluZ1trZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBzZWxmLmdldENvbmZsaWN0aW5nID0gKCkgPT4gY29uZmxpY3Rpbmc7XG4gICAgc2VsZi5jb25mbGljdGluZyA9IGZ1bmN0aW9uIGNvbmZsaWN0aW5nRm4oYXJndikge1xuICAgICAgICBPYmplY3Qua2V5cyhhcmd2KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChjb25mbGljdGluZ1trZXldKSB7XG4gICAgICAgICAgICAgICAgY29uZmxpY3Rpbmdba2V5XS5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBkZWZhdWx0IGtleXMgdG8gJ3VuZGVmaW5lZCcgdGhhdCBoYXZlIGJlZW4gY29uZmlndXJlZCwgd2Ugc2hvdWxkIG5vdFxuICAgICAgICAgICAgICAgICAgICAvLyBhcHBseSBjb25mbGljdGluZyBjaGVjayB1bmxlc3MgdGhleSBhcmUgYSB2YWx1ZSBvdGhlciB0aGFuICd1bmRlZmluZWQnLlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgJiYgYXJndltrZXldICE9PSB1bmRlZmluZWQgJiYgYXJndlt2YWx1ZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNhZ2UuZmFpbChfXygnQXJndW1lbnRzICVzIGFuZCAlcyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlJywga2V5LCB2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgc2VsZi5yZWNvbW1lbmRDb21tYW5kcyA9IGZ1bmN0aW9uIHJlY29tbWVuZENvbW1hbmRzKGNtZCwgcG90ZW50aWFsQ29tbWFuZHMpIHtcbiAgICAgICAgY29uc3QgdGhyZXNob2xkID0gMzsgLy8gaWYgaXQgdGFrZXMgbW9yZSB0aGFuIHRocmVlIGVkaXRzLCBsZXQncyBtb3ZlIG9uLlxuICAgICAgICBwb3RlbnRpYWxDb21tYW5kcyA9IHBvdGVudGlhbENvbW1hbmRzLnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpO1xuICAgICAgICBsZXQgcmVjb21tZW5kZWQgPSBudWxsO1xuICAgICAgICBsZXQgYmVzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjYW5kaWRhdGU7IChjYW5kaWRhdGUgPSBwb3RlbnRpYWxDb21tYW5kc1tpXSkgIT09IHVuZGVmaW5lZDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkID0gbGV2ZW5zaHRlaW5fMS5sZXZlbnNodGVpbihjbWQsIGNhbmRpZGF0ZSk7XG4gICAgICAgICAgICBpZiAoZCA8PSB0aHJlc2hvbGQgJiYgZCA8IGJlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGJlc3REaXN0YW5jZSA9IGQ7XG4gICAgICAgICAgICAgICAgcmVjb21tZW5kZWQgPSBjYW5kaWRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY29tbWVuZGVkKVxuICAgICAgICAgICAgdXNhZ2UuZmFpbChfXygnRGlkIHlvdSBtZWFuICVzPycsIHJlY29tbWVuZGVkKSk7XG4gICAgfTtcbiAgICBzZWxmLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQobG9jYWxMb29rdXApIHtcbiAgICAgICAgaW1wbGllZCA9IG9ial9maWx0ZXJfMS5vYmpGaWx0ZXIoaW1wbGllZCwgayA9PiAhbG9jYWxMb29rdXBba10pO1xuICAgICAgICBjb25mbGljdGluZyA9IG9ial9maWx0ZXJfMS5vYmpGaWx0ZXIoY29uZmxpY3RpbmcsIGsgPT4gIWxvY2FsTG9va3VwW2tdKTtcbiAgICAgICAgY2hlY2tzID0gY2hlY2tzLmZpbHRlcihjID0+IGMuZ2xvYmFsKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfTtcbiAgICBjb25zdCBmcm96ZW5zID0gW107XG4gICAgc2VsZi5mcmVlemUgPSBmdW5jdGlvbiBmcmVlemUoKSB7XG4gICAgICAgIGZyb3plbnMucHVzaCh7XG4gICAgICAgICAgICBpbXBsaWVkLFxuICAgICAgICAgICAgY2hlY2tzLFxuICAgICAgICAgICAgY29uZmxpY3RpbmdcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBzZWxmLnVuZnJlZXplID0gZnVuY3Rpb24gdW5mcmVlemUoKSB7XG4gICAgICAgIGNvbnN0IGZyb3plbiA9IGZyb3plbnMucG9wKCk7XG4gICAgICAgIGNvbW1vbl90eXBlc18xLmFzc2VydE5vdFN0cmljdEVxdWFsKGZyb3plbiwgdW5kZWZpbmVkKTtcbiAgICAgICAgKHtcbiAgICAgICAgICAgIGltcGxpZWQsXG4gICAgICAgICAgICBjaGVja3MsXG4gICAgICAgICAgICBjb25mbGljdGluZ1xuICAgICAgICB9ID0gZnJvemVuKTtcbiAgICB9O1xuICAgIHJldHVybiBzZWxmO1xufVxuZXhwb3J0cy52YWxpZGF0aW9uID0gdmFsaWRhdGlvbjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///63\n")},function(module,exports,__webpack_require__){"use strict";eval('\n/*\nCopyright (c) 2011 Andrei Mackenzie\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the "Software"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.levenshtein = void 0;\n// levenshtein distance algorithm, pulled from Andrei Mackenzie\'s MIT licensed.\n// gist, which can be found here: https://gist.github.com/andrei-m/982927\n// Compute the edit distance between the two given strings\nfunction levenshtein(a, b) {\n    if (a.length === 0)\n        return b.length;\n    if (b.length === 0)\n        return a.length;\n    const matrix = [];\n    // increment along the first column of each row\n    let i;\n    for (i = 0; i <= b.length; i++) {\n        matrix[i] = [i];\n    }\n    // increment each column in the first row\n    let j;\n    for (j = 0; j <= a.length; j++) {\n        matrix[0][j] = j;\n    }\n    // Fill in the rest of the matrix\n    for (i = 1; i <= b.length; i++) {\n        for (j = 1; j <= a.length; j++) {\n            if (b.charAt(i - 1) === a.charAt(j - 1)) {\n                matrix[i][j] = matrix[i - 1][j - 1];\n            }\n            else {\n                matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution\n                Math.min(matrix[i][j - 1] + 1, // insertion\n                matrix[i - 1][j] + 1)); // deletion\n            }\n        }\n    }\n    return matrix[b.length][a.length];\n}\nexports.levenshtein = levenshtein;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliL2xldmVuc2h0ZWluLmpzP2RkMGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZTtBQUM5QixtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjY0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKlxuQ29weXJpZ2h0IChjKSAyMDExIEFuZHJlaSBNYWNrZW56aWVcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZlxudGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpblxudGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0b1xudXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2ZcbnRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbyxcbnN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbmNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTXG5GT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1JcbkNPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUlxuSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU5cbkNPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sZXZlbnNodGVpbiA9IHZvaWQgMDtcbi8vIGxldmVuc2h0ZWluIGRpc3RhbmNlIGFsZ29yaXRobSwgcHVsbGVkIGZyb20gQW5kcmVpIE1hY2tlbnppZSdzIE1JVCBsaWNlbnNlZC5cbi8vIGdpc3QsIHdoaWNoIGNhbiBiZSBmb3VuZCBoZXJlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9hbmRyZWktbS85ODI5Mjdcbi8vIENvbXB1dGUgdGhlIGVkaXQgZGlzdGFuY2UgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHN0cmluZ3NcbmZ1bmN0aW9uIGxldmVuc2h0ZWluKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBiLmxlbmd0aDtcbiAgICBpZiAoYi5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBhLmxlbmd0aDtcbiAgICBjb25zdCBtYXRyaXggPSBbXTtcbiAgICAvLyBpbmNyZW1lbnQgYWxvbmcgdGhlIGZpcnN0IGNvbHVtbiBvZiBlYWNoIHJvd1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPD0gYi5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXRyaXhbaV0gPSBbaV07XG4gICAgfVxuICAgIC8vIGluY3JlbWVudCBlYWNoIGNvbHVtbiBpbiB0aGUgZmlyc3Qgcm93XG4gICAgbGV0IGo7XG4gICAgZm9yIChqID0gMDsgaiA8PSBhLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG1hdHJpeFswXVtqXSA9IGo7XG4gICAgfVxuICAgIC8vIEZpbGwgaW4gdGhlIHJlc3Qgb2YgdGhlIG1hdHJpeFxuICAgIGZvciAoaSA9IDE7IGkgPD0gYi5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGogPSAxOyBqIDw9IGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChiLmNoYXJBdChpIC0gMSkgPT09IGEuY2hhckF0KGogLSAxKSkge1xuICAgICAgICAgICAgICAgIG1hdHJpeFtpXVtqXSA9IG1hdHJpeFtpIC0gMV1baiAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF0cml4W2ldW2pdID0gTWF0aC5taW4obWF0cml4W2kgLSAxXVtqIC0gMV0gKyAxLCAvLyBzdWJzdGl0dXRpb25cbiAgICAgICAgICAgICAgICBNYXRoLm1pbihtYXRyaXhbaV1baiAtIDFdICsgMSwgLy8gaW5zZXJ0aW9uXG4gICAgICAgICAgICAgICAgbWF0cml4W2kgLSAxXVtqXSArIDEpKTsgLy8gZGVsZXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0cml4W2IubGVuZ3RoXVthLmxlbmd0aF07XG59XG5leHBvcnRzLmxldmVuc2h0ZWluID0gbGV2ZW5zaHRlaW47XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///64\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyExtends = void 0;\nconst fs = __webpack_require__(2);\nconst path = __webpack_require__(0);\nconst yerror_1 = __webpack_require__(6);\nlet previouslyVisitedConfigs = [];\nfunction checkForCircularExtends(cfgPath) {\n    if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {\n        throw new yerror_1.YError(`Circular extended configurations: '${cfgPath}'.`);\n    }\n}\nfunction getPathToDefaultConfig(cwd, pathToExtend) {\n    return path.resolve(cwd, pathToExtend);\n}\nfunction mergeDeep(config1, config2) {\n    const target = {};\n    function isObject(obj) {\n        return obj && typeof obj === 'object' && !Array.isArray(obj);\n    }\n    Object.assign(target, config1);\n    for (const key of Object.keys(config2)) {\n        if (isObject(config2[key]) && isObject(target[key])) {\n            target[key] = mergeDeep(config1[key], config2[key]);\n        }\n        else {\n            target[key] = config2[key];\n        }\n    }\n    return target;\n}\nfunction applyExtends(config, cwd, mergeExtends = false) {\n    let defaultConfig = {};\n    if (Object.prototype.hasOwnProperty.call(config, 'extends')) {\n        if (typeof config.extends !== 'string')\n            return defaultConfig;\n        const isPath = /\\.json|\\..*rc$/.test(config.extends);\n        let pathToDefault = null;\n        if (!isPath) {\n            try {\n                pathToDefault = /*require.resolve*/(__webpack_require__(7).resolve(config.extends));\n            }\n            catch (err) {\n                // most likely this simply isn't a module.\n            }\n        }\n        else {\n            pathToDefault = getPathToDefaultConfig(cwd, config.extends);\n        }\n        // maybe the module uses key for some other reason,\n        // err on side of caution.\n        if (!pathToDefault && !isPath)\n            return config;\n        if (!pathToDefault)\n            throw new yerror_1.YError(`Unable to find extended config '${config.extends}' in '${cwd}'.`);\n        checkForCircularExtends(pathToDefault);\n        previouslyVisitedConfigs.push(pathToDefault);\n        defaultConfig = isPath ? JSON.parse(fs.readFileSync(pathToDefault, 'utf8')) : __webpack_require__(7)(config.extends);\n        delete config.extends;\n        defaultConfig = applyExtends(defaultConfig, path.dirname(pathToDefault), mergeExtends);\n    }\n    previouslyVisitedConfigs = [];\n    return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);\n}\nexports.applyExtends = applyExtends;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3MvYnVpbGQvbGliL2FwcGx5LWV4dGVuZHMuanM/MzliYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLENBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLENBQU07QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMsQ0FBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsUUFBUTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQWUsQ0FBQyw2Q0FBYztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxlQUFlLFFBQVEsSUFBSTtBQUNwRztBQUNBO0FBQ0Esc0ZBQXNGLHVCQUFRLGNBQWMsQ0FBQztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBIiwiZmlsZSI6IjY1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFwcGx5RXh0ZW5kcyA9IHZvaWQgMDtcbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgeWVycm9yXzEgPSByZXF1aXJlKFwiLi95ZXJyb3JcIik7XG5sZXQgcHJldmlvdXNseVZpc2l0ZWRDb25maWdzID0gW107XG5mdW5jdGlvbiBjaGVja0ZvckNpcmN1bGFyRXh0ZW5kcyhjZmdQYXRoKSB7XG4gICAgaWYgKHByZXZpb3VzbHlWaXNpdGVkQ29uZmlncy5pbmRleE9mKGNmZ1BhdGgpID4gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IHllcnJvcl8xLllFcnJvcihgQ2lyY3VsYXIgZXh0ZW5kZWQgY29uZmlndXJhdGlvbnM6ICcke2NmZ1BhdGh9Jy5gKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRQYXRoVG9EZWZhdWx0Q29uZmlnKGN3ZCwgcGF0aFRvRXh0ZW5kKSB7XG4gICAgcmV0dXJuIHBhdGgucmVzb2x2ZShjd2QsIHBhdGhUb0V4dGVuZCk7XG59XG5mdW5jdGlvbiBtZXJnZURlZXAoY29uZmlnMSwgY29uZmlnMikge1xuICAgIGNvbnN0IHRhcmdldCA9IHt9O1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9iaik7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBjb25maWcxKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjb25maWcyKSkge1xuICAgICAgICBpZiAoaXNPYmplY3QoY29uZmlnMltrZXldKSAmJiBpc09iamVjdCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gbWVyZ2VEZWVwKGNvbmZpZzFba2V5XSwgY29uZmlnMltrZXldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gY29uZmlnMltrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBhcHBseUV4dGVuZHMoY29uZmlnLCBjd2QsIG1lcmdlRXh0ZW5kcyA9IGZhbHNlKSB7XG4gICAgbGV0IGRlZmF1bHRDb25maWcgPSB7fTtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2V4dGVuZHMnKSkge1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZy5leHRlbmRzICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0Q29uZmlnO1xuICAgICAgICBjb25zdCBpc1BhdGggPSAvXFwuanNvbnxcXC4uKnJjJC8udGVzdChjb25maWcuZXh0ZW5kcyk7XG4gICAgICAgIGxldCBwYXRoVG9EZWZhdWx0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpc1BhdGgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF0aFRvRGVmYXVsdCA9IHJlcXVpcmUucmVzb2x2ZShjb25maWcuZXh0ZW5kcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gbW9zdCBsaWtlbHkgdGhpcyBzaW1wbHkgaXNuJ3QgYSBtb2R1bGUuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXRoVG9EZWZhdWx0ID0gZ2V0UGF0aFRvRGVmYXVsdENvbmZpZyhjd2QsIGNvbmZpZy5leHRlbmRzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYXliZSB0aGUgbW9kdWxlIHVzZXMga2V5IGZvciBzb21lIG90aGVyIHJlYXNvbixcbiAgICAgICAgLy8gZXJyIG9uIHNpZGUgb2YgY2F1dGlvbi5cbiAgICAgICAgaWYgKCFwYXRoVG9EZWZhdWx0ICYmICFpc1BhdGgpXG4gICAgICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgICAgICBpZiAoIXBhdGhUb0RlZmF1bHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgeWVycm9yXzEuWUVycm9yKGBVbmFibGUgdG8gZmluZCBleHRlbmRlZCBjb25maWcgJyR7Y29uZmlnLmV4dGVuZHN9JyBpbiAnJHtjd2R9Jy5gKTtcbiAgICAgICAgY2hlY2tGb3JDaXJjdWxhckV4dGVuZHMocGF0aFRvRGVmYXVsdCk7XG4gICAgICAgIHByZXZpb3VzbHlWaXNpdGVkQ29uZmlncy5wdXNoKHBhdGhUb0RlZmF1bHQpO1xuICAgICAgICBkZWZhdWx0Q29uZmlnID0gaXNQYXRoID8gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGF0aFRvRGVmYXVsdCwgJ3V0ZjgnKSkgOiByZXF1aXJlKGNvbmZpZy5leHRlbmRzKTtcbiAgICAgICAgZGVsZXRlIGNvbmZpZy5leHRlbmRzO1xuICAgICAgICBkZWZhdWx0Q29uZmlnID0gYXBwbHlFeHRlbmRzKGRlZmF1bHRDb25maWcsIHBhdGguZGlybmFtZShwYXRoVG9EZWZhdWx0KSwgbWVyZ2VFeHRlbmRzKTtcbiAgICB9XG4gICAgcHJldmlvdXNseVZpc2l0ZWRDb25maWdzID0gW107XG4gICAgcmV0dXJuIG1lcmdlRXh0ZW5kcyA/IG1lcmdlRGVlcChkZWZhdWx0Q29uZmlnLCBjb25maWcpIDogT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENvbmZpZywgY29uZmlnKTtcbn1cbmV4cG9ydHMuYXBwbHlFeHRlbmRzID0gYXBwbHlFeHRlbmRzO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///65\n")},function(module,exports,__webpack_require__){eval("var fs = __webpack_require__(2)\nvar path = __webpack_require__(0)\nvar util = __webpack_require__(3)\n\nfunction Y18N (opts) {\n  // configurable options.\n  opts = opts || {}\n  this.directory = opts.directory || './locales'\n  this.updateFiles = typeof opts.updateFiles === 'boolean' ? opts.updateFiles : true\n  this.locale = opts.locale || 'en'\n  this.fallbackToLanguage = typeof opts.fallbackToLanguage === 'boolean' ? opts.fallbackToLanguage : true\n\n  // internal stuff.\n  this.cache = {}\n  this.writeQueue = []\n}\n\nY18N.prototype.__ = function () {\n  if (typeof arguments[0] !== 'string') {\n    return this._taggedLiteral.apply(this, arguments)\n  }\n  var args = Array.prototype.slice.call(arguments)\n  var str = args.shift()\n  var cb = function () {} // start with noop.\n\n  if (typeof args[args.length - 1] === 'function') cb = args.pop()\n  cb = cb || function () {} // noop.\n\n  if (!this.cache[this.locale]) this._readLocaleFile()\n\n  // we've observed a new string, update the language file.\n  if (!this.cache[this.locale][str] && this.updateFiles) {\n    this.cache[this.locale][str] = str\n\n    // include the current directory and locale,\n    // since these values could change before the\n    // write is performed.\n    this._enqueueWrite([this.directory, this.locale, cb])\n  } else {\n    cb()\n  }\n\n  return util.format.apply(util, [this.cache[this.locale][str] || str].concat(args))\n}\n\nY18N.prototype._taggedLiteral = function (parts) {\n  var args = arguments\n  var str = ''\n  parts.forEach(function (part, i) {\n    var arg = args[i + 1]\n    str += part\n    if (typeof arg !== 'undefined') {\n      str += '%s'\n    }\n  })\n  return this.__.apply(null, [str].concat([].slice.call(arguments, 1)))\n}\n\nY18N.prototype._enqueueWrite = function (work) {\n  this.writeQueue.push(work)\n  if (this.writeQueue.length === 1) this._processWriteQueue()\n}\n\nY18N.prototype._processWriteQueue = function () {\n  var _this = this\n  var work = this.writeQueue[0]\n\n  // destructure the enqueued work.\n  var directory = work[0]\n  var locale = work[1]\n  var cb = work[2]\n\n  var languageFile = this._resolveLocaleFile(directory, locale)\n  var serializedLocale = JSON.stringify(this.cache[locale], null, 2)\n\n  fs.writeFile(languageFile, serializedLocale, 'utf-8', function (err) {\n    _this.writeQueue.shift()\n    if (_this.writeQueue.length > 0) _this._processWriteQueue()\n    cb(err)\n  })\n}\n\nY18N.prototype._readLocaleFile = function () {\n  var localeLookup = {}\n  var languageFile = this._resolveLocaleFile(this.directory, this.locale)\n\n  try {\n    localeLookup = JSON.parse(fs.readFileSync(languageFile, 'utf-8'))\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      err.message = 'syntax error in ' + languageFile\n    }\n\n    if (err.code === 'ENOENT') localeLookup = {}\n    else throw err\n  }\n\n  this.cache[this.locale] = localeLookup\n}\n\nY18N.prototype._resolveLocaleFile = function (directory, locale) {\n  var file = path.resolve(directory, './', locale + '.json')\n  if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf('_')) {\n    // attempt fallback to language only\n    var languageFile = path.resolve(directory, './', locale.split('_')[0] + '.json')\n    if (this._fileExistsSync(languageFile)) file = languageFile\n  }\n  return file\n}\n\n// this only exists because fs.existsSync() \"will be deprecated\"\n// see https://nodejs.org/api/fs.html#fs_fs_existssync_path\nY18N.prototype._fileExistsSync = function (file) {\n  try {\n    return fs.statSync(file).isFile()\n  } catch (err) {\n    return false\n  }\n}\n\nY18N.prototype.__n = function () {\n  var args = Array.prototype.slice.call(arguments)\n  var singular = args.shift()\n  var plural = args.shift()\n  var quantity = args.shift()\n\n  var cb = function () {} // start with noop.\n  if (typeof args[args.length - 1] === 'function') cb = args.pop()\n\n  if (!this.cache[this.locale]) this._readLocaleFile()\n\n  var str = quantity === 1 ? singular : plural\n  if (this.cache[this.locale][singular]) {\n    str = this.cache[this.locale][singular][quantity === 1 ? 'one' : 'other']\n  }\n\n  // we've observed a new string, update the language file.\n  if (!this.cache[this.locale][singular] && this.updateFiles) {\n    this.cache[this.locale][singular] = {\n      one: singular,\n      other: plural\n    }\n\n    // include the current directory and locale,\n    // since these values could change before the\n    // write is performed.\n    this._enqueueWrite([this.directory, this.locale, cb])\n  } else {\n    cb()\n  }\n\n  // if a %d placeholder is provided, add quantity\n  // to the arguments expanded by util.format.\n  var values = [str]\n  if (~str.indexOf('%d')) values.push(quantity)\n\n  return util.format.apply(util, values.concat(args))\n}\n\nY18N.prototype.setLocale = function (locale) {\n  this.locale = locale\n}\n\nY18N.prototype.getLocale = function () {\n  return this.locale\n}\n\nY18N.prototype.updateLocale = function (obj) {\n  if (!this.cache[this.locale]) this._readLocaleFile()\n\n  for (var key in obj) {\n    this.cache[this.locale][key] = obj[key]\n  }\n}\n\nmodule.exports = function (opts) {\n  var y18n = new Y18N(opts)\n\n  // bind all functions to y18n, so that\n  // they can be used in isolation.\n  for (var key in y18n) {\n    if (typeof y18n[key] === 'function') {\n      y18n[key] = y18n[key].bind(y18n)\n    }\n  }\n\n  return y18n\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveTE4bi9pbmRleC5qcz8zZjgxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFNBQVMsbUJBQU8sQ0FBQyxDQUFJO0FBQ3JCLFdBQVcsbUJBQU8sQ0FBQyxDQUFNO0FBQ3pCLFdBQVcsbUJBQU8sQ0FBQyxDQUFNOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0EsMkJBQTJCOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6IjY2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGZzID0gcmVxdWlyZSgnZnMnKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbmZ1bmN0aW9uIFkxOE4gKG9wdHMpIHtcbiAgLy8gY29uZmlndXJhYmxlIG9wdGlvbnMuXG4gIG9wdHMgPSBvcHRzIHx8IHt9XG4gIHRoaXMuZGlyZWN0b3J5ID0gb3B0cy5kaXJlY3RvcnkgfHwgJy4vbG9jYWxlcydcbiAgdGhpcy51cGRhdGVGaWxlcyA9IHR5cGVvZiBvcHRzLnVwZGF0ZUZpbGVzID09PSAnYm9vbGVhbicgPyBvcHRzLnVwZGF0ZUZpbGVzIDogdHJ1ZVxuICB0aGlzLmxvY2FsZSA9IG9wdHMubG9jYWxlIHx8ICdlbidcbiAgdGhpcy5mYWxsYmFja1RvTGFuZ3VhZ2UgPSB0eXBlb2Ygb3B0cy5mYWxsYmFja1RvTGFuZ3VhZ2UgPT09ICdib29sZWFuJyA/IG9wdHMuZmFsbGJhY2tUb0xhbmd1YWdlIDogdHJ1ZVxuXG4gIC8vIGludGVybmFsIHN0dWZmLlxuICB0aGlzLmNhY2hlID0ge31cbiAgdGhpcy53cml0ZVF1ZXVlID0gW11cbn1cblxuWTE4Ti5wcm90b3R5cGUuX18gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0aGlzLl90YWdnZWRMaXRlcmFsLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgdmFyIHN0ciA9IGFyZ3Muc2hpZnQoKVxuICB2YXIgY2IgPSBmdW5jdGlvbiAoKSB7fSAvLyBzdGFydCB3aXRoIG5vb3AuXG5cbiAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIGNiID0gYXJncy5wb3AoKVxuICBjYiA9IGNiIHx8IGZ1bmN0aW9uICgpIHt9IC8vIG5vb3AuXG5cbiAgaWYgKCF0aGlzLmNhY2hlW3RoaXMubG9jYWxlXSkgdGhpcy5fcmVhZExvY2FsZUZpbGUoKVxuXG4gIC8vIHdlJ3ZlIG9ic2VydmVkIGEgbmV3IHN0cmluZywgdXBkYXRlIHRoZSBsYW5ndWFnZSBmaWxlLlxuICBpZiAoIXRoaXMuY2FjaGVbdGhpcy5sb2NhbGVdW3N0cl0gJiYgdGhpcy51cGRhdGVGaWxlcykge1xuICAgIHRoaXMuY2FjaGVbdGhpcy5sb2NhbGVdW3N0cl0gPSBzdHJcblxuICAgIC8vIGluY2x1ZGUgdGhlIGN1cnJlbnQgZGlyZWN0b3J5IGFuZCBsb2NhbGUsXG4gICAgLy8gc2luY2UgdGhlc2UgdmFsdWVzIGNvdWxkIGNoYW5nZSBiZWZvcmUgdGhlXG4gICAgLy8gd3JpdGUgaXMgcGVyZm9ybWVkLlxuICAgIHRoaXMuX2VucXVldWVXcml0ZShbdGhpcy5kaXJlY3RvcnksIHRoaXMubG9jYWxlLCBjYl0pXG4gIH0gZWxzZSB7XG4gICAgY2IoKVxuICB9XG5cbiAgcmV0dXJuIHV0aWwuZm9ybWF0LmFwcGx5KHV0aWwsIFt0aGlzLmNhY2hlW3RoaXMubG9jYWxlXVtzdHJdIHx8IHN0cl0uY29uY2F0KGFyZ3MpKVxufVxuXG5ZMThOLnByb3RvdHlwZS5fdGFnZ2VkTGl0ZXJhbCA9IGZ1bmN0aW9uIChwYXJ0cykge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50c1xuICB2YXIgc3RyID0gJydcbiAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCwgaSkge1xuICAgIHZhciBhcmcgPSBhcmdzW2kgKyAxXVxuICAgIHN0ciArPSBwYXJ0XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBzdHIgKz0gJyVzJ1xuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHRoaXMuX18uYXBwbHkobnVsbCwgW3N0cl0uY29uY2F0KFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpXG59XG5cblkxOE4ucHJvdG90eXBlLl9lbnF1ZXVlV3JpdGUgPSBmdW5jdGlvbiAod29yaykge1xuICB0aGlzLndyaXRlUXVldWUucHVzaCh3b3JrKVxuICBpZiAodGhpcy53cml0ZVF1ZXVlLmxlbmd0aCA9PT0gMSkgdGhpcy5fcHJvY2Vzc1dyaXRlUXVldWUoKVxufVxuXG5ZMThOLnByb3RvdHlwZS5fcHJvY2Vzc1dyaXRlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBfdGhpcyA9IHRoaXNcbiAgdmFyIHdvcmsgPSB0aGlzLndyaXRlUXVldWVbMF1cblxuICAvLyBkZXN0cnVjdHVyZSB0aGUgZW5xdWV1ZWQgd29yay5cbiAgdmFyIGRpcmVjdG9yeSA9IHdvcmtbMF1cbiAgdmFyIGxvY2FsZSA9IHdvcmtbMV1cbiAgdmFyIGNiID0gd29ya1syXVxuXG4gIHZhciBsYW5ndWFnZUZpbGUgPSB0aGlzLl9yZXNvbHZlTG9jYWxlRmlsZShkaXJlY3RvcnksIGxvY2FsZSlcbiAgdmFyIHNlcmlhbGl6ZWRMb2NhbGUgPSBKU09OLnN0cmluZ2lmeSh0aGlzLmNhY2hlW2xvY2FsZV0sIG51bGwsIDIpXG5cbiAgZnMud3JpdGVGaWxlKGxhbmd1YWdlRmlsZSwgc2VyaWFsaXplZExvY2FsZSwgJ3V0Zi04JywgZnVuY3Rpb24gKGVycikge1xuICAgIF90aGlzLndyaXRlUXVldWUuc2hpZnQoKVxuICAgIGlmIChfdGhpcy53cml0ZVF1ZXVlLmxlbmd0aCA+IDApIF90aGlzLl9wcm9jZXNzV3JpdGVRdWV1ZSgpXG4gICAgY2IoZXJyKVxuICB9KVxufVxuXG5ZMThOLnByb3RvdHlwZS5fcmVhZExvY2FsZUZpbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsb2NhbGVMb29rdXAgPSB7fVxuICB2YXIgbGFuZ3VhZ2VGaWxlID0gdGhpcy5fcmVzb2x2ZUxvY2FsZUZpbGUodGhpcy5kaXJlY3RvcnksIHRoaXMubG9jYWxlKVxuXG4gIHRyeSB7XG4gICAgbG9jYWxlTG9va3VwID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMobGFuZ3VhZ2VGaWxlLCAndXRmLTgnKSlcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIFN5bnRheEVycm9yKSB7XG4gICAgICBlcnIubWVzc2FnZSA9ICdzeW50YXggZXJyb3IgaW4gJyArIGxhbmd1YWdlRmlsZVxuICAgIH1cblxuICAgIGlmIChlcnIuY29kZSA9PT0gJ0VOT0VOVCcpIGxvY2FsZUxvb2t1cCA9IHt9XG4gICAgZWxzZSB0aHJvdyBlcnJcbiAgfVxuXG4gIHRoaXMuY2FjaGVbdGhpcy5sb2NhbGVdID0gbG9jYWxlTG9va3VwXG59XG5cblkxOE4ucHJvdG90eXBlLl9yZXNvbHZlTG9jYWxlRmlsZSA9IGZ1bmN0aW9uIChkaXJlY3RvcnksIGxvY2FsZSkge1xuICB2YXIgZmlsZSA9IHBhdGgucmVzb2x2ZShkaXJlY3RvcnksICcuLycsIGxvY2FsZSArICcuanNvbicpXG4gIGlmICh0aGlzLmZhbGxiYWNrVG9MYW5ndWFnZSAmJiAhdGhpcy5fZmlsZUV4aXN0c1N5bmMoZmlsZSkgJiYgfmxvY2FsZS5sYXN0SW5kZXhPZignXycpKSB7XG4gICAgLy8gYXR0ZW1wdCBmYWxsYmFjayB0byBsYW5ndWFnZSBvbmx5XG4gICAgdmFyIGxhbmd1YWdlRmlsZSA9IHBhdGgucmVzb2x2ZShkaXJlY3RvcnksICcuLycsIGxvY2FsZS5zcGxpdCgnXycpWzBdICsgJy5qc29uJylcbiAgICBpZiAodGhpcy5fZmlsZUV4aXN0c1N5bmMobGFuZ3VhZ2VGaWxlKSkgZmlsZSA9IGxhbmd1YWdlRmlsZVxuICB9XG4gIHJldHVybiBmaWxlXG59XG5cbi8vIHRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBmcy5leGlzdHNTeW5jKCkgXCJ3aWxsIGJlIGRlcHJlY2F0ZWRcIlxuLy8gc2VlIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZnMuaHRtbCNmc19mc19leGlzdHNzeW5jX3BhdGhcblkxOE4ucHJvdG90eXBlLl9maWxlRXhpc3RzU3luYyA9IGZ1bmN0aW9uIChmaWxlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZzLnN0YXRTeW5jKGZpbGUpLmlzRmlsZSgpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cblkxOE4ucHJvdG90eXBlLl9fbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gIHZhciBzaW5ndWxhciA9IGFyZ3Muc2hpZnQoKVxuICB2YXIgcGx1cmFsID0gYXJncy5zaGlmdCgpXG4gIHZhciBxdWFudGl0eSA9IGFyZ3Muc2hpZnQoKVxuXG4gIHZhciBjYiA9IGZ1bmN0aW9uICgpIHt9IC8vIHN0YXJ0IHdpdGggbm9vcC5cbiAgaWYgKHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIGNiID0gYXJncy5wb3AoKVxuXG4gIGlmICghdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV0pIHRoaXMuX3JlYWRMb2NhbGVGaWxlKClcblxuICB2YXIgc3RyID0gcXVhbnRpdHkgPT09IDEgPyBzaW5ndWxhciA6IHBsdXJhbFxuICBpZiAodGhpcy5jYWNoZVt0aGlzLmxvY2FsZV1bc2luZ3VsYXJdKSB7XG4gICAgc3RyID0gdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV1bc2luZ3VsYXJdW3F1YW50aXR5ID09PSAxID8gJ29uZScgOiAnb3RoZXInXVxuICB9XG5cbiAgLy8gd2UndmUgb2JzZXJ2ZWQgYSBuZXcgc3RyaW5nLCB1cGRhdGUgdGhlIGxhbmd1YWdlIGZpbGUuXG4gIGlmICghdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV1bc2luZ3VsYXJdICYmIHRoaXMudXBkYXRlRmlsZXMpIHtcbiAgICB0aGlzLmNhY2hlW3RoaXMubG9jYWxlXVtzaW5ndWxhcl0gPSB7XG4gICAgICBvbmU6IHNpbmd1bGFyLFxuICAgICAgb3RoZXI6IHBsdXJhbFxuICAgIH1cblxuICAgIC8vIGluY2x1ZGUgdGhlIGN1cnJlbnQgZGlyZWN0b3J5IGFuZCBsb2NhbGUsXG4gICAgLy8gc2luY2UgdGhlc2UgdmFsdWVzIGNvdWxkIGNoYW5nZSBiZWZvcmUgdGhlXG4gICAgLy8gd3JpdGUgaXMgcGVyZm9ybWVkLlxuICAgIHRoaXMuX2VucXVldWVXcml0ZShbdGhpcy5kaXJlY3RvcnksIHRoaXMubG9jYWxlLCBjYl0pXG4gIH0gZWxzZSB7XG4gICAgY2IoKVxuICB9XG5cbiAgLy8gaWYgYSAlZCBwbGFjZWhvbGRlciBpcyBwcm92aWRlZCwgYWRkIHF1YW50aXR5XG4gIC8vIHRvIHRoZSBhcmd1bWVudHMgZXhwYW5kZWQgYnkgdXRpbC5mb3JtYXQuXG4gIHZhciB2YWx1ZXMgPSBbc3RyXVxuICBpZiAofnN0ci5pbmRleE9mKCclZCcpKSB2YWx1ZXMucHVzaChxdWFudGl0eSlcblxuICByZXR1cm4gdXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgdmFsdWVzLmNvbmNhdChhcmdzKSlcbn1cblxuWTE4Ti5wcm90b3R5cGUuc2V0TG9jYWxlID0gZnVuY3Rpb24gKGxvY2FsZSkge1xuICB0aGlzLmxvY2FsZSA9IGxvY2FsZVxufVxuXG5ZMThOLnByb3RvdHlwZS5nZXRMb2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmxvY2FsZVxufVxuXG5ZMThOLnByb3RvdHlwZS51cGRhdGVMb2NhbGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIGlmICghdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV0pIHRoaXMuX3JlYWRMb2NhbGVGaWxlKClcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgdGhpcy5jYWNoZVt0aGlzLmxvY2FsZV1ba2V5XSA9IG9ialtrZXldXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuICB2YXIgeTE4biA9IG5ldyBZMThOKG9wdHMpXG5cbiAgLy8gYmluZCBhbGwgZnVuY3Rpb25zIHRvIHkxOG4sIHNvIHRoYXRcbiAgLy8gdGhleSBjYW4gYmUgdXNlZCBpbiBpc29sYXRpb24uXG4gIGZvciAodmFyIGtleSBpbiB5MThuKSB7XG4gICAgaWYgKHR5cGVvZiB5MThuW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHkxOG5ba2V5XSA9IHkxOG5ba2V5XS5iaW5kKHkxOG4pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHkxOG5cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///66\n")},function(module,exports,__webpack_require__){"use strict";eval("\nconst path = __webpack_require__(0);\nconst locatePath = __webpack_require__(68);\nconst pathExists = __webpack_require__(72);\n\nconst stop = Symbol('findUp.stop');\n\nmodule.exports = async (name, options = {}) => {\n\tlet directory = path.resolve(options.cwd || '');\n\tconst {root} = path.parse(directory);\n\tconst paths = [].concat(name);\n\n\tconst runMatcher = async locateOptions => {\n\t\tif (typeof name !== 'function') {\n\t\t\treturn locatePath(paths, locateOptions);\n\t\t}\n\n\t\tconst foundPath = await name(locateOptions.cwd);\n\t\tif (typeof foundPath === 'string') {\n\t\t\treturn locatePath([foundPath], locateOptions);\n\t\t}\n\n\t\treturn foundPath;\n\t};\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\t// eslint-disable-next-line no-await-in-loop\n\t\tconst foundPath = await runMatcher({...options, cwd: directory});\n\n\t\tif (foundPath === stop) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (foundPath) {\n\t\t\treturn path.resolve(directory, foundPath);\n\t\t}\n\n\t\tif (directory === root) {\n\t\t\treturn;\n\t\t}\n\n\t\tdirectory = path.dirname(directory);\n\t}\n};\n\nmodule.exports.sync = (name, options = {}) => {\n\tlet directory = path.resolve(options.cwd || '');\n\tconst {root} = path.parse(directory);\n\tconst paths = [].concat(name);\n\n\tconst runMatcher = locateOptions => {\n\t\tif (typeof name !== 'function') {\n\t\t\treturn locatePath.sync(paths, locateOptions);\n\t\t}\n\n\t\tconst foundPath = name(locateOptions.cwd);\n\t\tif (typeof foundPath === 'string') {\n\t\t\treturn locatePath.sync([foundPath], locateOptions);\n\t\t}\n\n\t\treturn foundPath;\n\t};\n\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tconst foundPath = runMatcher({...options, cwd: directory});\n\n\t\tif (foundPath === stop) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (foundPath) {\n\t\t\treturn path.resolve(directory, foundPath);\n\t\t}\n\n\t\tif (directory === root) {\n\t\t\treturn;\n\t\t}\n\n\t\tdirectory = path.dirname(directory);\n\t}\n};\n\nmodule.exports.exists = pathExists;\n\nmodule.exports.sync.exists = pathExists.sync;\n\nmodule.exports.stop = stop;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3Mvbm9kZV9tb2R1bGVzL2ZpbmQtdXAvaW5kZXguanM/NmQ5YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLGFBQWEsbUJBQU8sQ0FBQyxDQUFNO0FBQzNCLG1CQUFtQixtQkFBTyxDQUFDLEVBQWE7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsRUFBYTs7QUFFeEM7O0FBRUEsMENBQTBDO0FBQzFDO0FBQ0EsUUFBUSxLQUFLO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsMkJBQTJCOztBQUVqRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDO0FBQ3pDO0FBQ0EsUUFBUSxLQUFLO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQjs7QUFFM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBIiwiZmlsZSI6IjY3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGxvY2F0ZVBhdGggPSByZXF1aXJlKCdsb2NhdGUtcGF0aCcpO1xuY29uc3QgcGF0aEV4aXN0cyA9IHJlcXVpcmUoJ3BhdGgtZXhpc3RzJyk7XG5cbmNvbnN0IHN0b3AgPSBTeW1ib2woJ2ZpbmRVcC5zdG9wJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmMgKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuXHRsZXQgZGlyZWN0b3J5ID0gcGF0aC5yZXNvbHZlKG9wdGlvbnMuY3dkIHx8ICcnKTtcblx0Y29uc3Qge3Jvb3R9ID0gcGF0aC5wYXJzZShkaXJlY3RvcnkpO1xuXHRjb25zdCBwYXRocyA9IFtdLmNvbmNhdChuYW1lKTtcblxuXHRjb25zdCBydW5NYXRjaGVyID0gYXN5bmMgbG9jYXRlT3B0aW9ucyA9PiB7XG5cdFx0aWYgKHR5cGVvZiBuYW1lICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gbG9jYXRlUGF0aChwYXRocywgbG9jYXRlT3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZm91bmRQYXRoID0gYXdhaXQgbmFtZShsb2NhdGVPcHRpb25zLmN3ZCk7XG5cdFx0aWYgKHR5cGVvZiBmb3VuZFBhdGggPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gbG9jYXRlUGF0aChbZm91bmRQYXRoXSwgbG9jYXRlT3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZvdW5kUGF0aDtcblx0fTtcblxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG5cdHdoaWxlICh0cnVlKSB7XG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWF3YWl0LWluLWxvb3Bcblx0XHRjb25zdCBmb3VuZFBhdGggPSBhd2FpdCBydW5NYXRjaGVyKHsuLi5vcHRpb25zLCBjd2Q6IGRpcmVjdG9yeX0pO1xuXG5cdFx0aWYgKGZvdW5kUGF0aCA9PT0gc3RvcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChmb3VuZFBhdGgpIHtcblx0XHRcdHJldHVybiBwYXRoLnJlc29sdmUoZGlyZWN0b3J5LCBmb3VuZFBhdGgpO1xuXHRcdH1cblxuXHRcdGlmIChkaXJlY3RvcnkgPT09IHJvb3QpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRkaXJlY3RvcnkgPSBwYXRoLmRpcm5hbWUoZGlyZWN0b3J5KTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMuc3luYyA9IChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcblx0bGV0IGRpcmVjdG9yeSA9IHBhdGgucmVzb2x2ZShvcHRpb25zLmN3ZCB8fCAnJyk7XG5cdGNvbnN0IHtyb290fSA9IHBhdGgucGFyc2UoZGlyZWN0b3J5KTtcblx0Y29uc3QgcGF0aHMgPSBbXS5jb25jYXQobmFtZSk7XG5cblx0Y29uc3QgcnVuTWF0Y2hlciA9IGxvY2F0ZU9wdGlvbnMgPT4ge1xuXHRcdGlmICh0eXBlb2YgbmFtZSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0cmV0dXJuIGxvY2F0ZVBhdGguc3luYyhwYXRocywgbG9jYXRlT3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Y29uc3QgZm91bmRQYXRoID0gbmFtZShsb2NhdGVPcHRpb25zLmN3ZCk7XG5cdFx0aWYgKHR5cGVvZiBmb3VuZFBhdGggPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gbG9jYXRlUGF0aC5zeW5jKFtmb3VuZFBhdGhdLCBsb2NhdGVPcHRpb25zKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZm91bmRQYXRoO1xuXHR9O1xuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cblx0d2hpbGUgKHRydWUpIHtcblx0XHRjb25zdCBmb3VuZFBhdGggPSBydW5NYXRjaGVyKHsuLi5vcHRpb25zLCBjd2Q6IGRpcmVjdG9yeX0pO1xuXG5cdFx0aWYgKGZvdW5kUGF0aCA9PT0gc3RvcCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmIChmb3VuZFBhdGgpIHtcblx0XHRcdHJldHVybiBwYXRoLnJlc29sdmUoZGlyZWN0b3J5LCBmb3VuZFBhdGgpO1xuXHRcdH1cblxuXHRcdGlmIChkaXJlY3RvcnkgPT09IHJvb3QpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRkaXJlY3RvcnkgPSBwYXRoLmRpcm5hbWUoZGlyZWN0b3J5KTtcblx0fVxufTtcblxubW9kdWxlLmV4cG9ydHMuZXhpc3RzID0gcGF0aEV4aXN0cztcblxubW9kdWxlLmV4cG9ydHMuc3luYy5leGlzdHMgPSBwYXRoRXhpc3RzLnN5bmM7XG5cbm1vZHVsZS5leHBvcnRzLnN0b3AgPSBzdG9wO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///67\n")},function(module,exports,__webpack_require__){"use strict";eval("\nconst path = __webpack_require__(0);\nconst fs = __webpack_require__(2);\nconst {promisify} = __webpack_require__(3);\nconst pLocate = __webpack_require__(69);\n\nconst fsStat = promisify(fs.stat);\nconst fsLStat = promisify(fs.lstat);\n\nconst typeMappings = {\n\tdirectory: 'isDirectory',\n\tfile: 'isFile'\n};\n\nfunction checkType({type}) {\n\tif (type in typeMappings) {\n\t\treturn;\n\t}\n\n\tthrow new Error(`Invalid type specified: ${type}`);\n}\n\nconst matchType = (type, stat) => type === undefined || stat[typeMappings[type]]();\n\nmodule.exports = async (paths, options) => {\n\toptions = {\n\t\tcwd: process.cwd(),\n\t\ttype: 'file',\n\t\tallowSymlinks: true,\n\t\t...options\n\t};\n\tcheckType(options);\n\tconst statFn = options.allowSymlinks ? fsStat : fsLStat;\n\n\treturn pLocate(paths, async path_ => {\n\t\ttry {\n\t\t\tconst stat = await statFn(path.resolve(options.cwd, path_));\n\t\t\treturn matchType(options.type, stat);\n\t\t} catch (_) {\n\t\t\treturn false;\n\t\t}\n\t}, options);\n};\n\nmodule.exports.sync = (paths, options) => {\n\toptions = {\n\t\tcwd: process.cwd(),\n\t\tallowSymlinks: true,\n\t\ttype: 'file',\n\t\t...options\n\t};\n\tcheckType(options);\n\tconst statFn = options.allowSymlinks ? fs.statSync : fs.lstatSync;\n\n\tfor (const path_ of paths) {\n\t\ttry {\n\t\t\tconst stat = statFn(path.resolve(options.cwd, path_));\n\n\t\t\tif (matchType(options.type, stat)) {\n\t\t\t\treturn path_;\n\t\t\t}\n\t\t} catch (_) {\n\t\t}\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3Mvbm9kZV9tb2R1bGVzL2xvY2F0ZS1wYXRoL2luZGV4LmpzP2MxMGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixhQUFhLG1CQUFPLENBQUMsQ0FBTTtBQUMzQixXQUFXLG1CQUFPLENBQUMsQ0FBSTtBQUN2QixPQUFPLFVBQVUsR0FBRyxtQkFBTyxDQUFDLENBQU07QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsRUFBVTs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLEtBQUs7QUFDakQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBIiwiZmlsZSI6IjY4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHtwcm9taXNpZnl9ID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgcExvY2F0ZSA9IHJlcXVpcmUoJ3AtbG9jYXRlJyk7XG5cbmNvbnN0IGZzU3RhdCA9IHByb21pc2lmeShmcy5zdGF0KTtcbmNvbnN0IGZzTFN0YXQgPSBwcm9taXNpZnkoZnMubHN0YXQpO1xuXG5jb25zdCB0eXBlTWFwcGluZ3MgPSB7XG5cdGRpcmVjdG9yeTogJ2lzRGlyZWN0b3J5Jyxcblx0ZmlsZTogJ2lzRmlsZSdcbn07XG5cbmZ1bmN0aW9uIGNoZWNrVHlwZSh7dHlwZX0pIHtcblx0aWYgKHR5cGUgaW4gdHlwZU1hcHBpbmdzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0dGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHR5cGUgc3BlY2lmaWVkOiAke3R5cGV9YCk7XG59XG5cbmNvbnN0IG1hdGNoVHlwZSA9ICh0eXBlLCBzdGF0KSA9PiB0eXBlID09PSB1bmRlZmluZWQgfHwgc3RhdFt0eXBlTWFwcGluZ3NbdHlwZV1dKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXN5bmMgKHBhdGhzLCBvcHRpb25zKSA9PiB7XG5cdG9wdGlvbnMgPSB7XG5cdFx0Y3dkOiBwcm9jZXNzLmN3ZCgpLFxuXHRcdHR5cGU6ICdmaWxlJyxcblx0XHRhbGxvd1N5bWxpbmtzOiB0cnVlLFxuXHRcdC4uLm9wdGlvbnNcblx0fTtcblx0Y2hlY2tUeXBlKG9wdGlvbnMpO1xuXHRjb25zdCBzdGF0Rm4gPSBvcHRpb25zLmFsbG93U3ltbGlua3MgPyBmc1N0YXQgOiBmc0xTdGF0O1xuXG5cdHJldHVybiBwTG9jYXRlKHBhdGhzLCBhc3luYyBwYXRoXyA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbnN0IHN0YXQgPSBhd2FpdCBzdGF0Rm4ocGF0aC5yZXNvbHZlKG9wdGlvbnMuY3dkLCBwYXRoXykpO1xuXHRcdFx0cmV0dXJuIG1hdGNoVHlwZShvcHRpb25zLnR5cGUsIHN0YXQpO1xuXHRcdH0gY2F0Y2ggKF8pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH0sIG9wdGlvbnMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMuc3luYyA9IChwYXRocywgb3B0aW9ucykgPT4ge1xuXHRvcHRpb25zID0ge1xuXHRcdGN3ZDogcHJvY2Vzcy5jd2QoKSxcblx0XHRhbGxvd1N5bWxpbmtzOiB0cnVlLFxuXHRcdHR5cGU6ICdmaWxlJyxcblx0XHQuLi5vcHRpb25zXG5cdH07XG5cdGNoZWNrVHlwZShvcHRpb25zKTtcblx0Y29uc3Qgc3RhdEZuID0gb3B0aW9ucy5hbGxvd1N5bWxpbmtzID8gZnMuc3RhdFN5bmMgOiBmcy5sc3RhdFN5bmM7XG5cblx0Zm9yIChjb25zdCBwYXRoXyBvZiBwYXRocykge1xuXHRcdHRyeSB7XG5cdFx0XHRjb25zdCBzdGF0ID0gc3RhdEZuKHBhdGgucmVzb2x2ZShvcHRpb25zLmN3ZCwgcGF0aF8pKTtcblxuXHRcdFx0aWYgKG1hdGNoVHlwZShvcHRpb25zLnR5cGUsIHN0YXQpKSB7XG5cdFx0XHRcdHJldHVybiBwYXRoXztcblx0XHRcdH1cblx0XHR9IGNhdGNoIChfKSB7XG5cdFx0fVxuXHR9XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///68\n")},function(module,exports,__webpack_require__){"use strict";eval("\nconst pLimit = __webpack_require__(70);\n\nclass EndError extends Error {\n\tconstructor(value) {\n\t\tsuper();\n\t\tthis.value = value;\n\t}\n}\n\n// The input can also be a promise, so we await it\nconst testElement = async (element, tester) => tester(await element);\n\n// The input can also be a promise, so we `Promise.all()` them both\nconst finder = async element => {\n\tconst values = await Promise.all(element);\n\tif (values[1] === true) {\n\t\tthrow new EndError(values[0]);\n\t}\n\n\treturn false;\n};\n\nconst pLocate = async (iterable, tester, options) => {\n\toptions = {\n\t\tconcurrency: Infinity,\n\t\tpreserveOrder: true,\n\t\t...options\n\t};\n\n\tconst limit = pLimit(options.concurrency);\n\n\t// Start all the promises concurrently with optional limit\n\tconst items = [...iterable].map(element => [element, limit(testElement, element, tester)]);\n\n\t// Check the promises either serially or concurrently\n\tconst checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);\n\n\ttry {\n\t\tawait Promise.all(items.map(element => checkLimit(finder, element)));\n\t} catch (error) {\n\t\tif (error instanceof EndError) {\n\t\t\treturn error.value;\n\t\t}\n\n\t\tthrow error;\n\t}\n};\n\nmodule.exports = pLocate;\n// TODO: Remove this for the next major release\nmodule.exports.default = pLocate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3Mvbm9kZV9tb2R1bGVzL3AtbG9jYXRlL2luZGV4LmpzP2Q2YTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixlQUFlLG1CQUFPLENBQUMsRUFBUzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjY5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuY29uc3QgcExpbWl0ID0gcmVxdWlyZSgncC1saW1pdCcpO1xuXG5jbGFzcyBFbmRFcnJvciBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3IodmFsdWUpIHtcblx0XHRzdXBlcigpO1xuXHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0fVxufVxuXG4vLyBUaGUgaW5wdXQgY2FuIGFsc28gYmUgYSBwcm9taXNlLCBzbyB3ZSBhd2FpdCBpdFxuY29uc3QgdGVzdEVsZW1lbnQgPSBhc3luYyAoZWxlbWVudCwgdGVzdGVyKSA9PiB0ZXN0ZXIoYXdhaXQgZWxlbWVudCk7XG5cbi8vIFRoZSBpbnB1dCBjYW4gYWxzbyBiZSBhIHByb21pc2UsIHNvIHdlIGBQcm9taXNlLmFsbCgpYCB0aGVtIGJvdGhcbmNvbnN0IGZpbmRlciA9IGFzeW5jIGVsZW1lbnQgPT4ge1xuXHRjb25zdCB2YWx1ZXMgPSBhd2FpdCBQcm9taXNlLmFsbChlbGVtZW50KTtcblx0aWYgKHZhbHVlc1sxXSA9PT0gdHJ1ZSkge1xuXHRcdHRocm93IG5ldyBFbmRFcnJvcih2YWx1ZXNbMF0pO1xuXHR9XG5cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgcExvY2F0ZSA9IGFzeW5jIChpdGVyYWJsZSwgdGVzdGVyLCBvcHRpb25zKSA9PiB7XG5cdG9wdGlvbnMgPSB7XG5cdFx0Y29uY3VycmVuY3k6IEluZmluaXR5LFxuXHRcdHByZXNlcnZlT3JkZXI6IHRydWUsXG5cdFx0Li4ub3B0aW9uc1xuXHR9O1xuXG5cdGNvbnN0IGxpbWl0ID0gcExpbWl0KG9wdGlvbnMuY29uY3VycmVuY3kpO1xuXG5cdC8vIFN0YXJ0IGFsbCB0aGUgcHJvbWlzZXMgY29uY3VycmVudGx5IHdpdGggb3B0aW9uYWwgbGltaXRcblx0Y29uc3QgaXRlbXMgPSBbLi4uaXRlcmFibGVdLm1hcChlbGVtZW50ID0+IFtlbGVtZW50LCBsaW1pdCh0ZXN0RWxlbWVudCwgZWxlbWVudCwgdGVzdGVyKV0pO1xuXG5cdC8vIENoZWNrIHRoZSBwcm9taXNlcyBlaXRoZXIgc2VyaWFsbHkgb3IgY29uY3VycmVudGx5XG5cdGNvbnN0IGNoZWNrTGltaXQgPSBwTGltaXQob3B0aW9ucy5wcmVzZXJ2ZU9yZGVyID8gMSA6IEluZmluaXR5KTtcblxuXHR0cnkge1xuXHRcdGF3YWl0IFByb21pc2UuYWxsKGl0ZW1zLm1hcChlbGVtZW50ID0+IGNoZWNrTGltaXQoZmluZGVyLCBlbGVtZW50KSkpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGlmIChlcnJvciBpbnN0YW5jZW9mIEVuZEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gZXJyb3IudmFsdWU7XG5cdFx0fVxuXG5cdFx0dGhyb3cgZXJyb3I7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcExvY2F0ZTtcbi8vIFRPRE86IFJlbW92ZSB0aGlzIGZvciB0aGUgbmV4dCBtYWpvciByZWxlYXNlXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcExvY2F0ZTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///69\n")},function(module,exports,__webpack_require__){"use strict";eval("\nconst pTry = __webpack_require__(71);\n\nconst pLimit = concurrency => {\n\tif (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {\n\t\treturn Promise.reject(new TypeError('Expected `concurrency` to be a number from 1 and up'));\n\t}\n\n\tconst queue = [];\n\tlet activeCount = 0;\n\n\tconst next = () => {\n\t\tactiveCount--;\n\n\t\tif (queue.length > 0) {\n\t\t\tqueue.shift()();\n\t\t}\n\t};\n\n\tconst run = (fn, resolve, ...args) => {\n\t\tactiveCount++;\n\n\t\tconst result = pTry(fn, ...args);\n\n\t\tresolve(result);\n\n\t\tresult.then(next, next);\n\t};\n\n\tconst enqueue = (fn, resolve, ...args) => {\n\t\tif (activeCount < concurrency) {\n\t\t\trun(fn, resolve, ...args);\n\t\t} else {\n\t\t\tqueue.push(run.bind(null, fn, resolve, ...args));\n\t\t}\n\t};\n\n\tconst generator = (fn, ...args) => new Promise(resolve => enqueue(fn, resolve, ...args));\n\tObject.defineProperties(generator, {\n\t\tactiveCount: {\n\t\t\tget: () => activeCount\n\t\t},\n\t\tpendingCount: {\n\t\t\tget: () => queue.length\n\t\t},\n\t\tclearQueue: {\n\t\t\tvalue: () => {\n\t\t\t\tqueue.length = 0;\n\t\t\t}\n\t\t}\n\t});\n\n\treturn generator;\n};\n\nmodule.exports = pLimit;\nmodule.exports.default = pLimit;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcC1saW1pdC9pbmRleC5qcz9jZGM0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLEVBQU87O0FBRTVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI3MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IHBUcnkgPSByZXF1aXJlKCdwLXRyeScpO1xuXG5jb25zdCBwTGltaXQgPSBjb25jdXJyZW5jeSA9PiB7XG5cdGlmICghKChOdW1iZXIuaXNJbnRlZ2VyKGNvbmN1cnJlbmN5KSB8fCBjb25jdXJyZW5jeSA9PT0gSW5maW5pdHkpICYmIGNvbmN1cnJlbmN5ID4gMCkpIHtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgYGNvbmN1cnJlbmN5YCB0byBiZSBhIG51bWJlciBmcm9tIDEgYW5kIHVwJykpO1xuXHR9XG5cblx0Y29uc3QgcXVldWUgPSBbXTtcblx0bGV0IGFjdGl2ZUNvdW50ID0gMDtcblxuXHRjb25zdCBuZXh0ID0gKCkgPT4ge1xuXHRcdGFjdGl2ZUNvdW50LS07XG5cblx0XHRpZiAocXVldWUubGVuZ3RoID4gMCkge1xuXHRcdFx0cXVldWUuc2hpZnQoKSgpO1xuXHRcdH1cblx0fTtcblxuXHRjb25zdCBydW4gPSAoZm4sIHJlc29sdmUsIC4uLmFyZ3MpID0+IHtcblx0XHRhY3RpdmVDb3VudCsrO1xuXG5cdFx0Y29uc3QgcmVzdWx0ID0gcFRyeShmbiwgLi4uYXJncyk7XG5cblx0XHRyZXNvbHZlKHJlc3VsdCk7XG5cblx0XHRyZXN1bHQudGhlbihuZXh0LCBuZXh0KTtcblx0fTtcblxuXHRjb25zdCBlbnF1ZXVlID0gKGZuLCByZXNvbHZlLCAuLi5hcmdzKSA9PiB7XG5cdFx0aWYgKGFjdGl2ZUNvdW50IDwgY29uY3VycmVuY3kpIHtcblx0XHRcdHJ1bihmbiwgcmVzb2x2ZSwgLi4uYXJncyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHF1ZXVlLnB1c2gocnVuLmJpbmQobnVsbCwgZm4sIHJlc29sdmUsIC4uLmFyZ3MpKTtcblx0XHR9XG5cdH07XG5cblx0Y29uc3QgZ2VuZXJhdG9yID0gKGZuLCAuLi5hcmdzKSA9PiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IGVucXVldWUoZm4sIHJlc29sdmUsIC4uLmFyZ3MpKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZ2VuZXJhdG9yLCB7XG5cdFx0YWN0aXZlQ291bnQ6IHtcblx0XHRcdGdldDogKCkgPT4gYWN0aXZlQ291bnRcblx0XHR9LFxuXHRcdHBlbmRpbmdDb3VudDoge1xuXHRcdFx0Z2V0OiAoKSA9PiBxdWV1ZS5sZW5ndGhcblx0XHR9LFxuXHRcdGNsZWFyUXVldWU6IHtcblx0XHRcdHZhbHVlOiAoKSA9PiB7XG5cdFx0XHRcdHF1ZXVlLmxlbmd0aCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gZ2VuZXJhdG9yO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBwTGltaXQ7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcExpbWl0O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///70\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nconst pTry = (fn, ...arguments_) => new Promise(resolve => {\n\tresolve(fn(...arguments_));\n});\n\nmodule.exports = pTry;\n// TODO: remove this in the next major version\nmodule.exports.default = pTry;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcC10cnkvaW5kZXguanM/ZDgzNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EiLCJmaWxlIjoiNzEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHBUcnkgPSAoZm4sIC4uLmFyZ3VtZW50c18pID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuXHRyZXNvbHZlKGZuKC4uLmFyZ3VtZW50c18pKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBUcnk7XG4vLyBUT0RPOiByZW1vdmUgdGhpcyBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcFRyeTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///71\n")},function(module,exports,__webpack_require__){"use strict";eval("\nconst fs = __webpack_require__(2);\nconst {promisify} = __webpack_require__(3);\n\nconst pAccess = promisify(fs.access);\n\nmodule.exports = async path => {\n\ttry {\n\t\tawait pAccess(path);\n\t\treturn true;\n\t} catch (_) {\n\t\treturn false;\n\t}\n};\n\nmodule.exports.sync = path => {\n\ttry {\n\t\tfs.accessSync(path);\n\t\treturn true;\n\t} catch (_) {\n\t\treturn false;\n\t}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3Mvbm9kZV9tb2R1bGVzL3BhdGgtZXhpc3RzL2luZGV4LmpzPzkzYTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixXQUFXLG1CQUFPLENBQUMsQ0FBSTtBQUN2QixPQUFPLFVBQVUsR0FBRyxtQkFBTyxDQUFDLENBQU07O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EiLCJmaWxlIjoiNzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7cHJvbWlzaWZ5fSA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3QgcEFjY2VzcyA9IHByb21pc2lmeShmcy5hY2Nlc3MpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzeW5jIHBhdGggPT4ge1xuXHR0cnkge1xuXHRcdGF3YWl0IHBBY2Nlc3MocGF0aCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKF8pIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLnN5bmMgPSBwYXRoID0+IHtcblx0dHJ5IHtcblx0XHRmcy5hY2Nlc3NTeW5jKHBhdGgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChfKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///72\n")},function(module,exports,__webpack_require__){eval("module.exports = function (_require) {\n  _require = _require || __webpack_require__(74)\n  var main = _require.main\n  if (main && isIISNode(main)) return handleIISNode(main)\n  else return main ? main.filename : process.cwd()\n}\n\nfunction isIISNode (main) {\n  return /\\\\iisnode\\\\/.test(main.filename)\n}\n\nfunction handleIISNode (main) {\n  if (!main.children.length) {\n    return main.filename\n  } else {\n    return main.children[0].filename\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVxdWlyZS1tYWluLWZpbGVuYW1lL2luZGV4LmpzPzM1NTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSx5QkFBeUIsdUJBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJmaWxlIjoiNzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChfcmVxdWlyZSkge1xuICBfcmVxdWlyZSA9IF9yZXF1aXJlIHx8IHJlcXVpcmVcbiAgdmFyIG1haW4gPSBfcmVxdWlyZS5tYWluXG4gIGlmIChtYWluICYmIGlzSUlTTm9kZShtYWluKSkgcmV0dXJuIGhhbmRsZUlJU05vZGUobWFpbilcbiAgZWxzZSByZXR1cm4gbWFpbiA/IG1haW4uZmlsZW5hbWUgOiBwcm9jZXNzLmN3ZCgpXG59XG5cbmZ1bmN0aW9uIGlzSUlTTm9kZSAobWFpbikge1xuICByZXR1cm4gL1xcXFxpaXNub2RlXFxcXC8udGVzdChtYWluLmZpbGVuYW1lKVxufVxuXG5mdW5jdGlvbiBoYW5kbGVJSVNOb2RlIChtYWluKSB7XG4gIGlmICghbWFpbi5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICByZXR1cm4gbWFpbi5maWxlbmFtZVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYWluLmNoaWxkcmVuWzBdLmZpbGVuYW1lXG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///73\n")},function(module,exports){eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 74;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVxdWlyZS1tYWluLWZpbGVuYW1lIHN5bmM/OTI1MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBIiwiZmlsZSI6Ijc0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gd2VicGFja0VtcHR5Q29udGV4dChyZXEpIHtcblx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRlLmNvZGUgPSAnTU9EVUxFX05PVF9GT1VORCc7XG5cdHRocm93IGU7XG59XG53ZWJwYWNrRW1wdHlDb250ZXh0LmtleXMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9O1xud2VicGFja0VtcHR5Q29udGV4dC5yZXNvbHZlID0gd2VicGFja0VtcHR5Q29udGV4dDtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0VtcHR5Q29udGV4dDtcbndlYnBhY2tFbXB0eUNvbnRleHQuaWQgPSA3NDsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///74\n")},function(module,exports,__webpack_require__){"use strict";eval("\n// Call this function in a another function to find out the file from\n// which that function was called from. (Inspects the v8 stack trace)\n//\n// Inspired by http://stackoverflow.com/questions/13227489\nmodule.exports = function getCallerFile(position) {\n    if (position === void 0) { position = 2; }\n    if (position >= Error.stackTraceLimit) {\n        throw new TypeError('getCallerFile(position) requires position be less then Error.stackTraceLimit but position was: `' + position + '` and Error.stackTraceLimit was: `' + Error.stackTraceLimit + '`');\n    }\n    var oldPrepareStackTrace = Error.prepareStackTrace;\n    Error.prepareStackTrace = function (_, stack) { return stack; };\n    var stack = new Error().stack;\n    Error.prepareStackTrace = oldPrepareStackTrace;\n    if (stack !== null && typeof stack === 'object') {\n        // stack[0] holds this file\n        // stack[1] holds where this function was called\n        // stack[2] holds the file we're interested in\n        return stack[position] ? stack[position].getFileName() : undefined;\n    }\n};\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2V0LWNhbGxlci1maWxlL2luZGV4LmpzP2RkZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsY0FBYztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI3NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLy8gQ2FsbCB0aGlzIGZ1bmN0aW9uIGluIGEgYW5vdGhlciBmdW5jdGlvbiB0byBmaW5kIG91dCB0aGUgZmlsZSBmcm9tXG4vLyB3aGljaCB0aGF0IGZ1bmN0aW9uIHdhcyBjYWxsZWQgZnJvbS4gKEluc3BlY3RzIHRoZSB2OCBzdGFjayB0cmFjZSlcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMjI3NDg5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldENhbGxlckZpbGUocG9zaXRpb24pIHtcbiAgICBpZiAocG9zaXRpb24gPT09IHZvaWQgMCkgeyBwb3NpdGlvbiA9IDI7IH1cbiAgICBpZiAocG9zaXRpb24gPj0gRXJyb3Iuc3RhY2tUcmFjZUxpbWl0KSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dldENhbGxlckZpbGUocG9zaXRpb24pIHJlcXVpcmVzIHBvc2l0aW9uIGJlIGxlc3MgdGhlbiBFcnJvci5zdGFja1RyYWNlTGltaXQgYnV0IHBvc2l0aW9uIHdhczogYCcgKyBwb3NpdGlvbiArICdgIGFuZCBFcnJvci5zdGFja1RyYWNlTGltaXQgd2FzOiBgJyArIEVycm9yLnN0YWNrVHJhY2VMaW1pdCArICdgJyk7XG4gICAgfVxuICAgIHZhciBvbGRQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gZnVuY3Rpb24gKF8sIHN0YWNrKSB7IHJldHVybiBzdGFjazsgfTtcbiAgICB2YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IG9sZFByZXBhcmVTdGFja1RyYWNlO1xuICAgIGlmIChzdGFjayAhPT0gbnVsbCAmJiB0eXBlb2Ygc3RhY2sgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIHN0YWNrWzBdIGhvbGRzIHRoaXMgZmlsZVxuICAgICAgICAvLyBzdGFja1sxXSBob2xkcyB3aGVyZSB0aGlzIGZ1bmN0aW9uIHdhcyBjYWxsZWRcbiAgICAgICAgLy8gc3RhY2tbMl0gaG9sZHMgdGhlIGZpbGUgd2UncmUgaW50ZXJlc3RlZCBpblxuICAgICAgICByZXR1cm4gc3RhY2tbcG9zaXRpb25dID8gc3RhY2tbcG9zaXRpb25dLmdldEZpbGVOYW1lKCkgOiB1bmRlZmluZWQ7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///75\n")},function(module,exports){eval("function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 76;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMveWFyZ3Mgc3luYz8yZjMwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0EiLCJmaWxlIjoiNzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiB3ZWJwYWNrRW1wdHlDb250ZXh0KHJlcSkge1xuXHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0dGhyb3cgZTtcbn1cbndlYnBhY2tFbXB0eUNvbnRleHQua2V5cyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH07XG53ZWJwYWNrRW1wdHlDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSB3ZWJwYWNrRW1wdHlDb250ZXh0O1xud2VicGFja0VtcHR5Q29udGV4dC5pZCA9IDc2OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///76\n")}]);